\chapter{Input and Output}\label{chap:io}

\firstchar{J}ava provides a rich array of classes for dealing with
input and output.  At the basic level, input and output streams
provide a means to transfer data consisting of a sequence of bytes.
Data may be transferred among memory with memory-backed streams, the
file system via file streams or memory mapped files, the terminal via
standard input and output streams, and remote servers via sockets.
Stream filters may be put in place to compress or decompress data.
Streams that block awaiting input or output may be dealt with in
threads.

Bytes may encode anything, but we are particularly interested in the
case of natural language text data, with or without document
structure.  To support streams of \code{char} values, Java provides
\code{char} streams as byte streams.  In order to crete a character
stream from byte stream, the character encoding must be known.

We are also interested in sequences of bytes that encode Java objects
through serialization.  We use serialized objects to represent models
and their components, such as tokenizers.  


\section{Files}

Java provides the class \code{File} in the \code{java.io} package for
representing files and directories on the local file system.
Underlyingly, an instance of \code{File} is nothing more than a string
representing a path coupled with a convenient set of utility methods,
some of which access the underlying file system.  

\subsection{Relative vs.\ Absolute Paths}

Files may be either relative or absolute.  An absolute path name
provides a full description of where to find a file on the system in
question.  A relative path picks out a file or directory starting from
a root directory (the form of which will be operating system
specific).  Relative paths may pick out different resources in
different situations depending on the base directory.

The static method \code{File.listRoots()} provides an array of all of
the available root directories.  We wrote a simple demo in the
class \code{ListRoots}, the heart of which is
%
\codeblock{ListRoots.1}
%
Running it on my Windows machine returns
%
\commandlinefollow{ant list-roots}
\begin{verbatim}
Root Directories
     C:\
     E:\
\end{verbatim}
%
The root directories \code{C:\bk} and \code{E:\bk} correspond to my
two drives, but they could also correspond to partitions of a single
drive or a redundant array of independent disks (RAID), or even a
section of memory acting like a disk drive.

\subsubsection{Root of Relative Paths}

In Java, relative paths are interpreted relative to the directory from
which Java was called.  The same goes for Ant, except when a \code{basedir}
attribute is set on the top-level \code{project} element.  

A consequence of this behavior is that the empty string (\code{""}) is
a path that picks out the directory from which Java was called.


\subsection{Windows vs.\ UNIX File Conventions}

Due to the differing setup of the operating systems, \code{File}
objects behave differently on different platforms.  In all cases, they
respect the conventions of the file system on which they are run, but
it requires some care to create portable code or Ant tasks that involve
files.

On either Windows or UNIX, files are organized hierarchically into
directories under one or more root directories.  Each file other
than one of the root directories has a parent directory.  The most
prominent difference between the two operating system flavors is
that Windows uses a backslash (\code{\bk}), whereas UNIX uses
a forward slash (\code{/}) to separate directories and file names
in a path.

In Unix, there is a single root directory for the file system, and
absolute path names will start with a forward slash (\code{/}).  

In Windows, there may be more than one root directory.  Each root
directory is written as a drive letter followed by a colon-backslash
(\code{:\bk}), as in \code{C:\bk} for the root directory on the drive
named \code{C}.  

Windows also allows Universal Naming Convention (UNC) network paths,
which begin with two backslashes (\code{\bk\bk}) followed by the name
of the computer or device on the network.  For instance,
\code{{\bk\bk}MONTAGUE} is the root of the shared files on the network
computer named
\code{MONTAGUE}.  Each networked Windows computer makes visible its 
top-level shared files.  

The biggest difference is that in Windows, file names are not case
sensitive.  Thus \code{FOO}, \code{foo}, and \code{Foo} will all pick
out the same file.  


\subsection{Constructing a \code{File}}

There are four \code{File} constructors.  The simplest,
\code{File(String)}, simply takes a path name to construct
a file object.  The string may be anything, but separator characters
will be parsed and normalized.

Conveniently, Java lets you use either forward (Unix)
or backward (Windows) slashes interchangeably, as does Ant.  Thus in
Windows, I can use Unix-style forward slashes with the same effect as
backward slashes.  For example, \code{new File("c:/foo")}, constructs
the same object as \code{new File("c:{\bk}foo")}.  

There are also two-argument constructors taking a parent directory and
a file name.  The parent may be specified as a string using the constructor
\code{File(String,String)} or as a file itself, using the constructor
\code{File(File,String)}.

\subsubsection{URI/URL to File Conversion}

There is a fourth \code{File} constructor that takes a uniform
resource identifier (URI) argument, \code{File(URI)} (see
\refsec{uri-url-urn} for more information on URIs and URLs).  The
\code{URI} class is in the \code{java.net} package, which comes
standard with Java.

URIs for files have the form
\code{file://}\codeVar{host}\code{/}\codeVar{path}, where the
(optional) \codeVar{host} picks out a domain name and \codeVar{path} a
file path.  If the \codeVar{host} is not specified, the form devolves
to \code{file:///}\codeVar{path}, and the host is assumed to be the
the so-called localhost, the machine on which Java is running.

It is also possible to convert an instance of \code{File} to a URI,
using the method \code{toURI()} in \code{File}.  

It is also possible to get a uniform resource locator (URL) from a
file, by first converting to a URI and then calling the \code{URI}
method \code{toURL()}, which returns an instance of \code{URL}, also
in \code{java.net}.



\subsection{Getting a File's Canonical Path}

The method \code{getCanonicalFile()} returns a \code{File} based on an
absolute path with a conventionalized name.  For instance, if I happen
to be running in directory \code{c:{\bk}lpb} (on Windows), then the
following two expressions return equivalent files
%
\begin{verbatim}
new File("c:\lpb\Foo").getCanonicalPath()
\end{verbatim}
%
%
\begin{verbatim}
new File("foo").getCanonicalPath();
\end{verbatim}
%
Note that this is not truly a unique normal form.  The resulting files
will have different capitalizations for \code{foo} in this case, but
will be equivalent running under Windows.  Further note that the
canonical path is not used for equality (see \refsec{io-files-equality}).


\subsection{Exploring File Properties}

There are many methods on \code{File} objects which explore the type
of a file.  The method \code{exists()} tests whehter it exists,
\code{isAbsolute()} tests whether it
denotes an absolute path, \code{isDirectory()} whether it's directory,
\code{isFile()} whether it's an ordinary file, and
\code{isHidden()} tests whether it's hidden (starts with a period (\code{.}) in
Unix or is so marked by the operating system in Windows).

What permissions an application has for a file can be probed with
\code{canExecute()},\code{canRead()}, and \code{canWrite()}, all of
which return boolean values.

The time it was last modified, available through
\code{lastModified()}, returns the time as a \code{long} denoting
milliseconds since the epoch (the standard measure of time on
computers, and the basis of Java's date and calendar representations).

The number of bytes in a file is returned as a \code{long} by
\code{length()}.

The name of the file itself (everything but the parent), is returned
by \code{getName()}.  The methods \code{getParent()} and
\code{getParentFile()} return the parent directory as a string or as a
file, returning \code{null} if no parent was specified.

\subsection{Listing the Files in a Directory}

If a file is a directory, the method \code{listFiles()} returns an
array of files that the directory contains; it returns \code{null}
if the file's not a directory.  The files may also be listed
by name using \code{list()}. 

File listings may be filtered with an implementation of
\code{FileFilter}, an interface in \code{java.io} specifying a single
method \code{accept(File)} returning \code{true} if the file is
acceptable.  An older interface, \code{FilenameFilter}, is also
available for file name listings.


\subsubsection{LingPipe's \code{FileExtensionFilter}}

LingPipe provides a convenience class \code{FileExtensionFilter}, which
implements a \code{FileFilter} based on the extension of a file.  A
file's extension is here defined to mean the string after the final
period (\code{.}) in the file's name.  This is purely a convention for
naming files, which is especially useful in Windows or web browsers,
where each extension may be associated with a program to open or view
files with that extesnion.

A file extension filter takes a single or multiple strings
specified as an array.

A file extension filter is configured with a flag indicating
whether it should automatically accept directories or not, which
is convenient for recursive descents through a file system.  The
default for the unmarked constructors is to accept directories.

File extension filters would implement \code{FilenameFilter}
directly if they could, but it causes a conflict with the
polymorphic file method \code{listFiles(FilenameFilter)} and
\code{listFiles(FileFilter)}.  Instead, a file extension filter
provides a method \code{fileNameFilter()} which returns the
corresponding file name filter.  This is only necessary if you want to
test or list files by name rather than as files.

There are two static utility methods in the class \code{Files} in
\code{com.aliasi.util} that break file names apart into their suffix
and their base name.  The method \code{Files.extension(File)} returns
the extesnion of a file, consisting of the text after the final
period (\code{.}), or \code{null} if there is no period.  The method
\code{baseName(File)} returns the base name of a file, which excludes
the last period and extension.  For instance, a file named \code{io.tex}
has extension \code{tex} and base name \code{io}, whereas \code{foo.bar.baz}
has extension \code{baz} and base name \code{foo.bar}.


\subsection{Exploring Partitions}

Each file in an operating system exists in a partition, which is a
top-level root directory.  This is of interest because a file can't be
created in a partition that's larger than the available space in that
partition.

There are methods in \code{File} for exploring partitions.  The
methods \code{getFreeSpace()}, \code{getTotalSpace()}, and
\code{getUsableSpace()} return the respective amounts of space on the
partition as a \code{long} value.


\subsection{Comparison, Equality, and Hash Codes}\label{section:io-files-equality}

Equality of \code{File} objects is based on the underlying platform's
notion of equality.  For instance, on Windows, a file created with
\code{new File("Foo")} creates a file that is equal to \code{new
File("foo")}.  For better or worse, this comparison is based on the
platform's convention for file comparison, not by constructing a
canonical path and comparing that.  For instance, if I happen to
be running from directory \code{c:{\bk}lpb}, then 
\code{new File("foo")} is not equal to 
\code{c:{\bk}lpb{\bk}foo}, even though their canonical paths are
the same.


\subsection{Example Program Listing File Properties}

We wrote a simple program \code{FileProperties}, which given the name
of a file as an argument, lists all of its properties, its canonical
path, its URI form, and provides a listing if it is a directory.  The
code is just a litany of prints for all of the methods described above.

Calling it with the Ant target \code{file-properties}, it uses the
\code{file.in} Ant property to specify an argument.  We can call it
on its own source file using a relative path,
%
\commandlinefollow{ant -Dfile.in=src/com/lingpipe/book/io/FileProperties.java file-properties}
%
\begin{verbatim}
arg=|src/com/lingpipe/book/io/FileProperties.java|
toString()=src\com\lingpipe\book\io\FileProperties.java
getcanonicalFile()=C:\lpb\src\io\src\com\lingpipe\book\
     io\FileProperties.java
getName()=FileProperties.java
getParent()=src\com\lingpipe\book\io
toURI()=file:/c:/lpb/src/io/src/com/lingpipe/book/
     io/FileProperties.java
toURI().toURL()=file:/c:/lpb/src/io/src/com/lingpipe/
     book/io/FileProperties.java
exists()=true
isAbsolute()=false
isDirectory()=false
isFile()=true
isHidden()=false
hashCode()=-72025272
lastModified()=1279224002134
new Date(lastModified())=Thu Jul 15 16:00:02 EDT 2010
length()=2141
canRead()=true
canExecute()=true
canWrite()=true
getFreeSpace()=320493494272
getTotalSpace()=500105736192
getUsableSpace()=320493494272
listFiles()={    }
\end{verbatim}
%
The line breaks plus indents were inserted by hand so it'd fit in the
book.

\subsection{Creating, Deleting, and Modifying Files and Directories}

In addition to inspecting files, the \code{File} class lets you modify
files, too.  

Calling \code{createNewFile()} creates an empty file for the path
specified by the \code{File} on which it is called, returning
\code{true} if a new file was created and \code{false} if it already
existed.

The \code{delete()} method attempts to delete a file, returning
\code{true} if it's successful.  If applied to a directory, \code{delete()}
will only succeed if the directory is empty.  To get around this
limitation, LingPipe includes a static utility method \code{removeRecursive(File)} 
in the class \code{File} in package \code{com.aliasi.util}, which attempts
to remove a file and all of its descendants.

The properties of a file may be modified using, for example,
\code{setExecutable(boolean, boolean)} which attempts to make a file executable
for everyone or just the owner of the file.  Similar methods
are available for readability, writability and last modification date.

Files may be ranemd using \code{renameTo(File)}, which returns \code{true}
if it succeeds.  

The method \code{mkdir()} creates the directory corresponding to the file.
This method only creates the directory itself, so the parent must exist.
The method \code{mkdirs()} recursively creates the directory and all of its
parent directories.


\subsection{Temporary Files}

It is sometimes useful to create a temporary file.  One of the
properties used to create the Java virtual machine is a directory for
``temporary'' files.  

This is typically a platform default directory, like
\code{/tmp} in UNIX or \code{C:{\bk}WINNT{\bk}TEMP} on Windows, but it
may be configured when the JVM starts up.

The static \code{File} method \code{createTempFile(String,String)}
attempts to create a temporary file in the default temporary file with
the specified prefix and suffix, and it returns the file that's
created.  After the file is created, it will exist, but have length
zero.

The temporariness of the file doesn't mean it'll
be guaranteed to disappear.  It is a matter of whether you delete the
file yourself or whether the operating system occassionally cleans out
the temp directory.

Invoking the method \code{deleteOnExit()} on a file tells the
operating system that the file should be deleted when the JVM exits.
Unfortunately, this method is buggy on Windows, so should not be taken
as provided strong cross-platform guarantees.  It's always a good idea
to make sure to use a \code{finally} block to clear out temporary
files.  


\section{I/O Exceptions}\label{section:io-ioexception}

Almost all of the I/O operations are declared to throw
\code{IOException}, a checked exception in the \code{java.io} package.
Like all exceptions, I/O exceptions should not be ignored.  In most
cases, methods should simply pass on exceptions raised by methods they
call.  Thus most methods using I/O operations will themselves be
declared to throw \code{IOException}.  

At some point, a method will have to step up and do something with an
exception.  In a server, this may mean logging an error and continuing
on.  In a short-lived command-line program, it may mean terminating
the program and printing an informative error message.  

It is important to clean up system resources in a long-running
program.  Thus it is not uncommon to see code in a \code{try} with a
\code{finally} block to clean up even if an I/O exception is raised.

\subsection{Catching Subclass Exceptions} 

Some methods are declared to throw exceptions that are instances
of subclasses of \code{IOException}.  For instance, the constructor
\code{FileInputStream(File)} may throw a \code{FileNotFoundException}.

If you are passing on exceptions, don't fall into the trap of
passing just a general \code{IOException}.  Declare your method
to throw \code{FileNotFoundException} and to throw \code{IOException}.
This provides more information to clients of the method, who then have
the option to handle the exceptions generically at the \code{IOException}
level, or more specifically, such as for a \code{FileNotFoundException}.
It also helps readers of your Javadoc understand what specifically could
go wrong with their method calls.

In general, it's a good idea to catch subclasses of exceptions
separately so that error handling and error messages may be as
specific as possible.  If the methods called in the \code{try} block
are declared to throw the more general \code{IOException}, you'll

To do so, you need to declare the more specific catches first.  For
example, it's legal to write
%
\begin{verbatim}
try {
    in = new FileInputStream(file);
} catch (FileNotFoundException e) { 
    ...
} catch (IOException e) {
    ...
}
\end{verbatim}
%
but if you try to catch the I/O exception first, the compiler will gripe that the
\code{FileNotFoundException} has already been caught.



\section{Security and Security Exceptions}

Almost all of the I/O operations that attempt to read or modify a file
may also throw an unchecked \code{SecurityException} from the base
package \code{java.lang}. Typically, such exceptions are thrown when
a program attempts to overstep its permissions.

File security is managed through an instance of
\code{SecurityManager}, also in \code{java.lang}.  This is a very
flexible interface that is beyond the scope of this book.




\section{Input Streams}

The abstract class \code{InputStream} in \code{java.io} provides the
basic operations available to all byte input streams.  Concrete
input streams may be constructed in many ways, but they are all closed
through the \code{Closeable} interface (see \refsec{io-closeable}).

\subsection{Single Byte Reads}

A concrete extension of the \code{InputStream} class need only
implement the top-level \code{read()} method.  The \code{read()}
method uses the C programming language pattern of returning an integer
representing an unsigned byte value between 0 (inclusive) and 255
(inclusive) as the value read, or -1 if the end of stream has been
reached.

\subsection{Byte Array Reads}

It is usually too inefficient to access data one byte at a time.
Instead, it is usually accessed in blocks through an array.  The
\code{read(byte[])} method reads data into the specified byte array
and returns the number of bytes that have been read.  If the return
value is -1, the end of the input stream has been reached.  There is a
similar method that reads into a slice of an array given an offset
and length.

\subsection{Available Bytes}

The method \code{available()} returns an integer representing the
number of bytes available for reading without blocking.  This is not
the same as the number of bytes available.  For one thing, streams may
represent terabytes of data, and \code{available()} only returns an
integer.  More importantly, some streams may block waiting for more
input.  For instance, the standard input (see \refsec{io-stdin-stdout} may
block while waiting for user input and show no avaialable bytes, even
if bytes may later become available.  

Because no bytes may be available without blocking, it's possible for
the block read method to return after reading no bytes.  This does not
mean there won't be more bytes to read later.  The \code{read()}
methods will return -1 when there are truly no more bytes to be read.

\subsection{Mark and Reset}

The method \code{markSupported()} returns \code{true} for markable
input streams.  If a stream is markable, calling \code{mark()} sets
the mark at the current position in the stream.  A later call to
\code{reset()} resets the stream back to the marked position.

\subsection{Skipping}

There is also a method \code{skip(long)}, which attempts to skip past
the specified number of bytes, returning the number of bytes it
actually skipped.  The only reason to use this method is that it is
often faster than actually reading the bytes and then throwing them
away, because it skipping bypasses all the byte assignments that
would otherwise be required for a read.


\section{Output Streams}

The \code{OutputStream} abstract class in the package \code{java.io}
provides a general interface for writing bytes.  It is thus the
complement to \code{InputStream}.  Output streams implement the
\code{Closeable} interface, and should be closed in the same way
as other closeable objects (see \refsec{io-closeable}).

\code{OutputStream} itself implements the array writers in terms of
single byte writes, with the close and flush operations doing nothing.
Subclasses override some or all of these methods for additional
functionality or increased efficiency.


\subsection{Single Byte Writes}

A single abstract method needs to be implemented by concrete
subclasses, \code{write(int)}, which writes a byte in unsigned
notation to the output stream.  The low-order byte in the integer is
written and the three high-order bytes are simply ignored (see
\refappendix{java-bytes} for more on the byte organization of integers).
Thus the value should be an unsigned representation of a byte between
0 (inclusive) and 255 (inclusive).

\subsection{Byte Array Writes}

Arrays of bytes may be written using the method \code{write(byte[])},
and a slice variant taking a byte array with a start position and
length.

The behavior is slightly different than for reads.  When a write
method returns, all of the bytes in the array (or specified slice
thereof) will have been written.  Thus it is not uncommon for array
writes to block if they need to wait for a resource such as a network,
file system, or user console input.

\subsection{Flushing Writes}

The method \code{flush()} writes any bytes that may be buffered
to their final destination.  As noted in the documentation, the
operating system may provide further buffering, for instance to
the network or to disk operations.  

The \code{OutputStream} class is defined to implement
\code{Flushable}, the interface in \code{java.io} for flushable
objects.  Like the general \code{close} method from the
\code{Closeable} interface, it may raise an \code{IOException}.

Most streams call the \code{flush()} method from their \code{close()}
method so that no data is left in the buffer as a result of closing
an object.


\section{Closing Streams}\label{section:io-closeable}

Because most streams impose local or system overhead on open I/O
streams, it is good practice to close a stream as soon as you are done
with it.  

\subsection{The \code{Closeable} Interface}

Conveniently, all the streams implement the handy \code{Closeable}
interface in the package \code{java.io}.  The \code{Closeable}
interface specifies a single method, \code{close()}, which closes a
stream and releases any resources it may be maintaining.

Care must be taken in closing streams, as the \code{close()} method
itself may throw an \code{IOException}.  Furthermore, if the stream
wasn't successfully created, the variable to which it was being
assigned may be null.

The typical idiom for closing a \code{Closeable} may be illustrated
with an input stream
%
\begin{verbatim}
InputStream in = null;
try {
    in = new FileInputStream(file);
    ...
} finally {
    if (in != null) {
        in.close();
    }
}
\end{verbatim}
%
Sometimes, the close method itself is wrapped to suppress
warnings, as in
%
\begin{verbatim}
try {
    in.close();
} catch (IOException e) {
    /* ignore exception */
}
\end{verbatim}
%
Note that even if the close method is wrapped, the operations in the
try block may throw I/O exceptions.  To remove these, I/O exceptions
may be caught in a block parallel to the \code{try} and
\code{finally}.

\subsection{LingPipe Quiet Close Utility}

If a sequence of streams need to be closed, things get ugly quickly.
LingPipe provides a utility method
\code{Streams.closeQuietly(Closeable)} in \code{com.aliasi.util} that
tests for null and swallows I/O exceptions for close operations.
Basically, it's defined as follows.
%
\begin{verbatim}
static void close(Closeable c) {
    if (c == null) return;
    try {
        c.close();
    } catch (IOException e) {
        /* ignore exception */
    }
}
\end{verbatim}
%
If you need to log stream closing exceptions, a similar method may
be implemented with logging in the catch operation and a message to
pass as an argument in the case of errors.


\section{Readers}

The \code{Reader} abstract base class is to \code{char} data as
\code{InputStream} is to \code{byte} data.  For instance,
\code{read()} reads a single \code{char} coded as an \code{int}, with
-1 indicating the end of the streamstream.  There is a block reading
method \code{read(char[])} that returns the number of values read,
with -1 indicating end of stream, and a similar method taking a slice
of an array of \code{char} values.  There is also a \code{skip(int)}
method that skips up to the specified number of \code{char} values,
returning the number of values skipped.  The \code{Reader} class
implements the \code{Closeable} interface, and like streams, have a
single \code{close()} method.  All of these methods are declared to
throw \code{IOException}.

Unlike input streams, concrete subclasses must implement the abstract
methods \code{close()} and the slice-based bulk read method
\code{read(char[],int,int)}.

Some readers are markable, as indicated by the same
\code{markSupported()} method, with the same \code{mark()} method to
set the mark at the current position and \code{reset()} method to
return to the marked position.

\subsection{The \code{Readable} Interface}

The \code{Reader} class also implements the \code{Readable} interface
in \code{java.lang}.  This interface has a single method
\code{read(CharBuffer)} that reads \code{char} values into a specified
buffer, returning the number of values read or -1 for end of stream
(see \refsec{char-charbuffer} for more on \code{CharBuffer}).


\section{Writers}

Writers are to readers as output streams are to input streams.  The
method \code{write(int)} writes a single character using the two
low-order bytes of the specified integer as a \code{char}.

Arrays of characters may be written using \code{write(char[])} and
there is a method to write only a slice of a character array.  Strings
and slices of strings may also be written.  

Like other streams, \code{Writer} implements \code{Closeable} and is
hence closed in the usual way using \code{close()}.  Like other output
streams, it implements \code{Flushable}, so calling \code{flush()}
should try to write any buffered characters.

\subsection{The \code{Appendable} Interface}

The \code{Writer} class also implements the \code{Appendable}
interface in \code{java.lang}.  This is the same interface as is
implemented by the mutable character sequence implementations
\code{CharBuffer}, \code{StringBuilder}, and \code{StringBuffer}.

This interface specifies a method for appending a single character,
\code{append(char)}, and for sequences, \code{append(CharSequence)},
as well as for slices of character sequences.  The result specified in
the \code{Appendable} interface is \code{Appendable}, so calls may be
chained.  The result specified by \code{Writer} is \code{Writer};
subclasses may declare more specific return types than their
superclasses.  Other implementations also declare their own types
as their return types.


\section{Converting Byte Streams to Characters}

Resources are typically provided as byte streams, but programs
manipulating language data require character streams.  Given a
character encoding, a byte stream may be converted to a character
stream. 

\subsection{The \code{InputStreamReader} Class}\label{section:io-inputstreamreader}

Given an input stream and a characte encoding, an instance
of \code{InputStreamReader} may be constructed to read characters.
The usual idiom is
%
\begin{verbatim}
String encoding = ...;
InputStream in = ...;
Reader reader = new InputStreamReader(in,encoding);
...
reader.close();
\end{verbatim}
%
The operations ellided in the middle may then use the reader to
retrieve character-based data.  Instances may also be constructed from
an instance of \code{CharSet} or with a \code{CharSetDecoder}, both of
which are in \code{java.nio.charset}; the string-based method is just
a shortcut that creates a decoder for a character set behind the
scenes.  This decoder is used to convert the sequence of bytes from
the underlying input stream into the \code{char} values returned by
the reader.

The question remains as to whether to attempt to close the input
stream itself given that the reader was closed.  When an
\code{InputStreamReader} is closed, the input stream it wraps will be
closed.%
%
\footnote{This is not clear from the documentation, but is clear from
  the source code.  Perhaps we're meant to infer the behavior from the
  general contract for \code{close()} in \code{Closeable}, which
  specifies that it should release all of the resources it is holding.}
%
As long as the reader was constructed, there should be no problem.
For more robustness, the stream may be nested in a
\code{try}-\code{finally} block to ensure it's closed.  The reader
should be closed first, and if all goes well, the stream should
already be closed when the close in the \code{finally} block is
reached.  This second call should not cause problems, because the
\code{Closeable} interface specifies that redundant calls to
\code{close()} should have no effect on a closed object.

\subsection{The \code{OutputStreamWriter} Class}

In the other direction, the class \code{OutputStreamWriter} does the
conversion.  The idiom for construction, use, and closure is the same,
only based on a \code{CharSetEncoder} to convert sequences of
characters to sequences of bytes for writing.

\subsection{Illegal Sequences}

The documentation for both of these classes indicate that their
behavior in the face of illegal \code{byte} or \code{char} sequences.
For instance, an \code{InputStreamReader} may be faced with a sequence
of bytes that is not decodeable with the specified character encoding.
Going the other way, an \code{OutputStreamWriter} may receive a
sequence \code{char} values that is not a legal UTF-16 sequence, or
that contains code points that are not encodable in the specified
character encoding.  

In practice, a \code{InputStreamReader}'s behavior will be determined
by its \code{CharSetDecoder}, and a \code{OutputStreamWriter}'s by its
\code{CharSetEncoder}.  The encoders and decoders may be configured to
allow exceptions to be raised for illegal sequences or particular
substitutions to be carried out.

\section{File Input and Output Streams}

Streaming access to files is handled by the subclasses
\code{FileInputStream} and \code{FileOutputStream}, which
extned the obvious base classes.  

\subsection{Constructing File Streams}

A file input stream may be constructed with either a file using the
constructor \code{FileInputStream(File)} or the name of a file, using
\code{FileInputStream(String)}.  

Similarly, output streams may be constructed using
\code{FileOuptutStream(File)} and \code{FileOuptutStream(String)}.
If constructed this way, if the file exists, it will be overwritten
and resized to the output produced by the output stream.  To append
to a file, construct an output stream using
\code{FileOuptutStream(File,boolean)}, where the boolean flag
specifies whether or not to append.

The constructors are declared to throw the checked exception
\code{FileNotFoundException}, in package \code{java.io}, which is a
subcclass of \code{IOException}.  

\subsection{Finalizers}

Both the input and output file streams declare finalizer methods which
may release any system resources when the related stream is no longer
in scope.  The problem with finalization is that it's not guaranteed
to happen until the JVM on which the code was running is terminated.
In any case, whether it exits normally or not, the operating system
will recover any process-specific file handles.



\subsection{File Descriptors}\label{section:io-file-descriptors}

The \code{FileDescriptor} class in \code{java.io} provides an
encapsulation of a file input or output stream.  Every time a file
input or output stream is created, it has an associated file
descriptor.  The file descriptor may be retrieved from a file input
stream or file output stream using the method \code{getFD()}.  A new
input or output stream may be constructed based on a file descriptor.

\subsection{Examples of File Streams}


\subsubsection{Counting the Bytes in a File}\label{section:io-file-byte-count}

We wrote a demo program \code{FileByteCount} that opens a file input
stream and then reads all of its content, counting the number of
instances of each byte.  The work is done with
%
\codeblock{FileByteCount.1}
%
Note that the \code{main()} method is declared to throw both
a \code{FileNotFoundException} and its superclass
\code{IOException} (see \refsec{io-ioexception} for more information
on I/O exceptions and their handling).  

The body of the method creates an instance of \code{File} using the
command-line argument, then an input stream, based on the file.  It
then allocates an array of \code{long} values the size of the number
of bytes, which is used to store the counts (recall that primitive
numbers are always initialized to 0 in Java, including in arrays).
Then we use the C-style read method to read each bye into the integer
variable \code{b}.  If the value is -1, indicating the end of stream
(end of file here), the loop is exited.  In the body of the read loop,
the count for the byte just read is incremented.

We call the method using the Ant target \code{file-byte-count}, 
specifying the \code{file.in} property for the file to be counted. 
Here we call it on its own source code,
%
\commandlinefollow{ant -Dfile.in=src/com/lingpipe/book/io/FileByteCount.java file-byte-count}
\begin{verbatim}
Dec  Hex      Count
 10    a         33
 32   20        189
 33   21          1
...
123   7b          2
125   7d          2
\end{verbatim}
%
Because the file is encoded in ASCII, these bytes can be read as
characters.  For instance, character hexadecimal value 0A is the
linefeed, 20 is a newline, 32 is the digit 2, up through 7D, which is
the right curly bracket (\code{\}}).  We can infer that the file has
34 lines, because there are 33 line feeds.  

\subsubsection{Copying from One File to Another}\label{section:io-copy-file}

Our next sample program, \code{CopyFile}, copies the bytes in one file
into another file and illustrates the use of array-based reads and
writes.%
%
\footnote{The same functionality is available through the LingPipe
static utility method \code{copyFile(File,File)} from the \code{Files}
class in \code{com.aliasi.util}.}
%
After reading in the command-line arguments, the work is carried out by
%
\codeblock{CopyFile.1}
%
We first create the file input and output streams.  We've assigned
them to variables of type \code{InputStream} and \code{OutputStream}
rather than to their specific subclasses because we do not need any of
the functionality specific to file streams.  We then allocate an array
\code{buf} of bytes to act as a buffer and declare a variable \code{n} to hold
the count of the number of bytes read.  The loop continually reads
from the input stream into the buffer, assigning the number of bytes
read to \code{n}, and exiting the loop if the number of bytes read is
less than zero (signaling end of stream).  In the body of the loop, we
write the bytes in the buffer to the output stream, being careful to
specify that we only want to write \code{n} bytes.  Unlike reads,
writes either succeed in writing all their bytes (perhaps having to
block), or throw an exception.  When we're done, we close both streams.%
%
\footnote{We don't need elaborate try-finally logic to close
the file streams because they are closed automatically when the
command-line program exits.  We could get into trouble if another
program were to call this \code{main()} without exiting the JVM after
the call.  A more robust version of this program might catch I/O
exceptions thrown by the write method and delete the output stream
rather than leaving a partial copy.  We've shown what this would look
like in the source file for \code{CopyFile} in a parallel method
named \code{main2()}.}

\subsubsection{Character Encoding Conversion}

As a third example, we'll show how to wrap our file-based streams
in readers and writers in order to carry out character encoding
conversion.  Here we use a character buffer to do the transfer,
%
\codeblock{FileDecodeEncode.1}
%
The program may be called with the Ant target
\code{file-decode-encode} with arguments given by
properties \code{file.in}, \code{enc.in}, \code{file.out},
and \code{enc.out}.  



\section{Buffered Streams}

Some sources of input, such as an HTTP connection or a file, are most
efficiently dealt with in larger chunks than a single byte.  In most
cases, when using such streams, it is more efficient to buffer the
input or output.  Both byte and character streams may be buffered for
both input and output.  For byte streams, the classes are
\code{BufferedInputStream} and \code{BufferedOutputStream}, and for
character streams, \code{BufferedReader} and \code{BufferedWriter}

\subsection{Constructing Buffered Streams}

The buffered byte streams have constructors
\code{BufferedInputStream(InputStream,int)} and
\code{BufferedOutputStream(OutputStream,int)} that wrap a specified
stream and use a buffer of the specified size to hold bytes.  
The buffer sizes may be dropped, in which case a default size is used.

For example, we may created a buffered input stream from
a file input stream using
%
\begin{verbatim}
File file = ...;
InputStream in = new FileInputStream(file);
InputStream bufIn = new BufferedInputStream(in);
\end{verbatim}
%
The variable \code{bufIn} is then used where the unbuffered stream
\code{in} would've been used.  By assigning all these streams of
different types to a base \code{InputStream}, it makes it easier to
change the code later.

The constructors only save a pointer to the underlying stream and
create a buffer, so they don't throw I/O exceptions, because they're
not doing any I/O.

\subsection{Sizing the Buffer}

There is often a measurable performance improvement from getting the
buffer size right for the underlying platform and application, but
performance measurement is a tricky business (see
\refsec{reading-java} for recommended reading on performance tuning).

\subsection{Closing a Buffered Stream}

When a buffered stream is closed, it closes the contained stream.  See
the discussion in \refsec{io-inputstreamreader} concerning writing
robust stream closing idioms.  The close will also flush any bytes
or characters currently being buffered.

\subsection{Built-in Buffering}

Many of the streams (or readers and writers) have built-in buffering.
For instance, the GZIP input and output streams have built-in buffers.
In these cases, there's no need to buffer twice for efficiency's sake.

If you are eventually going to wrap a byte stream in a buffered
reader or writer, the byte stream doesn't itself need to be buffered.
The buffering, though use of block reads and writes, carries itself through.

Similarly, if your own code does buffering, as in our example in
\code{CopyFile} (see \refsec{io-copy-file}), there's no need to buffer
the file input or output streams.

By this same line of reasoning, if a byte stream is converted to a
character stream or vice versa, buffering is not required at both
places.  Usually, the buffer is placed later in the chain, around the
reader or writer, as in
%
\begin{verbatim}
InputStream in = new FileInputStream(file);
Reader reader = new InputStreamReader(in,"UTF-8");
BufferedReader bufReader = new BufferedReader(isReader);
\end{verbatim}
%
\begin{verbatim}
OutputStream out = new FileOutputStream(file);
Writer writer = new OutputStreamWriter(out,"UTF-8");
BufferedWriter bufWriter = new BufferedWriter(writer);
\end{verbatim}

\subsection{Line-Based Reads}

The \code{BufferedReader} class implements a method to read lines.
The method \code{readLine()} returns a \code{String} corresponding to
the next line of input read, not including the end-of-line markers.
If the end of stream has been reached, this method will return null.

This class recognizes three end-of-line markers,
a linefeed (\code{{\bk}n}), a carriage return (\code{{\bk}r}),
or a linefeed followed by a carriage return (\code{{\bk}n{\bk}r}).


\section{Array-Backed Input and Output Streams}

The array-backed input streams and readers read from arrays of data
held in memory.  The array-backed output streams and writers buffer
the bytes or characters written to them and provide access to them as
an array at any time.

\subsection{The \code{ByteArrayInputStream} Class}

The class \code{ByteArrayInputStream} wraps a byte array to produce an
in-memory input stream.  The constructor
\code{ByteArrayInputStream(byte[])} creates the input stream.  The
byte array is not copied, so changes to it will affect the input
stream.  

Byte array input streams support the \code{mark()} and \code{reset()}
methods.

Closing a byte array input stream has no effect whatsoever.

\subsection{The \code{CharArrayReader} Class}

The class \code{CharArrayReader} performs the same service, creating a
\code{Reader} from an array of characters.  They support the same
range of methods with almost all the same behaviors, only for
\code{char} data rather than \code{byte} data.  Inconsistently,
\code{close()} behaves differently, releasing the reference to the
underlying character array and causing all subsequent calls to read
methods to throw I/O exceptions.

There is also a class \code{StringReader} that does the same thing
as a character array reader for string input.


\subsection{The \code{ByteArrayOutputStream} Class}

A \code{ByteArrayOutputStream} provides an in-memory output stream
that buffers any bytes written to it.  Because it uses arrays, the
maximum amount of data that can be written to an output stream is
\code{Integer.MAX\_VALUE} bytes.

There is a no-argument constructor and one that specifies the initial
capacity of the buffer.  

The method \code{size()} returns the number of bytes that are buffered.

All of the bytes written to a byte array output stream are available
as a byte array using the method \code{toByteArray()}.  The returned
array is a copy of the bytes buffered in an underlying array, so
changes to it do not affect the output stream.  Calling this method
does not remove the returned bytes from the buffer.

Calling \code{reset()} removes all of the currently buffered bytes,
allowing a byte array output stream to be reused.  

Closing a byte-array output stream has no effect.  In particular, the
bytes that have been buffered will still be available.

\subsection{The \code{CharArrayWriter} Class}

A \code{CharArrayWriter} does the same thing for characters,
implementing methods of the same name as byte-array output streams.


\section{Compressed Streams}

In many cases, resources are compressed to save storage space or
transfer bandwidth.  The standard Java package \code{java.util.zip}
supports a general pair of streams, \code{DeflaterInputStream} and
\code{InflaterInputStream}, for compressing and decompressing
sequences of bytes.  Although new implementations may be written, Java
builds in support for Gnu Zip (GZIP) compression and for the ZIP
format for compressing archives consisting of multiple hierarchically
named streams as an archive.  Java's own Java archive (JAR) files are
essentially zipped archives, and are also implemented.   

\subsection{GZIP Input and Output Streams}

The GZIP input and output streams are constructed by wrapping anothr
stream and optionally specifying a buffer size.  After construction,
they behave just like any other stream. 

The sample program \code{FileGZIP} wraps a file output
stream in a GZIP output stream in order to implement
a simple compression command-line program.  The work
in the \code{main()} method is done by
%
\codeblock{FileGZIP.1}
%
Aside from the creation of the compressed stream, the
rest is just a buffered stream copy.  

The sample program \code{FileUnGZIP} uncompresses one
file into the other, with all the work being done in
the creation of the streams,
%
\codeblock{FileUnGZIP.1}
%
After the streams are created, the input is copied to the output as
before.  Both programs print the input and output file lengths
for convenience.

The Ant target \code{file-gzip} calls the program with arguments
the value of properties \code{file.uncompressed} and \code{file.gzipped}.
It's conventional to name a compressed file the same thing as the
original file with a suffix denoting the type of compression,
which for GZIP is \code{gz}. Here we compress the build file
\code{build.xml}, which being XML, is highly redundant, and hence
highly compressible.
%
\commandlinefollow{ant -Dfile.uncompressed=build.xml -Dfile.gzipped=build.xml.gz file-gzip}
\begin{verbatim}
Original Size=7645          Compressed Size=1333 
\end{verbatim}
%
We can uncompress in the same way, calling the \code{file-ungzip}
target, which takes as command-line arguments the values of properties
\code{file.gzipped} and \code{file.ungzipped}.
%
\commandlinefollow{ant -Dfile.ungzipped=build.xml.copy -Dfile.gzipped=build.xml.gz file-ungzip}
\begin{verbatim}
Original Size=1333          Expanded Size=7645
\end{verbatim}
%
The round trip results in \code{build.xml.copy} containing exactly the
same bytes as \code{build.xml}.  You may verify the files contain the
same content using the \code{diff} program from the command line,
%
\commandline{diff~build.xml~build.xml.copy}
%
which prints no output when the files being compared are the same.
Listing the directory contents shows the sizes,
%
\commandlinefollow{ls -l}
\begin{verbatim}
7645 Aug  5 16:54 build.xml        
7645 Aug  5 16:58 build.xml.copy
1333 Aug  5 16:58 build.xml.gz
\end{verbatim}

Along the same lines, you may verify that command-line versions of
GZIP, such as \code{gunzip}, can handle the compressed file.%
%
\footnote{We recommend working in a temporary directory so as not to
  destroy the original \code{build.xml} file.  The command-line
  compressors and uncompressors typically work by creating an output
  file which adds or removes the compression format's standard
  suffix.}%
\footnote{We've had trouble getting the compression programs to work from the
  DOS command line.}
%

If you try to compress a stream that isn't in GZIP format, the input
stream will throw an I/O exception with an explanatory message.


\subsection{ZIP Input and Output Streams}

ZIP streams enable the representation of compressed archives.  A ZIP
archive consists of a sequence of entries.  Each entry contains meta
information and data.  The data is accessed through an input stream
for reading and output stream for writing.  The pattern for using
the ZIP streams is somewhat unusual, so we will provide an example.

\subsubsection{The \code{ZIPEntry} Class}

The meta-information for an entry is encapsulated in an instance of
\code{ZIPEntry} in the \code{java.util.zip} package.  Information
about the entry including compressed size, CRC-32 checksum, time last
modified, comments, and the entry's name are available through
methods.

ZIP archives may be arranged hierarchically.  Directory structure is
described through entry names, with the forward slash (\code{/})
acting as the separator.  The method \code{isDirectory()} is available
to determine if an entry is a directory, which is signaled by its
ending in a forward slash.

For the purpose of creating archives, the zip entry values may
be set with setter methods corresponding to the get methods.  This
entails that the \code{ZIPEntry} class is mutable.

\subsubsection{Creating a Zip Archive with Ant}

To provide a zip file for experimental purposes, we've written
an Ant target \code{example-zip} that builds a zipped archive
using Ant's built-in \code{mkdir}, \code{echo}, and \code{zip}
tasks.  The Ant code is straightforward,
%
\begin{verbatim}
<property name="file.in.zip" 
          value="build/demo-archive.zip"/>

<target name="example-zip">
  <mkdir dir="build/archive/dir"/>    
  <echo message="Hello."  
        encoding="UTF-8" 
        file="build/archive/hello.txt"/>
...
  <zip destfile="${file.in.zip}"
       basedir="build/archive" 
       encoding="UTF-8"/>
</target>
\end{verbatim}
%
It uses the property \code{file.in.zip} to define the zipped archive's
location.  The \code{mkdir} task makes a working directory in our
build directory, which will be cleaned the next time the \code{clean}
target is invoked.  The \code{echo} task writes text to a file with a
specified encoding.  The ellided tasks write two more files.  We then
call the \code{zip} target, specifying the target file, the directory
which is being zipped up, and the encoding to use for file names.

The demo file creation target needs to be run before the demo so
there's something to unzip.
%
\commandlinefollow{ant example-zip}
\begin{verbatim}
Building zip: c:\lpb\src\io\build\demo-archive.zip
\end{verbatim}
%

\subsubsection{Reading a ZIP Archive}

A \code{ZIPInputStream} is created, and then the archive is read entry
by entry.  The method \code{getNextEntry()} returns the
\code{ZIPEntry} object for the next entry to be read, or \code{null}
if there ae no more entries.  For each entry, we read its
meta-information from the entry object and its data from the
input stream.

We provide a sample program \code{FileZipView} that reads a ZIP
archive from a file and displays its properties and contents.  The
work in the \code{main()} method is done by
%
\codeblock{FileZipView.1}
%
To get going, the file input stream is wrapped in a
\code{ZipInputStream}.  The buffer \code{bs} is used for
writing.  This loop uses the while-true-break idiom to
run until a condition discovered in the middle of the body
is discovered.  Here, we assign the entry variable to
the next entry.  If it's \code{null}, we break out of the
loop.  Otherwise, we print the properties of the entry
using a subroutine with the obvious implementation, then
read the bytes from the zip input stream and write
them to standard output.
  
We have an Ant target \code{file-zip-view} that dumps out
the contents of a Zip archive specified through the
\code{file.in.zip} property.
%
\commandlinefollow{ant -Dfile.in.zip=build/demo-archive.zip
  file-zip-view}
\begin{verbatim}
getName()=abc/     isDirectory()=true
getSize()=0     getCompressedSize()=0
new Date(getTime())=Tue Jul 20 18:21:36 EDT 2010
getCrc()=0     getComment()=null
---------------------------
getName()=abc/bye.txt     isDirectory()=false
getSize()=7     getCompressedSize()=9
new Date(getTime())=Tue Jul 20 18:21:36 EDT 2010
getCrc()=3258114536     getComment()=null
Goodbye
---------------------------
...
---------------------------
getName()=hello.txt     isDirectory()=false     
...
Hello
\end{verbatim}
%
We've moved lines together to save space and ellided the third entry
and part of the fourth.  Each division is for an entry, and the
commands used to access the properties are printed.  For instance, the
first entry is a directory named \code{abc/}, the second entry is an
ordinary entry named \code{abc/bye.txt}, implying containment in the
first directory by naming.  The final entry is another ordinary entry
named \code{hello.txt}, which isn't in any directory.  Note that the
compressed size is larget than the uncompressed size, which is not
unusual for a short (or random, or already compressed) sequence of
bytes.

After printing out all the properties for each entry, the program
prints the contents by simply writing the bytes read directly to the
standard output.  For example, the entry named \code{abc/bye.txt}
contains the UTF-8 bytes for \code{Goodbye}.


\subsubsection{Creating a Zip Archive}

Zip archives may be created programmatically using
\code{ZipOutputStream} by reversing the process by which they are
read.  That requires creating \code{ZipEntry} objects for each entry
in the archive and setting their properties.  The entry
meta-information is then written to the archive using the
\code{putNextEntry()} method on the Zip output stream, then writing
the bytes to the stream.  The method \code{setMethod(int)} may be used
with argument constants \code{STORED} for uncompressed entries
and \code{DEFLATED} for compressed entries.


\section{Accessing Resources from the Classpath}

When distributing an application, it is convenient to package all the
necessary files along with the compiled classes in a single Java
archive (jar).  This is particularly useful in the context of
servlets, which are themselves packaged in web archives (war), a kind
of jar with extra meta-information.

\subsection{Adding Resources to a Jar}

Resources that will be accessed programatically are added to an
archive file just like any other file.  We provide an Ant target
\code{example-resource-jar} which may be used to create a jar
at the path picked out by the property \code{resource.jar}.  
%
\begin{verbatim}
  <property name="resource.jar"
            value="build/demo-text.jar"/>

  <target name="example-resource-jar">
    <mkdir dir="build/resources/com/lingpipe/book/io"/>
    <echo message="Hello from the jar."
          encoding="UTF-8"
          file="build/resources/com/lingpipe/book/io/hello.txt"/>
    ...
    <jar destfile="${resource.jar}">
      <fileset dir="build/resources" 
               includes="**/*.txt"/>
    </jar>
  </target>
\end{verbatim}
%
We define the default for the property \code{resource.jar} to be a
file of the same name in the \code{build} directory (which is subject
to cleaning by the \code{clean} target).  The target that builds the
jar first makes a directory under \code{build/resources} into which
files will be placed.  These are created by \code{echo} tasks, for
instance creating a file \code{/com/lingpipe/book/io/hello.txt} under
\code{build/resources}.  After the directory structure to be archived
is created in \code{build/resources}, a \code{jar} task creates it,
specifying that the archive should include all the files in
\code{build/resources} that match the pattern \code{**/*.txt}, which
is all files ending in \code{.txt}.

This command should be run before the demo in the next section.
%
\commandlinefollow{ant -Dresource.jar=build/demo-text.jar example-resource-jar}
\begin{verbatim}
Building jar: c:\lpb\src\io\build\demo-text.jar
\end{verbatim}


\subsection{Resources as Input Streams}\label{section:io-resource-input}

One of the ways in which an input stream may be accessed is by
specifying a resource.  The system will then look for the resource on
the classpath in a number of prespecified locations based on its name.

The sample program \code{ResourceInput} reads the content of a
resource from the classpath and writes it to the standard output.
The part of the \code{main()} method that gets the resource as
an input streami is
%
\codeblock{ResourceInput.1}
%
The name of the resource is read in as the first command-line
argument.  Then the method \code{getResourceAsStream(String)} is
called with the name of the resource.  It is called on the
\code{Class} instance for the \code{ResourceInput} class, specified by
the static constant \code{ResourceInput.class}.  The calling class is
also important because the rules for locating the resource depend on
the particular class loader used to load the class.

If the name begins with a forward slash (\code{/}), it is taken to be
an absolute path name.  Otherwise, it is a relative path.  Relative
paths are interpreted relative to the package name of the class from
which the get method was called.  Specifically, the package name of
the class using forward slashes as separators is used a prefix for the
name.  

The Ant target \code{resource-input} look for a resource with the name
given by property \code{resource.name}, adding the archive named by
property \code{resource.jar} to the classpath.  The jar from which we
are reading needs to be on the classpath.  How it gets there doesn't
matter: you could put it on the command line, set an environment
variable read by the JVM, use a servlet container's classpath, etc.
Here, we just add the jar named by property \code{resource.jar} to the
classpath in the Ant target.  Very often, we just bundle resources
we want to read from the class path along with the compiled classes
for an application.  This is convenient for everything from document
type definitions (DTDs) to compiled statistical models.

We run the program using the resource named \code{hello.txt}
and the jar we created in the last section.
%
\commandlinefollow{ant -Dresource.jar=build/demo-text.jar
  -Dresource.name=hello.txt resource-input}
\begin{verbatim}
Hello from the jar.
\end{verbatim}
%
Note that we would get the same result if we specified the
\code{resource.name} property to be the absolute path
\code{/com/lingpipe/book/io/hello.txt} (note the initial forward
slash).

Once the stream is retrieved from the resource, it may be
manipulated like any other stream.  It may be buffered,
converted to a reader or object input stream, interpreted as
an image, etc.



\section{Print Streams and Formatted Output}\label{section:io-printstream-format}

A print stream is a very flexible output stream that supports standard
stream output, conversion of characters to bytes for output, and
structured C-style formatting.  This provides most of the
functionality of a \code{Writer}'s methods, while extending the base
class \code{InputStream}.%
%
\footnote{It's not possible in Java to be both a \code{Writer} and a
  \code{InputStream} because these are both abstract base classes, and
  a class may only extend one other class.  In retrospect, it'd be
  much more convenient if the streams were all defined as interfaces.}

\subsection{Constructing a Print Stream}

A print stream may be constructed by wrapping another input stream or
providing a file to which output should be written.  The character
encoding and whether auto-flushing should be carried out may also be
specified.  We recommend restricting your attention to the
constructors \code{PrintStream(File,String)} that writes to a file
given a specified encoding, and
\code{PrintStream(OutputStream,boolean,String)}, which prints to the
specified output stream, optionally using auto-flushing, using a
specified character encoding.  The othe methods are shorthands that
allow some parameters to be dropped.

\subsection{Exception Buffering}

The second unusual feature of print streams is that none of their
methods is declared to throw an I/O exception.  Instead, what it does
is implement an exception buffering pattern, only without an actual
buffer.%
%
\footnote{This pattern is sometimes implemented so
that the actual exceptions that were raised are accessible as a list.}
%
In cases where other streams would raise an I/O exception, the print
stream methods exit quietly, while at the same time setting an error
flag.  The status of this flag is available through the method
\code{checkError()}, which returns \code{true} if a method has caught
an I/O exception.

\subsection{Formatted Output}

One of the most convenient aspects of print streams is their
implementation of C-style \code{printf()} methods for formatted
printing.  These methods implicitly use an instance of
\code{Formatter} in \code{java.util} to convert a sequence of objects
into a string.  

Format syntax is very elaborate, and for the most part, we restrict
our attention to a few operations.  The method's signature is
\code{printf(Locale,String,Object...)}, where the string is the
formatting string and the variable-length argument \code{Object...}
is zero or more objects to format.  How the objects are formatted
depends on the format string and the \code{Locale} (from
\code{java.util}).  The locale is optional; if it is not supplied, the
default locale will be used.  The locale impacts the printing of
things like dates and decimal numbers, which are conventionally
printed differently in different places.  Although we are obsessive
about maintaining unadulterated character data and work in many
languages, a discussion of the intricacies f application
internationalization is beyond the scope of this book.

For example, the sample program \code{FileByteCount} (see
\refsec{io-file-byte-count}) uses string, decimal and hexadecimal
formatting for strings and numbers,
%
\codeblock{FileByteCount.2}
%
The first \code{printf()} has the format string
\code{"\%4s~\%4s~\%10s{\bk}n"}, which says to write the first string
using 4 characters, the second string using 4 characters, and the
third string using 10 characters; if they are too short, they align to
the right, and if they are too long, they run over their alloted
space.  The second \code{printf()} uses \code{\%4d} for a four place
integer (right aligned), and \code{\%4h} for a four-digit hexadecimal
representation.  Note that auto-boxing (see \refappendix{java-autoboxing})
converts the integers \code{i} and \code{counts[i]} to instances of
\code{Integer} to act as inputs to \code{printf()}.  Formatted prints
do not automatically occupy a line; we have manually added UNIX-style
line boundary with the line feed character escape \code{{\bk}n}.

Finally, note that the two \code{printf()} statements
intentionally use the same width so the output is formatted like a table
with headings aligned above the columns.  


\section{Standard Input, Output, and Error Streams}\label{section:io-stdin-stdout}

In many contexts, the environment in which a program is executed
provides streams for input, output, and error messages.  These streams
are known as standard input, standard output, and standard error.
Standard UNIX pipelines direct these streams in two ways.  They can
direct the standard input to be read from a file or the standard
output or error to be written to a file.  Second, they can pipe
processes together, so that the standard output from one process is
used for the standard input of the next process.
Shell scripts and scripting languages such as Python manage standard
input and output from processes in a similar way to shells.%
%
\footnote{Java provides an implementation of Unix-style pipes through
  piped streams and readers and writers.  These are based on the
  classes \code{PipedInputStream}, \code{PipedOutputStream},
  \code{PipedReader}, and \code{PipedWriter} in the standard
  \code{java.io} package.  These classes are multi-threaded so that
  they may asynchronously consume the output of one process to provide
  the input to the next, blocking if need be to wait for a read or write.}
%

\subsection{Accessing the Streams}

Java provides access to these streams through three static variables
in the class \code{System} in the package \code{java.lang}.  The
variable \code{System.in} is of type \code{InputStream}
and may be used to read bytes from the shell's standard input.  The
standard and error output streams, \code{System.out} and
\code{System.err}, are provided constants of type \code{PrintStream}
(see \refsec{io-printstream-format} for more information on print streams).
The standard output and error print streams use the platform's
default encoding (see below for how to reset this).

\subsection{Redirecting the Streams}\label{section:io-reset-system-out}

The standard input and output streams may be reset using the methods
\code{setIn(InputStream)}, \code{setOut(PrintStream)} and
\code{setErr(PrintStream)}.  This is convenient for writing Java
programs that act like Python or shell scripts.  

The mutability of the output and error streams enables a Java program
to reset their character encodings.  For example, to reset standard
output to use UTF-8, insert the following statement before any
output is produced,
%
\begin{verbatim}
System.setOut(new PrintStream(System.out,true,"UTF-8"));
\end{verbatim}
%
The value \code{true} enables auto-flushing.  The new standard
output wraps the old standard output in a new print stream
with the desired encoding. 

The output streams may be similarly redirected to files by using a
\code{PrintStream} constructed from a file in the same way.  For
example,
%
\begin{verbatim}
System.setErr(new PrintStream("stdout.utf8.txt","UTF-16BE"));
\end{verbatim}
%
sends anyting the program writes to the standard error stream to the
file \code{stdout.utf8.txt}, using the UTF-16BE character encoding
to convert characters to bytes.

The standard input stream may be wrapped in an
\code{InputStreamReader} or \code{BufferedReader} to interpret byte
inputs as characters.  Standard output and error may be wrapped in the
same way, which is an alternative to resetting the streams.

\subsection{UNIX-like Commands}

Commands in UNIX are often defined to default to writing to the
standard output if a file is not specified.  This idiom is easy to
reconstruct for Java commands.  Suppose we have a variable \code{file}
that is initialized to a file or \code{null} if the command is to
write an output
%
\begin{verbatim}
PrintStream out 
    = (file != null)
    ? new PrintStream(new FileOutputStream(file))
    : System.out;
\end{verbatim}
%
If the file is non-null, an output stream for it is wrapepd
in a print stream, otherwise the standard output is used.
The same can be done for input.

\section{URIs, URLs and URNs}\label{section:uri-url-urn}

A uniform resource identifier (URI) picks out something on the web by
name.  This is a very general notion, but we will only need a few
instances in this book.  The specifications for these standards are
quite complex, and beyond the scope of this book.  

\subsection{Uniform Resource Names}

There are two (overlapping) subtypes of URIs, based on function.  A
uniform resource name (URN) is a URI that provides a name for
something on the web, but may not say how or where to get it.  A
typical instance of a URN is the Digital Object Identifier (DOI)
system, which is becoming more and more widely used to identify text
resources such as journal articles.  For example, the DOI
\code{doi:10.1016/j.jbi.2003.10.001} picks out a paper on which my
wife was a co-author.  An alternative URN for the same paper is
\code{PMID:15016385}, which uses the PubMed identifier (PMID) for the
paper.

\subsection{Uniform Resource Locators}

A uniform resource locator (URL) provides a means of locating (a
concrete instance of) an item on the web.  A URL indicates how to get
something by providing a scheme name, such as \code{file://} for files
or \code{http://} for the hypertext transport protocol (HTTP).  For
example, the URL
\code{http://dx.doi.org/10.1016/j.jbi.2003.10.001} is for the same
paper as above, but specifies a web protocol, HTTP, and host,
\code{dx.doi.org} from which to fetch a specific embodiment of
the resource.  There may be many URLs that point to the same object.
For instance, \code{http://linkinghub.elsevier.com/retrieve/pii/S1532046403001126}
is a URL for the same paper, which links to the publisher's site.

\subsection{URIs and URLs in Java}

The standard \code{java.net} package has a class \code{URI} for URIs
and a class \code{URL} for URLs.  Both of them may be constructed
using a string representation of the resource.  Once constructed, the
classes provide a range of structured access to the fields making up
the resource.  For instance, both objects have methods such as
\code{getHost()} and \code{getPort()}, which may return proper values
or indicators like \code{null} or -1 that there is no host or port.

The demo program \code{UrlProperties} constructs a URL from a
command-line argument and prints out its available properties.  The
beginning of the \code{main()} method is
%
\codeblock{UrlProperties.1}
%
The rest of the program just prints out the rest of the properties.
The \code{main()} method throws a \code{MalformedURLException}, a
subclass of \code{IOException}, if the URL specified on the command
line is not well formed.  This ensures that once a URL is constructed,
it is well formed.  There are no exceptions to catch for the get
methods; they operate only on the string representations and are
guaranteed to succeed if the URL was constructed.

The Ant target \code{url-properties} calls the command supplying as
an argument the value of the property \code{url.in}.
%
\commandlinefollow{ant -Durl.in="http://google.com/webhp?q=dirichlet" url-properties}
\begin{verbatim}
getAuthority()=google.com
getDefaultPort()=80
getFile()=/webhp?q=dirichlet
getHost()=google.com
getPath()=/webhp
getPort()=-1
getProtocol()=http
getQuery()=q=dirichlet
getRef()=null
getUserInfo()=null
toExternalForm()=http://google.com/webhp?q=dirichlet
toString()=http://google.com/webhp?q=dirichlet
\end{verbatim}
%
Looking over the output shows how the URL is parsed into components
suc as host, path and query.

\subsection{Reading from URLs}

URLs know how to access resources.  These resources may reside locally
or remotely.  Wherever they arise, and whatever their content, 
resources are all coded as byte streams.  Java provides built-in support
for protocols \code{http}, \code{https}, \code{ftp}, \code{file}, and 
\code{jar}.  

Once a URL is created, the method \code{openStream()} returns an
\code{InputStream} that may be used to read the bytes from the URL.
Depending on the URL itself, these bytes may be from a local or
networked file, a local or remote web server, or elsewhere.  Opening
the stream may throw an I/O exception, as a connection is opened to
the URL.  Once the input stream is opened, it may be used like
any other stream.  

The sample program \code{ReadUrl} shows how to read the
bytes from an URL and relay them to standard output.
%
\codeblock{ReadUrl.1}
%
The code between the stream creation and its closing is just a generic
buffered stream copy.  

The Ant target \code{read-url} is configured to call the sample
program using as URL the value of the property \code{url.in}.
%
\commandlinefollow{ant -Durl.in=http://lingpipe.com url-read}
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html ...
<html ...
<head>
<title>LingPipe Home</title>
<meta http-equiv="Content-type"
      content="application/xhtml+xml; charset=utf-8"/>
...
pageTracker._trackPageview();
} catch(err) {}</script></body>
</html>
\end{verbatim}
%
As with most pages these days, LingPipe's home page starts with
a title, content type, and cascading stylesheet (CSS) declaration,
and ends with some Javascript.  
Whether you can see all of the output of a page depends on your
shell; you can save the output to a file and then view it in a
browser.  

A file URL may be used as well as an HTTP-based URL.  This allows an
abstraction over the location of the bytes being read.  


\subsection{URL Connections}

The output stream method we used above, \code{getOutputStream()}, is
just a convenience method for calling the \code{openConnection()}
method to get an instance of \code{URLConnection} and calling its
\code{getOutputStream()} method.  URL connections allow various
properties of the connection to be inspected and set.  

Although the \code{URL} method \code{openConnection()} is declared to
return a \code{URLConenction}, if the URL uses the HTTP protocol, the
documentation specifies that a \code{HttpURLConnection} will be
returned.  Thus the \code{URLConnection} may be cast to
\code{HttpURLConnection} at run time.  The HTTP-based connection
provides additional methods for manipulating HTTP headers and
responses, such as content types, last-modified dates, character
encodings, handling redirected web pages, fetching HTTP respose codes,
managing timeouts and keep-alive times for the connection, and other
intricacies of HTTP management.

A URL connection may also be used to write to a URL.  This makes it
possible to attach data for a POST-based request and thus implement
general web services.


\section{The Input Source Abstraction}

The class \code{InputSource}, in standard Java package
\code{org.xml.sax}, provides an input abstraction for XML documents
with a rather awkward mutable implementation.  An input source
specifies the source of its input as a URL, an input stream, or a
reader.

There is a constructor for each mode of input specification.
\code{InputSource(String)} may be used with a system identifier in the
form of a URL, and \code{InputSource(InputStream)} and
\code{InputSource(Reader)} for stream data.  We recommend using one
of these constructors and not the corresponding setters.
immutable. 

There is also a no-argument constructor \code{InputSource()} and
setters for each of the input types.  The setters
\code{setSystemId(String)}, \code{setByteStream(InputStream)} and
\code{setCharacterStream(Reader)} correspond to the three contentful
constructors.

The system ID may be used to resolve relative paths within an XML
document.  Thus setting a system ID may be useful even when a byte
stream or a character stream has been specified. 

Before using an input source, a character encoding may be specified
using the \code{setEncoding(String)} method.  A further awkwardness
arises because this method only makes sense in conjunction with an
input stream or URL; readers supply already converted \code{char}
values.

It is up to the consumer of the input source to gather data from
whatever source is specified.  Typically, consumers will try the
reader, then the input stream, then the URL.  Because of the
mutability of the class through the setters, an input source may have
an input stream and a reader and a URL specified.






\section{File Channels and Memory Mapped Files}

As an alternative to streaming I/O, memory mapping essentially
provides a random access interface for files.  The method is by
providing an array-like access abstraction on top of files.  It is
then up to the operating system's file manager to deal with actual
commits to and reads from disk.

Memory mapped files are great for random access to data on disk.  For
instance, databases and search engines make heavy use of memory
mapping.

Both the file input and file output stream classes implement a
\code{getChannel()} method which returns an instance of
\code{FileChannel}.  File channels are part of the ``new'' I/O,
rooted at package name \code{java.nio}, specifically in the
package \code{java.nio.channels}.  

File channels support reading and writing into \code{ByteBuffer}
instances.  Byte buffers and other buffers are in the \code{java.nio}
package.  Byte buffers may be wrapped to act as character buffers or
other primitive type buffers.  See \refsec{char-charbuffer} for a
basic overview of buffers focusing on character buffers.

File channels may also be used to produce a \code{MappedByteBuffer},
which creates a memory-mapped file accessible as a \code{ByteBuffer}.
The other way to create a file channel which may be used to produce a
memory mapped buffer is through the \code{RandomAccessFile} class in
\code{java.io}.  The random access file class implements the
\code{DataInput} and \code{DataOutput} interfaces, which provide utilities
to write arbitrary primitives and strings in addition to bytes.

\section{Object and Data I/O}

Java provides built-in support for writing objects to streams through
the classes \code{ObjectInputStream} and \code{ObjectOutputStream} in
the package \code{java.io}.  Object input and output streams implement
the \code{ObjectInput} and \code{ObjectOutput} interfaces, which
extend the \code{DataInput} and \code{DataOutput} interfaces.  The
object streams deal with writing objects and the data streams with
writing primitive types and strings.  Only objects with a runtime
class that implements the \code{Serializable} interface in package
\code{java.io} may be written or read.  We first provide an example
then discuss how to implement the \code{Serializable} interface.


\subsection{Example of Object and Data I/O}

The sample program \code{ObjectIo} provides an example of using object
input and output streams to write objects and primitive objects and
then reconstitute them.  The \code{main()} method begins by writing
the objects and primitive types,
%
\codeblock{ObjectIo.1}
%
Note that a byte array output stream is created and assigned to the
appropriate variable.  We use a byte array for convenience; it
could've been a file output stream, a compressed file output stream,
or an HTTP write in either direction.  The output stream is then
wrapped in an object output stream and assigned to a variable of the
interface type, \code{ObjectOutput}.  The object output is then used
to write a file object using the \code{writeObject()} method from the
\code{ObjectOutput} interface.  Next, a string is written using the
\code{writeUTF(String)} method from the \code{DataOutput} intrface.
This does not write the string as an object, but using an efficient
UTF-8-like encoding scheme.  Lastly, an integer is written; the
\code{DataOutput} interface provides write methods for all of the
primitive types.  Finally, the output stream is closed in the usual
way through the \code{Closeable} interface method \code{close()}.

We then reverse the process to read the object back in,
%
\codeblock{ObjectIo.2}
%
First, we get the bytes that were written frmo the byte array
output stream and use them to create a byte array input stream.%
%
\footnote{Note that we assign variables to the most general type possible;
the input stream had to be assigned to \code{ByteArrayInputStream}
because we needed to call the \code{toByteArray()} method on it.}
%
Then we wrap that in an object input stream, which we use to read the
object, string and primitive integer value.  Then we close the input
stream.  The result of the object read must be upcast to \code{File}
because the \code{readObject()} method is declared to return
\code{Object}.%
%
\footnote{The \code{\@SuppressWarnings} annotation is used 
to suppress the unchecked warning that would otherwise be generated
by the compiler for the runtime cast.  Although the cast can't
fail in this context, because we know what we wrote, it may fail
in a runtime context if the expected input format is not received.}
%
Because the class may not be found or the class loader may fail to
load the class for the object, the \code{readObject()} method is also
declared to throw a \code{ClassNotFoundException}, which we simply
declare on the \code{main()} method rather than handle.
%
The result of running the program is
%
\commandlinefollow{ant object-io}
\begin{verbatim}
file.getCanonicalPath()=C:\lpb\src\io\foo    s=bar    n=42
\end{verbatim}


\subsection{The \code{Serializable} Interface}

The \code{Serializable} interface in package \code{java.io} is 
what's known as a marker interface.  The marker pattern involves
an interface, such as \code{Serializable}, which declares no
methods.  The interface is used to treat classes that implement
it differently in some contexts.  The object input and output
classes use the \code{Serializable} marker interface to determine
if a class should be serialized or not.  

When a class is serialized, its fully qualified path name is written
out as if by the \code{writeUTF()} method.  A 64-bit serial version
identifier is also written.  Then data representing the state of
the class is written.

All that is strictly necessary to make a class serializable is to
declare it to implement the \code{Serializable} interface and meet a
few additional conditions described below.  If nothing else is
specified, the serial version identifier will be computed from the
class's signature, including the signature of its parents and
implemented interfaces.  If nothing else is done, the state of the
class is serialized by serializing each of its member objects and
writing each of its primitive member variables, including all those
inherited from parent classes.

The first condition for default serializability is that all of the
class's member variables (including those of its superclasses)
implement the \code{Serializable} interface or are declared to be
\code{transient}.  If that is the case, the object output method uses
reflection to write out each object and primitive member variable in
turn.  

The second requirement on a class for default serializabiilty is that
it must implement a public no-argument constructor.  If that is the
case, reconstituting an object will also happen by reflection, first
calling the no-argument constructor, then reading and setting all the
member variables.

The third requirement is that the same version of the class be used
for reading and writing.  There are two parts to this requirement.
The first version requirement is that the signature of the class used
to read in the serialized instance must be the same as that used to
write the objects.  If you change the member variables, method
declarations, subclasses, etc., it will interfere with
deserialization.  The second version requirement is that the major
version of Java being used to deserialize must be at least as great
as that used to deserialize.  Thus it is not possible to serialize in
Java version 6 and deserialize in version 5.


\subsection{The Serialization Proxy Pattern}\label{section:io-serialization-proxy}

Java allows classes to take full control over their serialization and
deserialization, which we take advantage of to overcome the
limitations of default serialization, such as the restrictions on
superclass behavior, backward compatibility with changing signatures,
and the ability to create immutable objects without no-arg constructors.

Our recommended approach to serialization is to use the serialization
proxy pattern, which we describe in this section by example, with an
implementation in \code{SerialProxied}.  The class begins by declaring
it implements \code{Serializable}, then definining two final member
variables in a single two-argument constructor.  
%
\codeblock{SerialProxied.1}
%
The finality of the variables mean that instances of the the class are
immutable in the sense that once they are constructed they will never
change.  We use immutable classes wherever possible in LingPipe,
checking during construction that they are well formed.  Immutable
classes are easy to reason about, especially in multi-threaded
environments, because they are well formed when constructed and never
change behavior.

\subsubsection{The \code{writeReplace()} Method}

Before applying default serialization, the object write methods first
check, using reflection, if a class implements the
\code{writeReplace()} method.  If it does, the return result of
calling it is serialized instead of the class itself.  

The \code{SerialProxied} class implements the \code{writeReplace()}
method by returning a new instance of the \code{Serializer} class,
which we show below
%
\codeblock{SerialProxied.2}
%
Note that the method is declared to be private, so it will not appear
in the documentation for the class and may not be called by clients.
Reflection is still able to access the method even though it's
private. 

\subsubsection{Serialization Proxy Implementation}

The rest of the work's done in the class \code{Serializer}.  We
declare the class within the \code{SerialProxied} class as a static
nested class, \code{Serializer}.  
%
\codeblock{SerialProxied.3}
%
The class itself is declared to be private and static.  The full name
of which would be
\code{com.lingpipe.book.io.SerialProxied.Serializer}, but given its
privacy, we only access it from within \code{SerialProxied} anyway.

As we will shortly see, the \code{Externalizable} interface it
implements extends \code{Serializable} with the ability to take full
control over what is written and read.  The variables and methods
within it are package protected, though they could also all be
private.  There are two constructors, a no-arg constructor which is
required to be public for deserialization, and a one-argument
constructor used by the \code{writeReplace()} method shown above for
serialization.

The rest of the methods in the \code{Serializer} class are
%
\codeblock{SerialProxied.4}
%
We describe them in turn below.

\subsubsection{The \code{writeExternal()} Method}

The first method is the \code{writeExternal()} method, which writes to
the specified object output.  In this case, it uses its within-class
private access to retrieve and write the member variables of the
\code{SerialProxied} object \code{mObj}.  

\subsubsection{The \code{readExternal()} Method}

The next method is the \code{readExternal()} method.  This method
and its sister method, \code{writeExternal()} are specified in
the \code{Externalizable} interface as public, so must be public here.%
%
\footnote{The \code{readExternal()} method is also declared to throw a
  \code{ClassNotFoundException} to deal with cases when it fails to
  deserialize an object using the object input's \code{readObject()}
  method.  We don't need it here because we are only using the data
  input methods \code{readUTF()} and \code{readInt()}.}

The read method first reads the serialized string and integer from the
specified object input.  Then it uses these to construct a new
\code{SerialProxied} instance based on the strnig and count and
assigns it to the object variable \code{mObj}.

\subsubsection{The \code{readResolve()} Method}

Finally, the \code{readResolve()} method is used to return the object
that was read in.  This method is the deserialization counterpart to
\code{writeReplace()}.  After the \code{readExternal()} method is
called, if \code{readResolve()} is defined, its return value is
returned as the result of deserialization.  Thus even though
the \code{Serializer} is the one being serialized and deserialized,
it is not visible at all to external clients.

\subsubsection{Serial Version Variable}

The final piece of the puzzle to take control over is the computation
of the serial version identifier.  This allows serialization to
bypass the computation of this identifier by inspecting the serialized
object's signature by reflection.  This is not only more efficient,
it also allows the signatures to be changed without affecting
the ability to deserialize already serialized instances.

If a class has already been fielded without declaring a serial version
ID, the command-line program \code{serialver}, which is shipped with
the Sun/Oracle JDK, may be used to compute the value that would be
computed by reflection during serialization.  It only needs the
classpath and full name of the class.
%
\commandlinefollow{serialver -classpath build/lp-book-io-4.0.jar com.lingpipe.book.io.SerialProxied}
\begin{verbatim}
static final long serialVersionUID = -688378786294424932L;
\end{verbatim}
%
The output is a piece of Java code declaring a constant
\code{serialVersionUID} with the current value of the identifier as
computed by serialization.  We just insert that into the class
\code{SerialProxied} class.  Technically, we may use whatever number
we like here; it's only checked for consistency during serialization.

We also need to insert the version ID constant into the nested static
class \code{SerialProxied.Serializer}.


\section{Lingpipe I/O Utilities}

LingPipe provides a number of utilities for input and output,
and we discuss the general-purpose ones in this section.  

\subsection{The \code{FileLineReader} Class}\label{section:io-file-line-reader}

To deal with line-based file formats, LingPipe provides the class
\code{FileLineReader}, in the \code{com.aliasi.io} package.  This
class extends \code{LineNumberReader} in \code{java.io}, which itself
extends \code{BufferedReader}, so all the inherited methods are
avaiable.  

For convenience, the \code{FileLineReader} class implements the
\code{Iterable<String>} interface, with \code{iterator()} returning an
\code{Iterator<String>} that iterates over the lines produced by the
\code{readLine()} method inherited from \code{BufferedReader}.  Being
iterable enables for-loop syntax, as in
%
\begin{verbatim}
File file = ...;
FileLineReader lines = new FileLineReader(file,"UTF-8");
for (String line : lines) {
    ...
}
lines.close();
\end{verbatim}
%
The ellided code block will then perform some operation on each line.

There are also static utility methods, \code{readLines()} and
\code{readLinesArray()}, both taking a file and character encoding
name like the constructor, to read all of the lines of a file into
either an array of type \code{String[]} or a list of type
\code{List<String>}.

\subsection{The \code{Files} Utility Class}

Some standard file operations are implemented as static methods
in the \code{Files} class from the package \code{com.aliasi.util}.

\subsubsection{File Name Parsing}

The \code{baseName(File)} and \code{extension(File)} methods split a
file's name into the part before the last period (\code{.}) and the
part after the alst period.  If there is no last period, the base name
is the entire file name.

\subsubsection{File Manipulation}

The method \code{removeDescendants(File)} removes all the files
contained in the specified directory recursively.  The
\code{removeRecursive(File)} method removes the descendants of a file
and the file itself.  The \code{copy(File,File)} method
copies the content of one file into another.

\subsubsection{Bulk Reads and Writes}

There are methods to read bytes, characters, or a string from a file,
and corresponding methods to write.  The methods all pass on any I/O
exceptions they encounter.

The method \code{readBytesFromFile(File)} returns the array of bytes
corresponding to the file's contents, whereas
\code{writeBytesToFile(byte[],File)} writes the specified bytes to the
specified file.

The methods \code{readCharsFromFile(File,String)} and
\code{writeCharsToFile(char[],File,String)} do the same thing for
\code{char} values.  These methods both require the character encoding
to be specified as the final argument.  There are corresponding
methods for strings, \code{readFromFile(File,String)} and
\code{writeStringToFile(String,File,String)}.  Together, we can
use these methods to transcode from one encoding to another,
%
\begin{verbatim}
char[] cs = Files.readCharsFromFile(fileIn,enc1);
Files.writeCharsToFile(cs,fileOut,enc2);
\end{verbatim}


\subsection{The \code{Streams} Utility Class}

The class \code{Streams} in the package \code{com.aliasi.io} provides
static utility methods for dealing with byte and character streams.  

\subsubsection{Quiet Close Methods}

The method \code{closeQuietly(Closeable)} closes the specified
closeable object, catching and ignoring any I/O exceptions raised
by the close operation.  If the specified object is null, the
quiet close method returns.

The method \code{closeInputSource(InputSource)} closes the byte
and character streams of the specified input source quietly, as
if by the \code{closeQuietly()} method.

\subsubsection{Bulk Reads}

There are utility bulk read methods that buffer inputs and return them
as an array.  Special utility methods are needed because the amount of
data available or read from a stream is unpredictable.  Bulk writing,
on teh other hand, is built into output streams and writers
themselves.

The bulk read method \code{toByteArray(InputStream)} reads all of the
bytes from the input stream returning them as an array.  The method
\code{toCharArray(Reader)} does the same for \code{char} values.

The method \code{toCharArray(InputSource)} reads from an input source,
using the reader if available, and if not, the input stream using
either the specified character encoding or the platfrom default, and
barring that, reads from the input source's system identifier (URL).

The method \code{toCharArray(InputStream,String)} reads an array of
\code{char} values by reading bytes from the specified input stream
and converts them to \code{char} values using the specified character
encoding. 

\subsubsection{Copying Streams}

The method \code{copy(InputStream,OutputStream)} reads bytes from the
specified input stream until the end of stream, writing what it finds
to the output stream.  The \code{copy(Reader,Writer)} does the same
thing for \code{char} value streams.

\subsection{The \code{Compilable} Interface}\label{section:io-compilable}

LingPipe defines the interface \code{Compilable} in the package
\code{com.aliasi.util} for classes that define a compiled
representation. 

The interface has a single method, \code{compileTo(ObjectOutput)},
used for compiling an object to an object output stream.  Like all I/O
interface methods, it's defined to throw an \code{IOException}.  The
method is used just like the \code{writeExternal(ObjectOutput)} method
from Java's \code{Externalizable} interface.  It is assumed that only
whatever is written, deserialization will produce a single object that
is the compiled form of the object that was compiled.  

Many of LingPipe's statistical models, such as language models,
classifiers and HMMs have implementations that allow training data to
be added incrementally.  The classes implementing these models are
often declared to be both \code{Serializable} and \code{Compilable}.
If they are serializable, the standard serialization followed by
deserialization typically produces an object in the same state and
of the same class as the one serialized.  If a model's compilable,
a compilation followed by deserialization typically produces an
object implementing the same model more efficiently, but without the
ability to be updated with new training data. 

\subsection{The \code{AbstractExternalizable} Class}\label{section:io-abstract-externalizable}

LingPipe provides a dual-purpose class \code{AbstractExternalizable}
in the package \code{com.aliasi.util}.  This class provides static
utility methods for dealing with serializable and compilable objects,
as well as supporting the serialization proxy pattern.

\subsubsection{Base Class for Serialization Proxies}

The abstract class \code{AbstractExternalizable} in package
\code{com.aliasi.util} provides a base class for implementing the
serializaion proxy pattern, as described in
\refsec{io-serialization-proxy}.  It is declared to implement
\code{Externalizable}, and the \code{writeExternal(ObjectOutput)}
method from that interface is declared to be abstract and thus must be
implemented by a concrete subclass.  The method
\code{readExternal(ObjectInput)} is implemented by
\code{AbstractExternalizable}, as is the serialization method
\code{readResolve()}.  The other abstract method that must be
implemented is \code{read(ObjectInput)}, which returns an object.
This method is called by \code{readExternal()} and the object it
returns stored to be used as the return value for
\code{readResolve()}.

We provide an example class \code{AbstractExternalized} that parallels
our earlier example \code{SerialProxied} (see
\refsec{io-serialization-proxy}, with the
\code{AbstractExternalizable} interface doing some of the work.  The
only thing that changes is the declaration of the externalizer,
%
\codeblock{AbstractExternalized.1}
%
and the read method, which now returns an object rather than
assigning it,
%
\codeblock{AbstractExternalized.2}

This class makes it particularly easy to implement serialization for a
singleton.  We provide an example in \code{SerializedSingleton}.  Following
the usual singleton pattern, we have a private constructor and a public
static constant,
%
\codeblock{SerializedSingleton.1}
%
We then have the usual definition of \code{writeReplace()}, and a
particularly simple implementation of the serialization proxy itself,
%
\codeblock{SerializedSingleton.2}
%
If the nested static class had been declared public, we wouldn't have
needed to define the public no-argument constructor.  The version ID
is optional, but highly recommended for backward compatibility.

To test that it works, we have a simple \code{main()} method,
%
\codeblock{SerializedSingleton.3}
%
which serializes and deserializes the instance using the 
LingPipe utility in \code{AbstractExternalizable}, then tests
for reference equality.

We can run this code using the Ant target \code{serialized-singleton},
which takes no arguments,
%
\commandlinefollow{ant serialized-singleton}
\begin{verbatim}
same=true
\end{verbatim}

\subsubsection{Serialization Proxy Utilities}

The \code{AbstractExternalizable} class defines a number of static
utility methods supporting serialization of arrays.  These methods
write the number of members then each member of the array in turn.
For instance, \code{writeInts(int[],ObjectOutput)} writes an array of
integers to an object output and \code{readInts(ObjectInput)} reads
and returns an integer array that was serialized using the
\code{writeInts()} method.  There are similar methods for \code{double},
\code{float}, and \code{String}.

The method \code{compileOrSerialize(Object,ObjectOutput)} will attempt
to compile the specified object if it is compilable, otherwise it
will try to serialize it to the specified object output.  It will throw
a \code{NotSerializableException} if the object is neither serializable
nor compilable.  The method \code{serializeOrCompile(Object,ObjectOutput)}
tries the operations in the opposite order, compiling only if the
object is nor serializable.

\subsubsection{General Serialization Utilities}

The \code{AbstractExternalizable} class defines a number of
general-purpose methods for supporting Java's serialization and 
LingPipe's compilation.

There are in-memory versions of compilation and serialization.  The
method \code{compile(Compilable)} returns the result of compiling then
deserializing an object. The method
\code{serializeDeserialize(Serializable)} serializes and deserializes
an object in memory.  These methods are useful for testing
serialization and compilation.  These operations are carried out in
memory, which requires enough capacity to store the original object, a
byte array holding the serialized or compiled bytes, and the
deserialized or compiled object itself.  The same operation may be
performed with a temporary file in much less space because the
original object may be garbage collected before deserialization and
the bytes reside out of main memory.

There are also utility methods for serializing or compiling to a file.
The method \code{serializeTo(Serializable,File)} writes
a serialized form of the object to the specified file.  The 
\code{compileTo(Compilable,File)} does the same thing for compilable
objects.

To read serialized or compiled objects back in, the method
\code{readObject(File)} reads a serialized object from a file and
returns it.

The method \code{readResourceObject(String)} reads an object from a
resource with the specified absolute path name (see
\refsec{io-resource-input} for information on resources including
how to create them and put them on the classpath).  This method simply
creates an input stream from the resource then wraps it in an object
input stream for reading.  The
\code{readResourceObject(Class<?>,String)} method reads a (possibly
relative) resource relative to the specified class.  

