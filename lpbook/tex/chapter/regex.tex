\chapter{Regular Expressions}\label{chapter:regex}

Generalized regular expressions, as implemented in Java and all the
scripting languages like Perl and Python, provide a general means for
describing spans of Unicode text.  Given a regular expression (regex)
and some text, basic regex functionality allows us to test whether a
string matches the regex or find non-overlapping substrings of a
string matching the regex.

\section{Matching and Finding}

Despite the rich functionality of regexes, Java's
\code{java.util.regex} package contains only two classes,
\code{Pattern} and \code{Matcher}.  An instance of \code{Pattern}
provides an immutable representation of a regular expression.  An
instance of \code{Matcher} represents the state of the matching of a
regular expression against a string.

\subsection{Matching Entire Strings}

It's easiest to start with an example of using a regular expression
for matching, which we wrote as a
\code{main()} method in the class \code{RegexMatch}, the work of
which is done by
%
\codeblock{RegexMatch.1}
%
First, we read the regex from the first command-line argument, then
the text from the second argument.  We then use the regular expression
to compile a pattern, using the static factory method
\code{pattern.compile()}.  This pattern is reusable.  We next
create a matcher instance, using the method \code{matcher()} on the
pattern we just created.  Finally, we assign a boolean variable
\code{matches} the value of calling the method \code{matches()} 
on the matcher.  And then we print out the result.

Regular expressions may consist of strings, in which case they
simply carry out exact string matching.  For example, the regex
\code{aab} does not match the string \stringmention{aabb}.  
There is an Ant target \code{regex-match} which feeds the command-line
arguments to our program.  For the example at hand, we have
%
\commandlinefollow{ant -Dregex="aab" -Dtext="aabb" regex-match}
\begin{verbatim}
Regex=|aab|    Text=|aabb|    Matches=false
\end{verbatim}
%
On the other hand, the regex \code{abc} does match
the string \stringmention{abc}.
%
\commandlinefollow{ant -Dregex="abc" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|abc|    Text=|abc|    Matches=true
\end{verbatim}
%
Note that we have used the vertical bar to mark the boundaries of the
regular expression and text in our output.  These vertical bars are
not part of the regular expression or the text.  This is a useful
trick in situations where space may appear as the prefix or suffix of
a string.  It may get confusing if there is a vertical bar within the
string, but the outer vertical bars are always the ones dropped.

\subsection{Finding Matching Substrings}

The second main application of regular expressions is to find
substrings of a string that match the regular expression.  The main
method in our class \code{RegexFind} illustrates this.  We read in two
command-line aguments into string variables \code{regex} and \code{text}
as we did for \code{RegexMatch} in the previous section.  We begin
by compling the pattern and creating a matcher for the text just
as in \code{RegexFind}.
%
\codeblock{RegexFind.1}
%
The first call of the \code{find()} method on a matcher returns
\code{true} if there is a substring of the text that matches the
pattern.  If \code{find()} returned \code{true}, then the are method
\code{group()} returns the substring that matched, and the methods
\code{start()} and \code{end()} return the span of the match, which is
from the start (inclusive) to the end (exclusive).

Subsequent calls to \code{find()} return \code{true} if there is a
match starting on or after the end position of the previous calls.
Thus the loop structure in the program above is the standard idiom
for enumerating all the matches.  

As an example, we use the Ant target \code{regex-find}, which takes
the same arguments as \code{regex-match}.
%
\commandlinefollow{ant -Dregex=aa -Dtext=aaaaab regex-find}
%
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%
As before, the vertical bars are delimeters, not part of the matching
substring.  The string \stringmention{aa} actually shows up in four
distinct locations in \stringmention{aaaaab}, at spans (0,2), (1,3),
(2,4), and (3,5).  Running find only returns two of them.  The matcher
works from the start to the end of the string, returning the first
match it finds after the first call to \code{find()}.  In this case,
that's the substring of \stringmention{aaaaab} spanning (0,2).  The
second call to \code{find()} starts looking for a match at position 2,
succeeding with the span (2,4).  Next, it starts looking at position
4, but there is no substring starting on or after position 4 that
matches \stringmention{aa}.


\section{Character Regexes}

The most basic regular expressions describe single characters.  Some
characters have special meanings in regexes and thus need to be
escaped for use in regular expresions.

\subsection{Characters as Regexes}

A single character may be used a regular expression.  A regular
expression consisting of a single character only matches that single
character.  For instance,
\code{Pattern.compile("a").matcher("a").matches()} would evaluate to
\code{true}.  Using our Ant match target, 
%
\commandlinefollow{ant -Dregex=b -Dtext=b regex-match}
\begin{verbatim}
Regex=|b|    Text=|b|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=b -Dtext=c regex-match}
\begin{verbatim}
Regex=|b|    Text=|c|    Matches=false
\end{verbatim}
%
Within a Java program, Java character literals may be used within the
string denoting the regex.  For instance, we may write
\code{Pattern.compile("{\bk}u00E9")} to compile the regular expression
that matches the character \unicode{00E9}, \unicodedesc{latin small e
  with acute}, which would be written as \charmention{\'e}.

\subsection{Unicode Escapes}

Arbitrary unicode characters may be escaped in the same way as in
Java.  That is, \code{{\bk}u}\codeVar{hhhh} is a regular expression
matching the character with Unicode code point
\unicode{\codeVar{hhhh}}.  For example,
%
\commandlinefollow{ant -Dregex={\bk}u0041 -Dtext=A regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%
Note that we did not have to escape the backslash for the shell
because the following character, \code{u}, is not an escape.  Unicode
escapes are useful for for matching the period character,
\unicode{002E}, \unicodedesc{full stop}, which is a reserved character
in regexes representing wildcards (see \refsec{regex-wildcard}).
%
\commandlinefollow{ant -Dregex="{\bk}u002E" -Dtext="." regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%

In a Java program, we'd still have to write
\code{Pattern.compile("{\bk}{\bk}u002E")}.  

Unicode escapes in regexes are confusing, because they use the same
syntax as Java unicode literals.  Further complicating matters, the
literal for backslashes in Java programs is itself an escape sequence,
\code{{\bk}{\bk}}.  There is a world of difference between the
patterns produced by \code{Pattern.compile("{\bk}u002E")} and
\code{Pattern.compile("{\bk}{\bk}u002E")}.  The former is the same
as \code{Patten.compile(".")}, and matches any character, whereas
the latter uses a regex escape, and only matches the period
character.

\subsection{Other Escapes}

There are also other built-in escapes, such as \code{{\bk}n} for
newline and \code{\bk\bk} for a backslash character.  Again, we have
to be careful about distinguishing Java string escapes, which are used
to create a regex, which itself may contain regex escapes.  For
instance, to create the regex \code{\bk\bk}, we need to use
\code{Pattern.compile("\bk\bk\bk\bk")}.  Each pair of backslashes
is a Java escape for the backslash; thus a string of two backslashes
is compiled, resulting in the regex \code{\bk\bk}.

This is all further confused by the command-line shell, which has its
own escape sequence.  Our sample program reads a command from the
command line, which is being supplied by Ant and set as a property on
the command-line call to Ant.  For instance, consider this puzzler,
%
\commandlinefollow{ant -Dregex="\bk\bk\bk\bk" -Dtext="\bk\bk" regex-match}
%
\begin{verbatim}
Regex=|\\|    Text=|\|    Matches=true
\end{verbatim}
%
On the command line, backslash is escaped as \code{\bk\bk}.%
%
\footnote{Usually backslash doesn't need to be escaped because the
following character isn't a valid escape; here, the following
character is a quote (\code{"}), and \code{\bk"} is a valid escape
sequence for the shell.}
%
Our Java program gets two backslashes for a first argument and one for
the second, as shown in the output.  The match succeeds because the
regex \code{\bk\bk} is the escaped backslash character, which
matches a single backslash.


\section{Character Classes}

Regular expressions provide a range of built-in character classes
based on ASCII or Unicode, as well as the ability to define new
classes.  Each character class matches a set of characters.  The
reason to use classes rather than disjunctions is that they have


\subsection{WildCards}\label{section:regex-wildcard}

A singe period (\code{.}) is a regular expression that matches any
single characer.  We may think of it as the universal character class.
For instance, the regex \code{.} matches the string \stringmention{a},
and \code{a.c} matches \stringmention{abc}.%
%
\commandlinefollow{ant -Dregex=a.c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|a.c|    Text=|abc|    Matches=true
\end{verbatim}
%

Whether or not a wildcard matches an end-of-line sequence depends on
whether or not the \code{DOTALL} flag is set (see
\refsec{pattern-modes}); if it is set, the wildcard matches
end-of-line sequences.  The following two expressions evaluate to
\code{true},
%
\begin{verbatim}
Pattern.compile(".").matcher("A").matches()
Pattern.compile(".",DOTALL).matcher("\n").matches()
\end{verbatim}
%
whereas the following expression evaluates to \code{false},
%
\begin{verbatim}
Pattern.compile(".").matcher("\n").matches()
\end{verbatim}

\subsection{Unicode Classes}

Unicode defines a range of categories for characters, such as the
category \code{Lu} of uppercase letters (see
\refsec{unicode-categories} for more information).  The regular
expression \code{p\{\codeVar{X}\}} matches any unicode character
belonging to the Unicode category \codeVar{X}.  For example,
%
\commandlinefollow{ant -Dregex={\bk}p{Lu} -Dtext=A regex-match}
\begin{verbatim}
Regex=|\p{Lu}|    Text=|A|    Matches=true
\end{verbatim}
%

\subsection{ASCII Classes}

There are character classes built in for ASCII characters.  For
instance, \code{{\bk}d} is for digits, \code{{\bk}s} for whitespace,
and \code{{\bk}w} for alphanumeric characters.  For example,
%
\commandlinefollow{ant -Dregex={\bk}d -Dtext=7 regex-match}
\begin{verbatim}
Regex=|\d|    Text=|7|    Matches=true
\end{verbatim}
%
Their capital forms match ASCII characters that don't match the
lowercase form, with \code{{\bk}D} for ASCII non-digits, and so on.
Like the Unicode classes described in the previous section, there are
a range of built-in ASCII classes from th POSIX standard built in,
such as \code{{\bk}p\{ASCII\}} for any ASCII character and
\code{{\bk}p\{Punct\}} for ASCII punctuation characters.

The ASCII characters must be used with care, because they will not
have their described behavior when interpreted over all of Unicode.
For example, there are whitespaces in Unicode that don't match
\code{{\bk}s} and digits that don't match \code{{\bk}d}.

\subsection{Compound Character Classes}




As described in the Javadoc for \code{Pattern},%
%
\footnote{We've added the negation operator at the end, which
is not in the Javadoc's lineup.}
%
the order of
attachment for character class operations is
%
\begin{center}
\begin{tabular}{rll}
\tblhead{Order} & \tblhead{Expression} & \tblhead{Example} 
\\ \hline
1 & Literal Escape & \code{{\bk}x}
\\
2 & Grouping & \code{[...]} 
\\
3 & Range & \code{0-9}
\\
4 & Concatenation & \code{ab}, \code{[0-9][ab]}, 
\\
5 & Intersection & \code{[a-z\&\&[aeiou]]}
\\
6 & Negation & \code{[\^{}aeiou]}
\end{tabular}
\end{center}
%





\section{Concatenation}

As we saw in our early examples, characters may be concatenated
together to form a regular expression that matches the string.

\subsection{Empty Regex}

The simplest regular expression is the empty regular expression.  It
only matches the empty string.  For example, the expression
\code{Pattern.compile("").matcher("").matches()} would evaluate to
\code{true}.  Using our test code from the command-line proves tricky,
because we have to escape the quotes if we want to assign environment
variables, as in 
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext={\bk}"{\bk}"  regex-match}
\begin{verbatim}
Regex=||    Text=||    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext=a regex-match}
\begin{verbatim}
Regex=||    Text=|a|    Matches=false
\end{verbatim}


\subsection{Concatenation}

Two regular expressions \codeVar{x} and \codeVar{y} may be
concatenated to produce a compound regular expression \codeVar{xy}.
The regex \codeVar{xy} matches any string that can be decomposed into
a string that matches \codeVar{x} followed by a string that matches
\codeVar{y}.

Concatenation is associative, meaning that if we have three regexes
\codeVar{x}, \codeVar{y}, and \codeVar{z}, the regexes
\code{(\codeVar{x}\codeVar{y})\codeVar{z}} and
\code{\codeVar{x}(\codeVar{y}\codeVar{z})} match exactly the same set
of strings.  Because parentheses may be used for groups (\see
\refsec{regex-groups}), the two regexes do not always behave exactly
the same way.



\section{Non-Capturing Regexes}

\subsection{Begin and End of Line}


The caret (\code{\^{}}) is a regular expression that matches the end
of a line and the dollar sign (\code{\$}) a regular expression
matching the beginning of a line.  For example, 
%
\commandlinefollow{ant -Dregex="\^{}abc\$" -Dtext=abc regex-match}
\begin{verbatim}
Regex=|^abc$|    Text=|abc|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=ab\$c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|ab$c|    Text=|abc|    Matches=false
\end{verbatim}
%
The begin- and end-of-line regexes do not themselves consume any
characters.

These begin-of-line and end-of-line regexes do not match new lines
inside of strings unless the \code{MULTILINE} flag is set (see
\refsec{pattern-modes}).  By default, these regexes match new-line
sequences for any platform (Unix, Macintosh, or Windows).  If the
\code{UNIX\_LINES} flag is set, they only match Unix newlines (see
\refsec{pattern-modes}).





\subsection{Disjunction}

Two regular expressions \codeVar{x} and \codeVar{y} may be disjoined
to produce a compound regular expression
\codeVar{x}\code{|}\codeVar{y}.  The regex
\codeVar{x}\code{|}\codeVar{y} matches any string that matches either
\codeVar{x} or \codeVar{y} (or both).  For example,
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=ab regex-match}
\begin{verbatim}
Regex=|ab|cd|
Text=|ab|
Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=cd regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|cd|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=bc regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|bc|    Matches=false
\end{verbatim}
%
The vertical bars used to display the regex are not part of it; thus
the regular expression is \code{ab|cd}, not \code{|ab|cd|}.  The regex
itself needs to be quoted on the command line so the vertical bar is
not interpreted as a Unix pipe.

Even though the order of disjunctions doesn't matter in a logical
expression.  And as far as matching whole strings, the order of
disjunctions doesn't matter.  But for finds, disjunctions are
evaluated left-to-right and the first match returned.
%
\commandlinefollow{ant -Dregex="ab|abc" -Dtext=abc regex-find}
\begin{verbatim}
Found |ab| at (0,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="abc|ab" -Dtext=abc regex-find}
\begin{verbatim}
Found |abc| at (0,3)
\end{verbatim}
%

Because complex disjunctions are executed through backtracking,
disjunctions that have to explore many branches can quickly lead to
inefficient regular expressions.

Combinatorics can quickly spiral out of control with disjunctions.
Even a regex as short as \code{(a|b)(c|d)(e|f)} has $2^3 = 8$ possible
search paths to explore.  Although each disjunction tacked on doubles
the size of the search space in theory, in practice disjunctions often
fail earlier.  If there is no match for \code{a|b}, the further
disjunctions are not explored.

\subsection{Kleene Star and Other Quantifiers}

A regular expression \codeVar{x} may have the Kleene-star operator%
%
\footnote{Named after Stephen Kleene, who invented regular expressionsn
as a notation for his characterization of regular languages.}
%
applied to it to produce the regular expression \codeVar{x}\code{*}.
The regex \codeVar{x}\code{*} matches a string if the string is
composed of a sequence of zero or more matches of \codeVar{x}.  In
terms of execution, \codeVar{x}\code{*} behaves like a disjunction
with a recursive definition,
%
\displ{\code{\codeVar{x}*} {::=} \code{(\codeVar{x}(\codeVar{x}*))|}}
%
A matcher for \code{\codeVar{x}*} first tries to find a
match for \codeVar{x} followed by a match of \code{\codeVar{x}*}, and
failing that, matches the empty string.
The second disjunct is the empty string, a regex that matches the
empty string.  



\subsection{Line Terminators and Unix Lines}

\begin{center}
\begin{tabular}{lll}
\tblhead{Code Point(s)} & \tblhead{Description} & \tblhead{Java} 
\\ \hline
\unicode{000A} & \unicodedesc{line feed} & \code{{\bk}n}
\\
\unicode{000D} & \unicodedesc{carriage return} & \code{{\bk}r}
\\
\unicode{000D}, \unicode{000A} & \unicodedesc{carriage return},
\unicodedesc{line feed} & \code{{\bk}r{\bk}n}
\\
\unicode{0085} & \unicodedesc{next line} & \code{{\bk}u0085} 
\\
\unicode{2028} & \unicodedesc{line separator} & \code{{\bk}u2028}
\\
\unicode{2029} & \unicodedesc{paragraph separator} & \code{{\bk}u2029}
\end{tabular}
\end{center}


\subsection{Parentheses for Grouping}\label{section:regex-groups}

In all cases, parentheses may be used around a regular expression to
clarify how the operations attach.  


\subsection{Pattern Match Flags}\label{section:pattern-modes}

There are a set of flags, all represented as static integer constants
in \code{Pattern}, which may be supplied to the pattern compiler
factory method \code{Pattern.compile(String,int)} to control the
matching behavior of the compiled pattern.  The most important of
these for our purposes are the following.
%
\begin{center}
\begin{tabular}{lp{0.65\textwidth}}
\tblhead{Constant Flag} & \tblhead{Description} 
\\ \hline { } \\[-6pt]
\code{DOTALL}
& Allows the wild card (\code{.}) expression to match any
character, including line terminators.  If this mode is not
set, the wild card does not match line terminators.
\\[4pt]
\code{MULTLINE}
& Allows the begin-of-line (\code{\^{}}) and end-of-line (\code{\$}) to
match internal line terminators.  If this is not set, they only
match before the first and after the last character.  The full Java
notion of newline is used unless the flag \code{UNIX\_LINES} is also set.
\\[4pt]
\code{UNIX\_LINES}
& Treat newlines as in Unix, with a single \unicode{000A},
\unicodedesc{line feed}, Java string escape \code{{\bk}n},
representing a new line.  This affects the behavior of wildcard
(\code{.}) and begin-of-line (\code{\^{}}) and end-of-line 
(\code{\$}) expressions. 
\\[4pt] 
\code{CASE\_INSENSITIVE} 
& Matching is insensitive to case.  Case folding is only for
the ASCII charset (\unicode{0000} to \unicode{007F}) unless
the flag \code{UNICODE\_CASE} is also set, which uses the Unicode
definitions of case folding.
\\[4pt]
\code{UNICODE\_CASE}
& If this flag and the \code{CASE\_INSENSITIVE} flag is set,
matching ignores case distinctions as defined by Unicode
case folding rules.
\\[4pt]
\code{CANON\_EQ} 
& Matches are based on canonical equivalence in Unicode 
(see \refsec{unicode-normalization-forms}).
\end{tabular}
\end{center}

The flags are defined using a bit-mask pattern whereby multiple
flags are set by taking their bitwise or value.  For instance,
the expression \code{DOTALL~|~MULTILINE} allows the wildcard
to match anything and the line-terminator expressions to match
internal newlines.  More than two flags may be set this way,
so we could further restrict to Unix newlines with
\code{DOTALL~|~MULTILINE~|~UNIX\_LINES}.

Even stronger matching than canonical equivalence with unicode case
folding can be achieved by writinger the regular expression using
compatibility normal forms and using the ICU package to perform a
compatibility decomposition on the input (see
\refsec{unicode-normalization-forms}).


\subsection{Pattern Construction Exceptions}

Attempting to compile a regular expression with a syntax error raises
a runtime exception, \code{PatternSyntaxException} from the
\code{java.util.regex} package.  The parser tries to provide a helpful
warning message.  For instance, here's what we see if we inadvertently
add a right parenthesis to our regex.
%
\commandlinefollow{ant -Dregex=aa) -Dtext=aaab regex-find}
\begin{verbatim}
Exception in thread "main" 
    java.util.regex.PatternSyntaxException:  
    Unmatched closing ')' near index 1
\end{verbatim}




\section{Thread Safety, Serialization, and Reuse}

\subsection{Thread Safety}

Because instances of \code{Pattern} are immutable, it is safe to use
them concurrently in multiple threads.  Because instances of
\code{Matcher} contain the state of the current match, it is not
thread safe to use matchers concurrently without synchronization.

\subsection{Reusing Matchers}

Matchers may be reused.  The method \code{reset()} may be called on a
matcher to reset it to behave as if it had just been constructed with
its given pattern and character sequence.  The character sequence may
be changed.  The pattern may also be changed on the fly, without
changing the current position.  This may be useful if you alternately
match first one pattern then another.  Although matchers may be
reused, the typical usage pattern is to construct them for a text, use
them once, then discard them.


\subsection{Serialization}

Patterns are serializable.  The string representing the pattern and
the compilation flags are stored and the version read back in is an
instance of \code{Pattern} behaving just like the original.  Often
patterns do not need to be serialized because they're effectively
singletons \ie{constants}.






