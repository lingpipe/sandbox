\chapter{Regular Expressions}\label{chapter:regex}

Generalized regular expressions, as implemented in Java and all the
scripting languages like Perl and Python, provide a general means for
describing spans of Unicode text.  Given a regular expression (regex)
and some text, basic regex functionality allows us to test whether a
string matches the regex or find non-overlapping substrings of a
string matching the regex.
The example programs for this chapter are in the code directory:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex}}


\section{Matching and Finding}

Despite the rich functionality of regexes, Java's
\code{java.util.regex} package contains only two classes,
\code{Pattern} and \code{Matcher}.  An instance of \code{Pattern}
provides an immutable representation of a regular expression.  An
instance of \code{Matcher} represents the state of the matching of a
regular expression against a string.

\subsection{Matching Entire Strings}

It's easiest to start with an example of using a regular expression
for matching, which we wrote as a
\code{main()} method in the class \code{RegexMatch}, the work of
which is done by
%
\codeblock{RegexMatch.1}
%
First, we read the regex from the first command-line argument, then
the text from the second argument.  We then use the regular expression
to compile a pattern, using the static factory method
\code{pattern.compile()}.  This pattern is reusable.  We next
create a matcher instance, using the method \code{matcher()} on the
pattern we just created.  Finally, we assign a boolean variable
\code{matches} the value of calling the method \code{matches()} 
on the matcher.  And then we print out the result.

Regular expressions may consist of strings, in which case they
simply carry out exact string matching.  For example, the regex
\code{aab} does not match the string \stringmention{aabb}.  
There is an Ant target \code{regex-match} which feeds the command-line
arguments to our program.  For the example at hand, we have
%
\commandlinefollow{ant -Dregex="aab" -Dtext="aabb" regex-match}
\begin{verbatim}
Regex=|aab|    Text=|aabb|    Matches=false
\end{verbatim}
%
On the other hand, the regex \code{abc} does match
the string \stringmention{abc}.
%
\commandlinefollow{ant -Dregex="abc" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|abc|    Text=|abc|    Matches=true
\end{verbatim}
%
Note that we have used the vertical bar to mark the boundaries of the
regular expression and text in our output.  These vertical bars are
not part of the regular expression or the text.  This is a useful
trick in situations where space may appear as the prefix or suffix of
a string.  It may get confusing if there is a vertical bar within the
string, but the outer vertical bars are always the ones dropped.

\subsection{Finding Matching Substrings}\label{section:regex-find}

The second main application of regular expressions is to find
substrings of a string that match the regular expression.  The main
method in our class \code{RegexFind} illustrates this.  We read in two
command-line arguments into string variables \code{regex} and \code{text}
as we did for \code{RegexMatch} in the previous section.  We begin
by compiling the pattern and creating a matcher for the text just
as in \code{RegexFind}.
%
\codeblock{RegexFind.1}
%
The first call of the \code{find()} method on a matcher returns
\code{true} if there is a substring of the text that matches the
pattern.  If \code{find()} returned \code{true}, then the are method
\code{group()} returns the substring that matched, and the methods
\code{start()} and \code{end()} return the span of the match, which is
from the start (inclusive) to the end (exclusive).

Subsequent calls to \code{find()} return \code{true} if there is a
match starting on or after the end position of the previous calls.
Thus the loop structure in the program above is the standard idiom
for enumerating all the matches.  

As an example, we use the Ant target \code{regex-find}, which takes
the same arguments as \code{regex-match}.
%
\commandlinefollow{ant -Dregex=aa -Dtext=aaaaab regex-find}
%
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%
As before, the vertical bars are delimiters, not part of the matching
substring.  The string \stringmention{aa} actually shows up in four
distinct locations in \stringmention{aaaaab}, at spans (0,2), (1,3),
(2,4), and (3,5).  Running find only returns two of them.  The matcher
works from the start to the end of the string, returning the first
match it finds after the first call to \code{find()}.  In this case,
that's the substring of \stringmention{aaaaab} spanning (0,2).  The
second call to \code{find()} starts looking for a match at position 2,
succeeding with the span (2,4).  Next, it starts looking at position
4, but there is no substring starting on or after position 4 that
matches \stringmention{aa}.


\section{Character Regexes}

The most basic regular expressions describe single characters.  Some
characters have special meanings in regexes and thus need to be
escaped for use in regular expressions.

\subsection{Characters as Regexes}

A single character may be used a regular expression.  A regular
expression consisting of a single character only matches that single
character.  For instance,
\code{Pattern.compile("a").matcher("a").matches()} would evaluate to
\code{true}.  Using our Ant match target, 
%
\commandlinefollow{ant -Dregex=b -Dtext=b regex-match}
\begin{verbatim}
Regex=|b|    Text=|b|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=b -Dtext=c regex-match}
\begin{verbatim}
Regex=|b|    Text=|c|    Matches=false
\end{verbatim}
%
Within a Java program, Java character literals may be used within the
string denoting the regex.  For instance, we may write
\code{Pattern.compile("{\bk}u00E9")} to compile the regular expression
that matches the character \unicode{00E9}, \unicodedesc{latin small e
  with acute}, which would be written as \charmention{\'e}.

\subsection{Unicode Escapes}

Arbitrary unicode characters may be escaped in the same way as in
Java.  That is, \code{{\bk}u}\codeVar{hhhh} is a regular expression
matching the character with Unicode code point
\unicode{\codeVar{hhhh}}.  For example,
%
\commandlinefollow{ant -Dregex={\bk}u0041 -Dtext=A regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%
Note that we did not have to escape the backslash for the shell
because the following character, \code{u}, is not an escape.  Unicode
escapes are useful for for matching the period character,
\unicode{002E}, \unicodedesc{full stop}, which is a reserved character
in regexes representing wildcards (see \refsec{regex-wildcard}).
%
\commandlinefollow{ant -Dregex="{\bk}u002E" -Dtext="." regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%

In a Java program, we'd still have to write
\code{Pattern.compile("{\bk}{\bk}u002E")}.  

Unicode escapes in regexes are confusing, because they use the same
syntax as Java unicode literals.  Further complicating matters, the
literal for backslashes in Java programs is itself an escape sequence,
\code{{\bk}{\bk}}.  There is a world of difference between the
patterns produced by \code{Pattern.compile("{\bk}u002E")} and
\code{Pattern.compile("{\bk}{\bk}u002E")}.  The former is the same
as \code{Patten.compile(".")}, and matches any character, whereas
the latter uses a regex escape, and only matches the period
character.

\subsection{Other Escapes}

There are also other built-in escapes, such as \code{{\bk}n} for
newline and \code{\bk\bk} for a backslash character.  Again, we have
to be careful about distinguishing Java string escapes, which are used
to create a regex, which itself may contain regex escapes.  

To confuse matters, Java itself also uses a backslash for escapes, so
that the character for backslash is written \code{'\bk\bk'} and so the
regex \code{{\bk}n} must be written as the string literal
\code{"\bk{\bk}n"}.  To create the regex \code{\bk\bk}, we need to use
two backslash escapes in our string literal, writing
\code{Pattern.compile("\bk\bk\bk\bk")}.  

This is all further confused by the command-line shell, which has its
own escape sequences.  Our sample program reads a command from the
command line, which is being supplied by Ant and set as a property on
the command-line call to Ant.  For instance, consider this puzzler,
%
\commandlinefollow{ant -Dregex="\bk\bk\bk\bk" -Dtext="\bk\bk" regex-match}
%
\begin{verbatim}
Regex=|\\|    Text=|\|    Matches=true
\end{verbatim}
%
On the command line, backslash is escaped as \code{\bk\bk}.%
%
\footnote{Usually backslash doesn't need to be escaped because the
following character isn't a valid escape; here, the following
character is a quote (\code{"}), and \code{\bk"} is a valid escape
sequence for the shell.}
%
Our Java program gets a value for \code{regex} consisting of a
length-two string made up of two backslashes, and value for text
consisting of a single backslash.  The match succeeds because the
regex \code{\bk\bk} is the escaped backslash character, which matches
a single backslash.


\section{Character Classes}

Regular expressions provide a range of built-in character classes
based on ASCII or Unicode, as well as the ability to define new
classes.  Each character class matches a set of characters.  The
reason to use classes rather than disjunctions is that they have


\subsection{WildCards}\label{section:regex-wildcard}

A singe period (\code{.}) is a regular expression that matches any
single character.  We may think of it as the universal character class.
For instance, the regex \code{.} matches the string \stringmention{a},
and \code{a.c} matches \stringmention{abc}.%
%
\commandlinefollow{ant -Dregex=a.c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|a.c|    Text=|abc|    Matches=true
\end{verbatim}
%

Whether or not a wildcard matches an end-of-line sequence depends on
whether or not the \code{DOTALL} flag is set (see
\refsec{pattern-modes}); if it is set, the wildcard matches
end-of-line sequences.  The following two expressions evaluate to
\code{true},
%
\codeblock{FragmentsRegex.1}
%
whereas the following expression evaluates to \code{false},
%
\codeblock{FragmentsRegex.2}

\subsection{Unicode Classes}\label{section:regex-unicode-classes}

Unicode defines a range of categories for characters, such as the
category \code{Lu} of uppercase letters (see
\refsec{unicode-categories} for more information).  The regular
expression \code{{\bk}p\{\codeVar{X}\}} matches any unicode character
belonging to the Unicode category \codeVar{X}.  For example,
the class \code{Lu} picks out uppercase letters, so we have
%
\commandlinefollow{ant -Dregex={\bk}p\{Lu\} -Dtext=A regex-match}
\begin{verbatim}
Regex=|\p{Lu}|    Text=|A|    Matches=true
\end{verbatim}
%

Using a capital letter complements the category; for instance,
\code{{\bk}p\{Lu\}} matches uppercase letters, whereas
\code{{\bk}P\{Lu\}} matches any character except an uppercase letter.

\subsection{ASCII Classes}

There are character classes built in for ASCII characters.  For
instance, \code{{\bk}d} is for digits, \code{{\bk}s} for whitespace,
and \code{{\bk}w} for alphanumeric characters.  For example,
%
\commandlinefollow{ant -Dregex={\bk}d -Dtext=7 regex-match}
\begin{verbatim}
Regex=|\d|    Text=|7|    Matches=true
\end{verbatim}
%
For these three ASCII classes, the capitalized forms match
ASCII characters that don't match the lowercase forms.  So
\code{{\bk}D} matches non-digits, \code{{\bk}S} non whitespace,
and \code{{\bk}W} non-alphanumeric characters.

There are a range of built-in ASCII classes from the POSIX standard
built in.  They use the same syntax as the Unicode classes described
in the previous section.  For example, \code{{\bk}p\{ASCII\}} matches
any ASCII character and \code{{\bk}p\{Punct\}} for ASCII punctuation
characters.

The ASCII characters must be used with care, because they will not
have their described behavior when interpreted over all of Unicode.
For example, there are whitespaces in Unicode that don't match
\code{{\bk}s} and digits that don't match \code{{\bk}d}.

\subsection{Compound Character Classes}

Character classes may be built up from single characters and/or other
character classes using set operations like union, intersection, and
negation.

The syntax for compound character classes uses brackets around a
character class expression.  The atomic character class expressions
are single characters like \code{a}, and the character class escapes
like \code{{\bk}p\{Lu\}} matches any uppercase Unicode letter character.

Character classes may be unioned, which confusingly uses a
concatenation syntax.  For instance, \code{[aeiou]} is the character
class picking out the ASCII vowels.  It is composed of the union of
character class expressions \code{a}, \code{e}, \ldots, \code{u}.  
%
\commandlinefollow{ant -Dregex=[aeiou] -Dtext=i regex-match}
\begin{verbatim}
Regex=|[aeiou]|    Text=|i|    Matches=true
\end{verbatim}
%
Class escapes may be used, so that \code{[{\bk}p\{Lu\}{\bk}p\{N\}]}
picks out upper case letters and numbers.

The use of range notation may be used as shorthand for unions.
For instance, \code{[0-9]} picks out the ASCII digits \charmention{0},
\charmention{1}, \ldots, \charmention{9}.  For example,
%
\commandlinefollow{ant -Dregex="[I-P]" -Dtext=J regex-match}
\begin{verbatim}
Regex=|[I-P]|    Text=|J|    Matches=true
\end{verbatim}

Character classes may be complemented.  The syntax involves a caret,
with \code{[\^{}\codeVar{A}]} picking out the class of characters not
in class \codeVar{A}.  The expression \codeVar{A} must be either a
range or a sequence of character class primitives.  For instance,
\code{[\^{}z]} represents the class of every character other than
\charmention{z}.  
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext=z regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|z|    Matches=false
\end{verbatim}
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext=a regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|a|    Matches=true
\end{verbatim}
%
Unlike the usual rules governing the logical operations disjunction,
conjunction, and negation, the character class complementation
operator binds more weakly than union.  Thus \code{[\^{}aeiou]} picks
out every character that is not an ASCII vowel.

Character classes may also be intersected.  The syntax is the same as
for logical conjunction, with \code{[\codeVar{A}\&\&\codeVar{B}]}
picking out the characters that are in the classes denoted by both
\codeVar{A} and \codeVar{B}.  For instance, we could write
\code{[[a-z]\&\&[\^{}aeiou]]} to pick out all lowercase ASCII
characters other than the vowels,
%
\commandlinefollow{ant -Dregex="[[a-z]\&\&[\^{}aeiou]]" -Dtext=i regex-match}
\begin{verbatim}
Regex=|[[a-z]&&[^aeiou]]|    Text=|i|    Matches=false
\end{verbatim}

As described in the Javadoc for \code{Pattern}, the order of
attachment for character class operations is
%
\begin{center}
\begin{tabular}{rll}
\tblhead{Order} & \tblhead{Expression} & \tblhead{Example} 
\\ \hline
1 & Literal Escape & \code{{\bk}x}
\\
2 & Grouping & \code{[...]} 
\\
3 & Range & \code{0-9}
\\
4 & Union & \code{ab}, \code{[0-9][ab]}, 
\\
5 & Intersection & \code{[[a-z]\&\&[\^{}aeiou]]}
\end{tabular}
\end{center}
%
Thus the square brackets act like grouping parentheses for character
classes.  Complementation must be treated separately.  Complementation
only applies to character groups or ranges, and must be closed within
brackets before being combined with union or intersection or the scope
may not be what you expect.  For instance, \code{[\^{}a[b-c]]} is
not equivalent to \code{[\^{}abc]}, but rather is equivalent to
\code{[[\^{}a][b-c]]}.


\section{Concatenation}

As we saw in our early examples, characters may be concatenated
together to form a regular expression that matches the string.  This
is not the same operation as character classes, which confusingly
uses the same notation.  

\subsection{Empty Regex}

With a list of characters (or strings) being concatenated, the
boundary case is the concatenation of an empty list, which is why we
start this section with a discussion of the empty regex.

The simplest regular expression is the empty regular expression.  It
only matches the empty string.  For example, the expression
\code{Pattern.compile("").matcher("").matches()} evaluates to
\code{true}.  Using our test code from the command-line proves tricky,
because we have to escape the quotes if we want to assign environment
variables, as in 
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext={\bk}"{\bk}"  regex-match}
\begin{verbatim}
Regex=||    Text=||    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext=a regex-match}
\begin{verbatim}
Regex=||    Text=|a|    Matches=false
\end{verbatim}


\subsection{Concatenation}

Two regular expressions \codeVar{x} and \codeVar{y} may be
concatenated to produce a compound regular expression \codeVar{xy}.
The regex \codeVar{xy} matches any string that can be decomposed into
a string that matches \codeVar{x} followed by a string that matches
\codeVar{y}.  For example, if we have a regex \code{[aeiou]} that
matches vowels and a regex \code{0-9} that matches digits, we can put
them together to produce a regex that matches a vowel followed by a
digit.
%
\commandlinefollow{ant -Dregex=[aeiou][0-9] -Dtext=i7 regex-match}
\begin{verbatim}
Regex=|[aeiou][0-9]|    Text=|i7|    Matches=true
\end{verbatim}

Concatenation is associative, meaning that if we have three regexes
\codeVar{x}, \codeVar{y}, and \codeVar{z}, the regexes
\code{(\codeVar{x}\codeVar{y})\codeVar{z}} and
\code{\codeVar{x}(\codeVar{y}\codeVar{z})} match exactly the same set
of strings.  Because parentheses may be used for groups (see
\refsec{regex-groups}), the two regexes do not always behave exactly
the same way.  


\section{Disjunction}

If \codeVar{X} and \codeVar{Y} are regular expressions, the regular
expression \codeVar{x}\code{|}\codeVar{y} matches any string that
matches either \codeVar{X} or \codeVar{Y} (or both).  For example,
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=ab regex-match}
\begin{verbatim}
Regex=|ab|cd|
Text=|ab|
Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=cd regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|cd|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=bc regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|bc|    Matches=false
\end{verbatim}
%
Concatenation takes precedence over disjunction, so that \code{ab|cd}
is read as \code{(ab)|(cd)}, not \code{a(b|c)d}.  

The order of disjunctions doesn't matter for matching (other than for
efficiency), but it matters for the find operation.  For finds,
disjunctions are evaluated left-to-right and the first match returned.
%
\commandlinefollow{ant -Dregex="ab|abc" -Dtext=abc regex-find}
\begin{verbatim}
Found |ab| at (0,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="abc|ab" -Dtext=abc regex-find}
\begin{verbatim}
Found |abc| at (0,3)
\end{verbatim}
%

Because complex disjunctions are executed through backtracking,
disjunctions that have to explore many branches can quickly lead to
inefficient regular expressions.  Even a regex as short as
\code{(a|b)(c|d)(e|f)} has $2^3 = 8$ possible search paths to explore.
Each disjunction doubles the size of the search space, leading to
exponential growth in the search space in the number of interacting
disjunctions.  In practice, disjunctions often fail earlier.  For
instance, if there is no match for \code{a|b}, further
disjunctions are not explored.  

A simple pathological case can be created by concatenating instances
of the regex \code{(|a)} and then matching a long string of \code{a}
characters.  You can try it out yourself with
%
\commandline{ant -Dregex="(|a)(|a)...(|a)(|a)" -Dtext=aa...aa regex-find}
%
where the elipses are meant to indicate further copies of \code{a}.
This expression will explore every branch of every disjunction.
Around 25 or 26 copies of \code{(|a)} there are tens of millions of
paths to explore, and with 30, there's over a billion.  You'll be
waiting a while for an answer.  But if the building block is
\code{(a|b)}, there's no problem, because each disjunction has to
match \code{a}.
%
\commandline{ant -Dregex="(b|a)(b|a)...(b|a)(b|a)" -Dtext=aa...aa regex-find}

\section{Greedy Quantifiers}

There are operators for optionality or multiple instances that go
under the general heading of ``greedy'' because of they match as
many times as they can.  In the next section, we consider their
``reluctant'' counterparts that do the opposite.

\subsection{Optionality}

The simplest greedy quantifier is the optionality marker.  The regex
\code{\codeVar{A}?} matches a string that matches \codeVar{A} or the
empty string.  For example,
%
\commandlinefollow{ant -Dregex=a? -Dtext=a regex-match}
\begin{verbatim}
Regex=|a?|    Text=|a|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=a? -Dtext={\bk}"{\bk}" regex-match}
\begin{verbatim}
Regex=|a?|    Text=||    Matches=true
\end{verbatim}

The greediness of the basic optionality marker, which tries to match
before trying to match the empty string, is illustrated using
\code{find()},
%
\commandlinefollow{ant -Dregex=a? -Dtext=aa regex-find}
\begin{verbatim}
Found |a| at (0,1)    Found |a| at (1,2)    Found || at (2,2)
\end{verbatim}
%
The first two substrings found match \code{a} rather than
the empty string.  Only when we are at position 2, at the
end of the string, do we match the empty string because we
can no longer match \code{a}.

The greediness of optionality means that the \code{\codeVar{A}?}
behaves like the disjunction \code{(\codeVar{A}|)} of \codeVar{A} and
the empty string.  Because it is the first disjunct, a match
against \codeVar{A} is tried first.


\subsection{Kleene Star}

A regular expression \codeVar{x} may have the Kleene-star operator%
%
\footnote{Named after Stephen Kleene, who invented regular expressions
as a notation for his characterization of regular languages.}
%
applied to it to produce the regular expression \codeVar{A}\code{*}.
The regex \codeVar{A}\code{*} matches a string if the string is
composed of a sequence of zero or more matches of \codeVar{A}.  For
example, \code{[01]*} matches any sequence composed only of \code{0}
and \code{1} characters,
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext=00100100 regex-match}
\begin{verbatim}
Regex=|[01]*|    Text=|00100100|    Matches=true
\end{verbatim}
%
It will also match the empty string, but will not match a string with
any other character.

Using find, the standard Kleene-star operation is greedy in that it
consumes as much as it can during a \code{find()} operation.  For
example, consider
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext=001a0100 regex-find}
\begin{verbatim}
Found |001| at (0,3)    Found || at (3,3)    Found |0100| at (4,8)
Found || at (8,8)
\end{verbatim}
%
The first result of calling \code{find()} consumes the expression
\code{[01]} as many times as possible, consuming the first three
characters, \code{001}.  After that, the expression matches the empty
string spanning from 3 to 3.  It then starts at position 4, finding
\code{0100} and then the empty string again after that.  Luckily,
\code{find()} is implemented cleverly enough that it only returns the
empty string once.  

Kleene star may also be understood in terms of disjunction.  The
greedy Kleene star regex \code{\codeVar{A}*} behaves like the
disjunction of \code{\codeVar{A}(\codeVar{A}*)} and the empty regex.
Thus it first tries to match \codeVar{A} followed by another match of
\code{\codeVar{A}*}, and only failing that tries to match the empty
string.  For instance, the two regexes in the following patterns match
exactly the same strings.
%
\codeblock{RegexFragments.1}

Kleene star interacts with disjunction in the expected way.  For
example, matching consumes an entire string, as with
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext=abcab regex-match}
\begin{verbatim}
Regex=|(ab|abc)*|    Text=|abcab|    Matches=true
\end{verbatim}
%
while finding returns only an initial match, 
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext=abcab regex-find}
\begin{verbatim}
Found |ab| at (0,2)    Found || at (2,2)    Found |ab| at (3,5)
Found || at (5,5)
\end{verbatim}
%
This is a result of the greediness of the Kleene-star operator
and the evaluation order of disjunctions.  If we reorder, we 
get the whole string,
%
\commandlinefollow{ant -Dregex="(abc|ab)*" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abcab| at (0,5)    Found || at (5,5)
\end{verbatim}
%
because we first match \code{abc} against the disjunct, then continue
trying to match \code{(abc|ab)*}, which matches \code{ab}.

\subsection{Kleene Plus}

The Kleene-plus operator is like the Kleene star, but requires at
least one match.  Thus \codeVar{A}\code{+} matches a string if the
string is composed of a sequence of one or more matches of
\codeVar{A}.  The Kleene-plus operator may be defined in terms
of Kleene star and concatenation, with \code{\codeVar{A}+} behaving
just like \code{\codeVar{A}\codeVar{A}*}.  

Use Kleene plus instead
of star to remove those pesky empty string matches.  For instance, 
%
\commandlinefollow{ant -Dregex="(abc|ab)+" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abcab| at (0,5)
\end{verbatim}

\subsection{Match Count Ranges}

We can specify an exact number or a range of possible number of
matches.  The regular expression \code{\codeVar{A}\{\codeVar{m}\}}
matches any string that that may be decomposed into a sequence of
\codeVar{m} strings, each of which matches \codeVar{A}.
%
\commandlinefollow{ant -Dregex="a\{3\}" -Dtext=aaa regex-match}
\begin{verbatim}
Regex=|a{3}|    Text=|aaa|    Matches=true
\end{verbatim}
%

There is similar notation for spans of counts.  The regex
\code{\codeVar{A}\{\codeVar{m},\codeVar{n}\}} matches any string that
may be decomposed into a sequence of between \codeVar{m} (inclusive)
and \codeVar{n} (inclusive) matches of \codeVar{A}.  The greediness
comes in because it prefers to match as many instances as possible.
For example,
%
\commandlinefollow{ant -Dregex="a\{2,3\}" -Dtext=aaaaa regex-find}
\begin{verbatim}
Found |aaa| at (0,3)    Found |aa| at (3,5)
\end{verbatim}
%
The first result found matches the regex \code{a} three times
rather than twice.  

There is also an open-ended variant.  The regex
\code{\codeVar{A}\{\codeVar{m},\}} matches any string that can be
decomposed into \codeVar{m} or more strings each of which matches
\codeVar{A}.

\section{Reluctant Quantifiers}

There are a range of reluctant quantifiers that parallel the more
typical greedy quantifiers.  For matching, the reluctant quantifiers
behave just like their greedy counterparts, whereas for find
operations, reluctant quantifiers try to match as little as possible.

The reluctant quantifiers are written like the greedy quantifiers
followed by a question mark.  For instance, \code{\codeVar{A}*?}  is
the reluctant version of the Kleene star regex \code{\codeVar{A}*},
\code{\codeVar{A}\{m,n\}?} is the reluctant variant of the range regex
\code{\codeVar{A}\{m,n\}}, and \code{\codeVar{A}??} is the reluctant
variant of the optionality regex \code{\codeVar{A}?}.

Reluctant quantifiers may be understood by reversing all the disjuncts
in the definitions of the greedy quantifier equivalents.  For
instance, we can think of \code{\codeVar{A}??} as
\code{\codeVar{(|\codeVar{A})}} and \code{\codeVar{A}*?} as
\code{(|\codeVar{A}\codeVar{A}*?)}. 

Here we repeat some key examples of the previous section using reluctant
quantifiers.
%
\commandlinefollow{ant -Dregex=a?? -Dtext=aa regex-find}
\begin{verbatim}
Found || at (0,0)    Found || at (1,1)    Found || at (2,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="(abc|ab)+?" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abc| at (0,3)    Found |ab| at (3,5)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="a\{2,3\}?" -Dtext=aaaaa regex-find}
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%


\section{Possessive Quantifiers}

The third class of quantified expression is the possessive quantifier.
Possessive quantifiers will not match a fewer number of instances of
their pattern if they can match more.  Procedurally, they commit to
a match once they've made it and do not allow backtracking.

The syntax for a possessive quantifier follows the quantifier symbol
with a plus sign (\code{+}); for instance, \code{?+} is possessive
optionality and \code{*+} is greedy Kleene star.

Consider the difference between a greedy Kleene star
%
\commandlinefollow{ant "-Dregex=[0-9]*1" -Dtext=1231 regex-match}
\begin{verbatim}
Regex=|[0-9]*1|    Text=|1231|    Matches=true
\end{verbatim}
%
which matches, and a possessive Kleene star,
%
\commandlinefollow{ant "-Dregex=[0-9]*+1" -Dtext=1231 regex-match}
\begin{verbatim}
Regex=|[0-9]*+1|    Text=|1231|    Matches=false
\end{verbatim}
%
which does not match.  Even though \code{[0-9]*} indicates a greedy
match, it is able to back off and only match the first three
characters of the input, \code{123}.  The possessive quantifier, once
it has matched \code{1231}, does not let it go, and the overall match
fails.

\subsection{Independent Group Possessive Marker}

If \codeVar{A} is a regex, then \code{(?>\codeVar{A})} is a regex that
matches the same thing as \codeVar{A}, but groups the first match
possessively.  That is, once \code{(?>\codeVar{A})} finds a match
for \codeVar{A}, it does not allow backtracking.   We can see this
with a pair of examples.
%
\commandlinefollow{ant -Dregex="(?>x+)xy" -Dtext=xxy regex-match}
\begin{verbatim}
Regex=|(?>x+)xy|    Text=|xxy|    Matches=false
\end{verbatim}
%
This doesn't match, because the \code{x+} matches both
instances of \charmention{x} in the text being matched and doesn't
allow backtracking.  Contrast this with
%
\commandlinefollow{ant -Dregex="(?>x+)y" -Dtext=xxy regex-match}
\begin{verbatim}
Regex=|(?>x+)y|    Text=|xxy|    Matches=true
\end{verbatim}

The parentheses in this construction do not count for grouping
(see \refsec{regex-groups}).  There is a similar construction
\code{(?:\codeVar{A})} which is not possessive, and also does
not count the parentheses for grouping.  




\section{Non-Capturing Regexes}

Some regexes match virtual positions in an input without consuming any
text themselves.  

\subsection{Boundary Matchers}

Boundary matchers match specific sequences, but do not consume any
input themselves.  

\subsubsection{Begin- and End-of-Line Matchers}

The caret (\code{\^{}}) is a regular expression that matches the end
of a line and the dollar sign (\code{\$}) a regular expression
matching the beginning of a line.  For example, 
%
\commandlinefollow{ant -Dregex="\^{}abc\$" -Dtext=abc regex-match}
\begin{verbatim}
Regex=|^abc$|    Text=|abc|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=ab\$c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|ab$c|    Text=|abc|    Matches=false
\end{verbatim}
%
The begin- and end-of-line regexes do not themselves consume any
characters.

These begin-of-line and end-of-line regexes do not match new lines
inside of strings unless the \code{MULTILINE} flag is set (see
\refsec{pattern-modes}).  By default, these regexes match new-line
sequences for any platform (Unix, Macintosh, or Windows) and many more
(see \refsec{regex-lines} for the full set of line terminators).  If
the
\code{UNIX\_LINES} flag is set, they only match Unix newlines (see
\refsec{pattern-modes}).

\subsubsection{Begin and End of Input}

Because begin-of-line and end-of-line have variable behavior, there
are regexes \code{{\bk}A} for the beginning of the input and
\code{{\bk}z} for the end of the input.  These will match the begin
and end of the input no matter what the match mode is.  For
instance,
%
\commandlinefollow{ant -Dregex={\bk}A(mnp){\bk}z -Dtext=mnp regex-group}
\begin{verbatim}
regex=|\A(mnp)\z|    text=|mnp|
Group  0=|mnp| at (0,3)    Group  1=|mnp| at (0,3)
\end{verbatim}
%

\subsubsection{Word Boundaries}

The regex \code{{\bk}b} matches a word boundary and \code{{\bk}B} a
non-word boundary, both without consuming any input.  Word boundaries
are the usual punctuation and spaces and the begin and end of input.
For example,
%
\commandlinefollow{ant -Dregex={\bk}b{\bk}w+{\bk}b -Dtext="John ran quickly." regex-find}
\begin{verbatim}
Found |John| at (0,4)        Found |ran| at (5,8)    
Found |quickly| at (9,16)
\end{verbatim}


\subsection{Positive and Negative Lookahead}

Often you want to match something only if it occurs in a given
context.  If \codeVar{A} is a regex, then \code{(?=\codeVar{A})} is
the positive lookahead and \code{(?!\codeVar{A})} the negative
lookahead regular expression.  These match a context that either
matches or doesn't match the specified regular expression.  They
must be used following other regular expressions.  For instance,
to find the instances of numbers preceding periods, we could
use 
%
\commandlinefollow{ant -Dregex="{\bk}d+(?={\bk}.)" -Dtext=12.2 regex-find}
\begin{verbatim}
Found |12| at (0,2)
\end{verbatim}
%
and to find those not preceding periods, 
%
\commandlinefollow{ant -Dregex="{\bk}d+(?!{\bk}.)" -Dtext=12.2 regex-find}
\begin{verbatim}
Found |1| at (0,1)    Found |2| at (3,4)
\end{verbatim}
%
In a real application, we would probably exclude numbers and periods
in the negative lookahead, with a regex such as
\code{{\bk}d+(?![{\bk}.{\bk}d])}.

One reason the lookahead is nice is that further finds can match
the material that the lookahead matched.

\subsection{Positive and Negative Lookbehind}\label{section:regex-lookbehind}

There are backward-facing variants of the positive and negative
lookahead constructs, \code{(?<=\codeVar{X})} and 
\code{(?<!\codeVar{X})}.  These are more limited in that the
regular expression \codeVar{X} must expand to a simple sequence, and
thus may not contain the Kleene-star or Kleene-plus operations.

For example, the following example finds sequences of digits that do
not follow periods or other digits
%
\commandlinefollow{ant -Dregex="(?<![{\bk}.{\bk}d]){\bk}d+" -Dtext=12.32 regex-find}
\begin{verbatim}
Found |12| at (0,2)
\end{verbatim}
%

\subsection{Line Terminators and Unix Lines}\label{section:regex-lines}

\begin{center}
\begin{tabular}{lll}
\tblhead{Code Point(s)} & \tblhead{Description} & \tblhead{Java} 
\\ \hline
\unicode{000A} & \unicodedesc{line feed} & \code{{\bk}n}
\\
\unicode{000D} & \unicodedesc{carriage return} & \code{{\bk}r}
\\
\unicode{000D}, \unicode{000A} & \unicodedesc{carriage return},
\unicodedesc{line feed} & \code{{\bk}r{\bk}n}
\\
\unicode{0085} & \unicodedesc{next line} & \code{{\bk}u0085} 
\\
\unicode{2028} & \unicodedesc{line separator} & \code{{\bk}u2028}
\\
\unicode{2029} & \unicodedesc{paragraph separator} & \code{{\bk}u2029}
\end{tabular}
\end{center}


\section{Parentheses for Grouping}\label{section:regex-groups}

Parentheses play the usual role of grouping in regular expressions,
and may be used to disambiguate what would otherwise be misparsed.
For instance, the expression \code{(a|b)c} is very different than
\code{a|(bc)}.

Parentheses also play the role of identifying the subexpressions
they wrap.  

If \codeVar{A} is a regular expression, \code{(\codeVar{A})} is a
regular expression that matches exactly the same strings as
\codeVar{A}.  Note that parentheses come in matched pairs, and
each picks out the unique subexpression \codeVar{A} it wraps.

The pairs of parentheses in a regular expression are numbered
from left to right, beginning with 1.  For example, we've written
a very simple regex with the identifier of each parentheses group
on the next line
%
\begin{verbatim}
 a(b(cd)(e))
0 1 2   3
\end{verbatim}
%
There is an implicit pair of parentheses around the entire pattern,
with group number 0.  Group 1 is \code{b(cd)(e)},
group 2 is \code{cd}, and group 3 is \code{e}.  

The identities of the groups are useful for pulling out substring
matches (this section), using back references in regexes (see
\refsec{regex-back-references}) and replace operations based on regexes (see
\refsec{regex-replace}). 

After a match or a find operation, the substring of the match that
matched each group is available from the matcher with a method
\code{group(int)}, where the argument indicates which group's match
is returned.  The start and end position of a group may also be
retrieved, using \code{start(int)} and \code{end(int)}.  The total
number of groups in the regex is available through the method
\code{groupCount()}.  The methods
\code{group()}, \code{start()}, and \code{end()} we used earlier to
retrieve the match of the entire string are just shorthand for
\code{group(0)}, \code{start(0)}, and \code{end(0)}.  If there hasn't
been a match or the last find did not succeed, attempting to retrieve
groups or positions raises an illegal state exception.

We provide a simple class \code{RegexGroup} to illustrate the workings
of group extraction.  The work is done in the \code{main()} method
by the code
%
\codeblock{RegexGroup.1}
%
Here we call \code{matcher.match()}, which requires a match of the
entire text.  

We set up the Ant target \code{regex-group} to call it, and test
it in the usual way, using the example whose groups are numbered
above.
%
\commandlinefollow{ant -Dregex=a(b(cd)(e)) -Dtext=abcde regex-group}
\begin{verbatim}
regex=|a(b(cd)(e))|    text=|abcde|
Group  0=|abcde| at (0,5)    Group  1=|bcde| at (1,5)
Group  2=|cd| at (2,4)       Group  3=|e| at (4,5)
\end{verbatim}
%
A more typical linguistic example would be to pull out names
after the word \stringmention{Mr}, as in
%
\commandlinefollow{ant -Dregex=Mr(({\bk}s({\bk}p\{Lu\}{\bk}p\{L\}*))+) -Dtext="Mr J Smith" regex-group}
\begin{verbatim}
Group  0=|Mr J Smith| at (0,10)    Group  1=| J Smith| at (2,10)
Group  2=| Smith| at (4,10)        Group  3=|Smith| at (5,10)
\end{verbatim}
%
Group 1 corresponds to the name, but note that we have an extra
leading space.  We can get rid of that with a more complex regex, and
we could also allow optional periods after \stringmention{Mr} with the
appropriate escape, and also deal with periods in names.  Matching
complicated patterns with regexes is a tricky business.

\subsection{Non-Capturing Group}

It is possible to use parentheses without capturing.  If \codeVar{X}
is a regex, then \code{(?:\codeVar{X})} matches the same things as
\codeVar{X}, but the parentheses are not treated as capturing.


\section{Back References}\label{section:regex-back-references}

The regex \code{\bk\codeVar{n}}\, is a back reference to the match of
the \codeVar{n}-th capturing group before it.  We can use matching
references to find pairs of duplicate words in text.  For instance,
consider
%
\commandlinefollow{ant -Dregex="({\bk}d+).*({\bk}1)" -Dtext="12 over 12" regex-group}
\begin{verbatim}
Group  0=|12 over 12| at (0,10)    Group  1=|12| at (0,2)
Group  2=|12| at (8,10)
\end{verbatim}
%
The regex \code{{\bk}1} will match whatever matched group 1.  
Group 1 is \code{({\bk}d+)} and group 2 is \code{({\bk}1)}; both
match the expression \stringmention{12}, only at different places.
You can see that the text \stringmention{12 over 13} would not
have matched.  

If the match index is out of bounds for the number of groups, matching
fails without raising an exception.


\section{Pattern Match Flags}\label{section:pattern-modes}

There are a set of flags, all represented as static integer constants
in \code{Pattern}, which may be supplied to the pattern compiler
factory method \code{Pattern.compile(String,int)} to control the
matching behavior of the compiled pattern.  
%
\begin{center}
\begin{tabular}{lrp{0.55\textwidth}}
\tblhead{Constant} & \tblhead{Value} & \tblhead{Description} 
\\ \hline { } \\[-6pt]
\code{DOTALL}
& 32
& Allows the wild card (\code{.}) expression to match any
character, including line terminators.  If this mode is not
set, the wild card does not match line terminators.
\\[4pt]
\code{MULTILINE}
& 8
& Allows the begin-of-line (\code{\^{}}) and end-of-line (\code{\$}) to
match internal line terminators.  If this is not set, they only
match before the first and after the last character.  The full Java
notion of newline is used unless the flag \code{UNIX\_LINES} is also set.
\\[4pt]
\code{UNIX\_LINES}
& 1
& Treat newlines as in Unix, with a single \unicode{000A},
\unicodedesc{line feed}, Java string escape \code{{\bk}n},
representing a new line.  This affects the behavior of wildcard
(\code{.}) and begin-of-line (\code{\^{}}) and end-of-line 
(\code{\$}) expressions. 
\\[4pt] 
\code{CASE\_INSENSITIVE} 
& 2
& Matching is insensitive to case.  Case folding is only for
the ASCII charset (\unicode{0000} to \unicode{007F}) unless
the flag \code{UNICODE\_CASE} is also set, which uses the Unicode
definitions of case folding.
\\[4pt]
\code{UNICODE\_CASE}
& 64
& If this flag and the \code{CASE\_INSENSITIVE} flag is set,
matching ignores case distinctions as defined by Unicode
case folding rules.
\\[4pt]
\code{CANON\_EQ} 
& 128
& Matches are based on canonical equivalence in Unicode 
(see \refsec{unicode-normalization-forms}).
\\[4pt]
\code{LITERAL} 
& 16
& Treats the pattern as a literal \ie{no parsing}.
\\[4pt]
\code{COMMENTS}
& 4
& Allows comments in patterns and causes pattern-internal whitespace to be ignored.
\end{tabular}
\end{center}

The flags are defined using a bit-mask pattern whereby multiple
flags are set by taking their bitwise-or value.%
%
\footnote{Although bitwise or looks like addition for flags like
these with only one bit on, it breaks down when you try to set
flags twice.  Thus \code{DOTALL~+~MULTILINE} evaluates to the
same thing as \code{DOTALL~|~MULTINE}, \code{DOTALL~+~DOTALL}
evaluates to the same thing as \code{UNICODE\_CASE}, whereas
\code{DOTALL~|~DOTALL} evaluates to the same thing as \code{DOTALL}.}
%
For instance,
the expression \code{DOTALL~|~MULTILINE} allows the wildcard
to match anything and the line-terminator expressions to match
internal newlines.  More than two flags may be set this way,
so we could further restrict to Unix newlines with
\code{DOTALL~|~MULTILINE~|~UNIX\_LINES}.  

Even stronger matching than canonical equivalence with unicode case
folding can be achieved by writing the regular expression using
compatibility normal forms and using the ICU package to perform a
compatibility decomposition on the input (see
\refsec{unicode-normalization-forms}).


\section{Pattern Construction Exceptions}

Attempting to compile a regular expression with a syntax error raises
a runtime exception, \code{PatternSyntaxException} from the
\code{java.util.regex} package.  The parser tries to provide a helpful
warning message.  For instance, here's what we see if we inadvertently
add a right parenthesis to our regex.
%
\commandlinefollow{ant -Dregex=aa) -Dtext=aaab regex-find}
\begin{verbatim}
Exception in thread "main" 
    java.util.regex.PatternSyntaxException:  
    Unmatched closing ')' near index 1
\end{verbatim}


\section{Find-and-Replace Operations}\label{section:regex-replace}

A common usage pattern for regular expressions is to find instances of
one pattern and replace them with another.  We provide a sample
program \code{RegexReplace}, which illustrates replacement in
its \code{main()} method,
%
\codeblock{RegexReplace.1}
%
The pattern and matcher are created as usual.  Then, we create
a string by replacing all the matches of the pattern in the text
provided to the matcher with the specified replacement.  We could
also use \code{replaceFirst()} to return the result of only replacing
the first match.

With the Ant target \code{regex-replace}, we can see this in action.
%
\commandlinefollow{ant -Dregex={\bk}d+ -Dreplacement=0 -Dtext="+1 (718) 290-9170" regex-replace}
\begin{verbatim}
regex=|\d+|    replacement=|0|    
text=|+1 (718) 290-9170|    result=|+0 (0) 0-0|
\end{verbatim}
%
We've replaced every sequence of digits with a zero.  

A nice feature of replace operations is that they may reference
pieces of the match by group number and use them in the replacement.
An occurrence of \code{\$\codeVar{n}} in the replacement string
represents whatever matched group \codeVar{n} in the match.

For instance, we can extract the version number from a jar and
redisplay it using
%
\commandlinefollow{ant -Dregex=({\bk}w+){\bk}-([{\bk}d{\bk}.]+){\bk}.jar -Dreplacement="\$1.jar v\$2" -Dtext="foo-7.6.jar" regex-replace}
\begin{verbatim}
regex=|(\w+)\-([\d\.]+)\.jar|    replacement=|$1.jar v$2|
text=|foo-7.6.jar|               result=|foo.jar v7.6|
\end{verbatim}
%
Note that we had to escape the literal hyphen and period characters in
the regex.  The class \code{{\bk}w} is for word characters, which are
alphanumerics and the underscore.  The example regexes are very
fragile, and it is quite difficult to write more robust regexes.

\section{String Regex Utilities}

There are many utility methods in the \code{String} class that
are based on regular expressions.  

The method \code{matches(String)} returns \code{true} if the string
matches the regex specified by the argument.  Given a regex \code{r},
\code{matches(r)} is just shorthand for
\code{Pattern.compile(r).matcher(this).matches()}.

The method \code{replaceAll(String,String)}, which takes a string
representing a regex and a replacement string, returns the result
of replacing all the substrings in the string matching the regex
with the replacement string.  Given a regex \code{r} and replacement
\code{s}, \code{replaceAll(r,s)} is just shorthand for
\code{Pattern.compile(r).matcher(this).replaceAll(s)}.  As such,
the replacement may contain references to match groups.  There is also
a corresponding \code{replaceFirst()} method.

One of the more useful utilities is
\code{split(String)}, which splits a string around the matches of
a regular expression, returning an array as a result.  For instance,
\code{"foo12bar177baz\".split({\bk}d+)} splits on digits, returning
the string array \code{\{~"foo", "bar", "baz"~\}}.  Note that the
matching numbers are removed.

\section{Thread Safety, Serialization, and Reuse}

\subsection{Thread Safety}

Because instances of \code{Pattern} are immutable, it is safe to use
them concurrently in multiple threads.  Because instances of
\code{Matcher} contain the state of the current match, it is not
thread safe to use matchers concurrently without synchronization.

\subsection{Reusing Matchers}

Matchers may be reused.  The method \code{reset()} may be called on a
matcher to reset it to behave as if it had just been constructed with
its given pattern and character sequence.  The character sequence may
be changed.  The pattern may also be changed on the fly, without
changing the current position.  This may be useful if you alternately
match first one pattern then another.  Although matchers may be
reused, the typical usage pattern is to construct them for a text, use
them once, then discard them.


\subsection{Serialization}

Patterns are serializable.  The string representing the pattern and
the compilation flags are stored and the version read back in is an
instance of \code{Pattern} behaving just like the original.  Often
patterns do not need to be serialized because they're effectively
singletons \ie{constants}.






