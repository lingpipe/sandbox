\chapter{Regular Expressions}\label{chapter:regex}

Generalized regular expressions, as implemented in Java and all the
scripting languages like Perl and Python, provide a general means for
describing spans of Unicode text.  Given a regular expression (regex)
and some text, basic regex functionality allows us to test whether a
string matches the regex or find non-overlapping substrings of a
string matching the regex.

We start with the classes and methods in package \code{java.util.regex}
and build a series of short example programs.
Then we cover the syntax for regular expressions in Java using
our example programs to show how different constructions behave.
Our discussion of regular expressions is limited.
We recommend 
\emph{Matering Regular Expressions, 3rd Edition} by Jeffrey E.F. Friedl,
O'Reilly and Associates, 2006, for a comprehensive treatment of
regular expressions in theory and practice.

The example programs for this chapter are in the code directory:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex}}


\section{The \code{java.util.regex} Package}\label{section:java-util-regex}

Despite the rich functionality of regexes, Java's
\code{java.util.regex} package contains only two classes,
\code{Pattern} and \code{Matcher}.  An instance of \code{Pattern}
provides an immutable representation of a regular expression. An
instance of \code{Matcher} represents the state of the matching of a
regular expression against a string.

\subsection{Matching Entire Strings}\label{section:exact-match-regex}

It's easiest to start with an example of using a regular expression
for matching, which we wrote as a the example class \code{RegexMatch}:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexMatch.java}}
%
\codeblock{RegexMatch.1}
%
First, we read the regex from the first command-line argument, then
the text from the second argument.  We then use the regular expression
to compile a pattern, using the static factory method
\code{pattern.compile()}.  This pattern is reusable.  We next
create a matcher instance, using the method \code{matcher()} on the
pattern we just created.  Finally, we assign a boolean variable
\code{matches} the value of calling the method \code{matches()} 
on the matcher.  And then we print out the result.

Regular expressions may consist of strings, in which case they
simply carry out exact string matching.  
We use simple strings as the regex for the examples in this section.
In the following sections we go through the regex syntax
and re-run these programs with more powerful regexes.

To test our program, we try to match the regex
\code{aab} against string \stringmention{aabb}.
There is an Ant target \code{regex-match} which feeds the command-line
arguments to our program.  For the example at hand, we have
%
\commandlinefollow{ant -Dregex="aab" -Dtext="aabb" regex-match}
\begin{verbatim}
Regex=|aab|    Text=|aabb|    Matches=false
\end{verbatim}
%
The test fails because there isn't an exact match
against the entire string.
On the other hand, the regex \code{abc} does match
the string \stringmention{abc}.
%
\commandlinefollow{ant -Dregex="abc" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|abc|    Text=|abc|    Matches=true
\end{verbatim}
%
Note that we have used the vertical bar to mark the boundaries of the
regular expression and text in our output.  These vertical bars are
not part of the regular expression or the text.  This is a useful
trick in situations where space may appear as the prefix or suffix of
a string.  It may get confusing if there is a vertical bar within the
string, but the outer vertical bars are always the ones dropped.

\subsection{Finding Matching Substrings}\label{section:regex-find}

The second main application of regular expressions is to find
substrings of a string that match the regular expression.  The main
method in our class \code{RegexFind} illustrates this:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexFind.java}}
%
We read in two
command-line arguments into string variables \code{regex} and \code{text}
as we did for \code{RegexMatch} in the previous section.  We begin
by compiling the pattern and creating a matcher for the text just
as in \code{RegexFind}.
%
\codeblock{RegexFind.1}
%
The first call of the \code{find()} method on a matcher returns
\code{true} if there is a substring of the text that matches the
pattern.  If \code{find()} returned \code{true}, then the are method
\code{group()} returns the substring that matched, and the methods
\code{start()} and \code{end()} return the span of the match, which is
from the start (inclusive) to the end (exclusive).

Subsequent calls to \code{find()} return \code{true} if there is a
match starting on or after the end position of the previous calls.
Thus the loop structure in the program above is the standard idiom
for enumerating all the matches.  

As an example, we use the Ant target \code{regex-find}, which takes
the same arguments as \code{regex-match}.
%
\commandlinefollow{ant -Dregex="aa" -Dtext="aaaaab" regex-find}
%
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%
As before, the vertical bars are delimiters, not part of the matching
substring.  The string \stringmention{aa} actually shows up in four
distinct locations in \stringmention{aaaaab}, at spans (0,2), (1,3),
(2,4), and (3,5).  Running find only returns two of them.  The matcher
works from the start to the end of the string, returning the first
match it finds after the first call to \code{find()}.  In this case,
that's the substring of \stringmention{aaaaab} spanning (0,2).  The
second call to \code{find()} starts looking for a match at position 2,
succeeding with the span (2,4).  Next, it starts looking at position
4, but there is no substring starting on or after position 4 that
matches \stringmention{aa}.

\subsection{Find-and-Replace Operations}\label{section:regex-replace}

A common usage pattern for regular expressions is to find instances of
one pattern and replace them with another.  We provide a sample
program \code{RegexReplace}:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexGroup.java}}
%
The \code{main()} method illustrates replacement.
%
\codeblock{RegexReplace.1}
%
The pattern and matcher are created as usual.  Then, we create
a string by replacing all the matches of the pattern in the text
provided to the matcher with the specified replacement.  We could
also use \code{replaceFirst()} to return the result of only replacing
the first match.

With the Ant target \code{regex-replace}, we can see this in action.
%
\commandlinefollow{ant -Dregex="a" -Dreplacement=z -Dtext="abc abc" regex-replace}
\commandlinefollow{ant -Dregex="{\bk}d+" -Dreplacement=0
  -Dtext="+1~(718)~290-9170" regex-replace}
\begin{verbatim}
regex=|a|       replacement=|z|
text=|abc abc|  result=|zbc zbc|
\end{verbatim}
%
\subsubsection{How the \code{Matcher.replaceAll} method works }\label{section:regex-replaceAll}

The following example comes from the Java SE 7 javadoc for the
\code{Matcher.appendReplacement} method
%
\codeblock{RegexFragments.2}
%
This code writes \code{one dog two dogs in the yard} to the standard-output stream.

The \code{Matcher.replaceAll} method uses this same sequence of calls to
the methods \code{find}, \code{appendReplacement}, and \code{appendTail}.
As in the above example, a \code{StringBuffer} is used to store 
the intermediate results.
\code{StringBuffer} objects are thread-safe and therefore this operations
incurs a certain amount of processing overhead due to synchronization.


\section{Empty Regex}\label{section:regex-empty}

The simplest regular expression is the empty regular expression.  It
only matches the empty string.  For example, the expression
\code{Pattern.compile("").matcher("").matches()} evaluates to
\code{true}.  Using our test code from the command-line proves tricky,
because we have to escape the quotes if we want to assign environment
variables, as in 
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext={\bk}"{\bk}"  regex-match}
\begin{verbatim}
Regex=||    Text=||    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext="a" regex-match}
\begin{verbatim}
Regex=||    Text=|a|    Matches=false
\end{verbatim}
The empty regex matches everywhere in a string, as the following example shows.
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext="aa" regex-find}
\begin{verbatim} 
Found || at (0,0)
Found || at (1,1)
Found || at (2,2)
\end{verbatim} 
The replacing the empty regex inserts the replacement between every
existing character in a string.
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dreplacement=z -Dtext="aa" regex-replace}
\begin{verbatim}
regex=||   replacement=|z|
text=|aa|  result=|zazaz|
\end{verbatim}

\section{Character Regexes}

The most basic regular expressions describe single characters.  Some
characters have special meanings in regexes and thus need to be
escaped for use in regular expressions.

\subsection{Characters as Regexes}

A single character may be used a regular expression.  A regular
expression consisting of a single character only matches that single
character.  For instance,
\code{Pattern.compile("a").matcher("a").matches()} would evaluate to
\code{true}.  Using our Ant match target, 
%
\commandlinefollow{ant -Dregex="b" -Dtext="b" regex-match}
\begin{verbatim}
Regex=|b|    Text=|b|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="b" -Dtext="c" regex-match}
\begin{verbatim}
Regex=|b|    Text=|c|    Matches=false
\end{verbatim}
%
Within a Java program, Java character literals may be used within the
string denoting the regex.  For instance, we may write
\code{Pattern.compile("{\bk}u00E9")} to compile the regular expression
that matches the character \unicode{00E9}, \unicodedesc{latin small e
  with acute}, which would be written as \charmention{\'e}.

\subsubsection{Unicode Escapes}

Arbitrary unicode characters may be escaped in the same way as in
Java.  That is, \code{{\bk}u}\codeVar{hhhh} is a regular expression
matching the character with Unicode code point
\unicode{\codeVar{hhhh}}.  For example,
%
\commandlinefollow{ant -Dregex="{\bk}u0041" -Dtext="A" regex-match}
%
\begin{verbatim}
Regex=|\u0041|    Text=|A|    Matches=true
\end{verbatim}
%
Note that we did not have to escape the backslash for the shell
because the following character, \code{u}, is not an escape.  Unicode
escapes are useful for for matching the period character,
\unicode{002E}, \unicodedesc{full stop}, which is a reserved character
in regexes representing wildcards (see \refsec{regex-wildcard}).
%
\commandlinefollow{ant -Dregex="{\bk}u002E" -Dtext="." regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%

In a Java program, we'd still have to write
\code{Pattern.compile("{\bk}{\bk}u002E")}.  

Unicode escapes in regexes are confusing, because they use the same
syntax as Java unicode literals.  Further complicating matters, the
literal for backslashes in Java programs is itself an escape sequence,
\code{{\bk}{\bk}}.  There is a world of difference between the
patterns produced by \code{Pattern.compile("{\bk}u002E")} and
\code{Pattern.compile("{\bk}{\bk}u002E")}.  The former is the same
as \code{Patten.compile(".")}, and matches any character, whereas
the latter uses a regex escape, and only matches the period
character.

\subsubsection{Other Escapes}

There are also other built-in escapes, such as \code{{\bk}n} for
newline and \code{\bk\bk} for a backslash character.  Again, we have
to be careful about distinguishing Java string escapes, which are used
to create a regex, which itself may contain regex escapes.  

Because Java itself also uses a backslash for escapes (see above),
to specify a single backslash we write \code{\bk\bk} and 
to specify an escape character that contains a backslash such as newline 
\code{{\bk}n} we write \code{\bk{\bk}n}.  To create the regex \code{\bk\bk}, 
we need to use two backslash escapes in our string literal, writing
\code{Pattern.compile("\bk\bk\bk\bk")}.  

Running this example from the command-line is problematic.
The shell itself is a scripting language with its own set of
escape characters, one of which is the backslash.
Usually we use double quotes to enclose the arguments and prevent
the shell from expanding special characters, but \code{\bk"} is a valid escape
sequence for the shell which means that the closing double quotes on the
command line arguments aren't interpreted correctly.
We use single quotes instead because
the shell treats all text enclosed by single quotes as a literal.%
%
\footnote{Different implementations of the bash shell
parse the command line differently.  Try this on your machine
using double quotes or no quotes around the arguments.}

To invoke the regex-match program with a regex consisting 
of the backslash literal, we need to set up the call \code{Pattern.compile("\bk\bk\bk\bk")}
and match it against a text consisting of the backslash literal \code{\bk\bk}.
%
\commandlinefollow{ant -Dregex='\bk\bk\bk\bk' -Dtext='\bk\bk' regex-match}
%
\begin{verbatim}
Regex=|\\|    Text=|\|    Matches=true
\end{verbatim}
%
Our Java program gets a value for \code{regex} consisting of a
length-two string made up of two backslashes, and value for text
consisting of a single backslash.  The match succeeds because the
regex \code{\bk\bk} is the escaped backslash character, which matches
a single backslash.


\section{Character Classes}

Regular expressions provide a range of built-in character classes
based on ASCII or Unicode, as well as the ability to define new
classes.  Each character class matches a set of characters.

A familiar example of a character class is the \code{digits} class,
which comprises the ASCII digits \{0,1,2,3,4,5,6,7,8,9\}.
In Java this class can be specified either explicitly as \code{[0-9]}
or by the pre-defined character class \code{{\bk}d}.
We strongly recommend the use of the predefined classes whenever possible.
They make your code easier to read and eliminate errors introduced by 
incomplete or malformed definitions.

Application-specific character classes are specified as a set of
character alternatives enclosed in brackets.
For example, \code{[aA]} specifies the character class that matches
both the upper and lower case letter A.
This syntax is confusing because within the square brackets
\code{aA} is interpreted as 
the set resulting from the union of these two atomic characters
but outside of this context the \code{aA} is interpreted as
the concatenation of these two characters.
Trying to do an exact match between the regex and \code{[aA]}
and the string \code{aA} fails.
%
\commandlinefollow{ant -Dregex="[aA]" -Dtext="aA" regex-match}
\begin{verbatim}
Regex=|[aA]|    Text=|aA|    Matches=false
\end{verbatim}
%
Because character classes may appear within other character classes,
these alternatives need not be single characters.
We discuss compound character classes later in this section.

\subsection{The WildCard as the Universal Character Class}\label{section:regex-wildcard}

A singe period (\code{.}) is a regular expression that matches any
single character.  We may think of it as the universal character class.
For instance, the regex \code{.} matches the string \stringmention{a},
and \code{a.c} matches \stringmention{abc}.%
%
\commandlinefollow{ant -Dregex="a.c" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|a.c|    Text=|abc|    Matches=true
\end{verbatim}
%

Whether or not a wildcard matches an end-of-line sequence depends on
whether or not the \code{DOTALL} flag is set (see
\refsec{pattern-modes}); if it is set, the wildcard matches
end-of-line sequences.  The following two expressions evaluate to
\code{true},
%
\codeblock{FragmentsRegex.1}
%
whereas the following expression evaluates to \code{false},
%
\codeblock{FragmentsRegex.2}

\subsection{Unicode Classes}\label{section:regex-unicode-classes}

Unicode defines a range of categories for characters, such as the
category \code{Lu} of uppercase letters (see
\refsec{unicode-categories} for more information).  The regular
expression \code{{\bk}p\{\codeVar{X}\}} matches any unicode character
belonging to the Unicode category \codeVar{X}.  For example,
the class \code{Lu} picks out uppercase letters, so we have
%
\commandlinefollow{ant -Dregex="{\bk}p\{Lu\}" -Dtext="A" regex-match}
\begin{verbatim}
Regex=|\p{Lu}|    Text=|A|    Matches=true
\end{verbatim}
%

Using a capital letter complements the category; for instance,
\code{{\bk}p\{Lu\}} matches uppercase letters, whereas
\code{{\bk}P\{Lu\}} matches any character except an uppercase letter.

\subsection{ASCII Classes}

There are character classes built in for ASCII characters.  For
instance, \code{{\bk}d} is for digits, \code{{\bk}s} for whitespace,
and \code{{\bk}w} for alphanumeric characters.  For example,
%
\commandlinefollow{ant -Dregex="{\bk}d" -Dtext="7" regex-match}
\begin{verbatim}
Regex=|\d|    Text=|7|    Matches=true
\end{verbatim}
%
For these three ASCII classes, the capitalized forms match
ASCII characters that don't match the lowercase forms.  So
\code{{\bk}D} matches non-digits, \code{{\bk}S} non whitespace,
and \code{{\bk}W} non-alphanumeric characters.

There are a range of built-in ASCII classes from the POSIX standard
built in.  They use the same syntax as the Unicode classes described
in the previous section.  For example, \code{{\bk}p\{ASCII\}} matches
any ASCII character and \code{{\bk}p\{Punct\}} for ASCII punctuation
characters.

The ASCII characters must be used with care, because they will not
have their described behavior when interpreted over all of Unicode.
For example, there are whitespaces in Unicode that don't match
\code{{\bk}s} and digits that don't match \code{{\bk}d}.

\section{Compound Character Classes}\label{section:compound-char-classes}

Character classes may be built up from single characters and/or other
character classes using set operations like union, intersection, and
negation.

The syntax for compound character classes uses brackets around a
character class expression.  The atomic character class expressions
are single characters like \code{a}, and the character class escapes
like \code{{\bk}p\{Lu\}} matches any uppercase Unicode letter character.

Character classes may be unioned, which confusingly uses a
concatenation syntax.  For instance, \code{[aeiou]} is the character
class picking out the ASCII vowels.  It is composed of the union of
character class expressions \code{a}, \code{e}, \ldots, \code{u}.  
%
\commandlinefollow{ant -Dregex="[aeiou]" -Dtext="i" regex-match}
\begin{verbatim}
Regex=|[aeiou]|    Text=|i|    Matches=true
\end{verbatim}
%
Class escapes may be used, so that \code{[{\bk}p\{Lu\}{\bk}p\{N\}]}
picks out upper case letters and numbers.

The use of range notation may be used as shorthand for unions.
For instance, \code{[0-9]} picks out the ASCII digits \charmention{0},
\charmention{1}, \ldots, \charmention{9}.  For example,
%
\commandlinefollow{ant -Dregex="[I-P]" -Dtext="J" regex-match}
\begin{verbatim}
Regex=|[I-P]|    Text=|J|    Matches=true
\end{verbatim}

Character classes may be complemented.  The syntax involves a caret,
with \code{[\^{}\codeVar{A}]} picking out the class of characters not
in class \codeVar{A}.  The expression \codeVar{A} must be either a
range or a sequence of character class primitives.  For instance,
\code{[\^{}z]} represents the class of every character other than
\charmention{z}.  
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext="z" regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|z|    Matches=false
\end{verbatim}
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext="a" regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|a|    Matches=true
\end{verbatim}
%
Unlike the usual rules governing the logical operations disjunction,
conjunction, and negation, the character class complementation
operator binds more weakly than union.  Thus \code{[\^{}aeiou]} picks
out every character that is not an ASCII vowel.

Character classes may also be intersected.  The syntax is the same as
for logical conjunction, with \code{[\codeVar{A}\&\&\codeVar{B}]}
picking out the characters that are in the classes denoted by both
\codeVar{A} and \codeVar{B}.  For instance, we could write
\code{[[a-z]\&\&[\^{}aeiou]]} to pick out all lowercase ASCII
characters other than the vowels,
%
\commandlinefollow{ant -Dregex="[[a-z]\&\&[\^{}aeiou]]" -Dtext="i" regex-match}
\begin{verbatim}
Regex=|[[a-z]&&[^aeiou]]|    Text=|i|    Matches=false
\end{verbatim}

As described in the Javadoc for \code{Pattern}, the order of
attachment for character class operations is
%
\begin{center}
\begin{tabular}{rll}
\tblhead{Order} & \tblhead{Expression} & \tblhead{Example} 
\\ \hline
1 & Literal Escape & \code{{\bk}x}
\\
2 & Grouping & \code{[...]} 
\\
3 & Range & \code{0-9}
\\
4 & Union & \code{ace}
\\
5 & Intersection & \code{a-z\&\&[\^{}aeiou]}
\end{tabular}
\end{center}
%
Thus the square brackets act like grouping parentheses for character
classes.
As mentioned earlier, within square brackets \code{union} is implicit
whereas otherwise contatenation is implicit.

Complementation must be treated separately.  Complementation
only applies to character groups or ranges, and must be closed within
brackets before being combined with union or intersection or the scope
may not be what you expect.  For instance, \code{[\^{}a[c-e]]} is
not equivalent to \code{[\^{}acde]}, but rather is equivalent to
\code{[[\^{}a][c-e]]} and can be specified this way to avoid confusion.



\section{Concatenating Regexes}

The regexes in our very first examples consisted of concatenated characters,
as we saw in \refsec{exact-match-regex} using regexes such as\code{aab}.
With a list of characters (or strings) being concatenated, the
boundary case is the concatenation of an empty list
(see \refsec{regex-empty}).

Two regular expressions \codeVar{x} and \codeVar{y} may be
concatenated to produce a compound regular expression \codeVar{xy}.
The regex \codeVar{xy} matches any string that can be decomposed into
a string that matches \codeVar{x} followed by a string that matches
\codeVar{y}.  For example, if we have a regex \code{[aeiou]} that
matches vowels and a regex \code{0-9} that matches digits, we can put
them together to produce a regex that matches a vowel followed by a
digit.
%
\commandlinefollow{ant -Dregex="[aeiou][0-9]" -Dtext="i7" regex-match}
\begin{verbatim}
Regex=|[aeiou][0-9]|    Text=|i7|    Matches=true
\end{verbatim}

Concatenation is associative, meaning that if we have three regexes
\codeVar{x}, \codeVar{y}, and \codeVar{z}, the regexes
\code{(\codeVar{x}\codeVar{y})\codeVar{z}} and
\code{\codeVar{x}(\codeVar{y}\codeVar{z})} match exactly the same set
of strings.  Because parentheses may be used for groups (see
\refsec{regex-groups}), the two regexes do not always behave exactly
the same way.  


\section{Disjunction}

If \codeVar{X} and \codeVar{Y} are regular expressions, the regular
expression \codeVar{x}\code{|}\codeVar{y} matches any string that
matches either \codeVar{X} or \codeVar{Y} (or both).  For example,
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext="ab" regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|ab|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext="cd" regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|cd|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext="bc" regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|bc|    Matches=false
\end{verbatim}
%
Concatenation takes precedence over disjunction, so that \code{ab|cd}
is read as \code{(ab)|(cd)}, not \code{a(b|c)d}.  

The order of disjunctions doesn't matter for matching (other than for
efficiency), but it matters for the find operation.  For finds,
disjunctions are evaluated left-to-right and the first match returned.
%
\commandlinefollow{ant -Dregex="ab|abc" -Dtext="abc" regex-find}
\begin{verbatim}
Found |ab| at (0,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="abc|ab" -Dtext="abc" regex-find}
\begin{verbatim}
Found |abc| at (0,3)
\end{verbatim}
%

Because complex disjunctions are executed through backtracking,
disjunctions that have to explore many branches can quickly lead to
inefficient regular expressions.  Even a regex as short as
\code{(a|b)(c|d)(e|f)} has $2^3 = 8$ possible search paths to explore.
Each disjunction doubles the size of the search space, leading to
exponential growth in the search space in the number of interacting
disjunctions.  In practice, disjunctions often fail earlier.  For
instance, if there is no match for \code{a|b}, further
disjunctions are not explored.  

\section{Parentheses for Scoping}

If \codeVar{A} is a regular expression, \code{(\codeVar{A})} is a
regular expression that matches exactly the same strings as
\codeVar{A}.  Note that parentheses come in matched pairs, and
each picks out the unique subexpression \codeVar{A} it wraps.

Parentheses play the usual role of grouping in regular expressions,
and may be used to disambiguate what would otherwise be misparsed.
For instance, the expression \code{(a|b)c} is very different than
\code{a|(bc)}, but the expressions \code{gray|grey} and
\code{gr(a|e)y} are equivalent.

Parentheses also play the role of identifying the subexpressions
they wrap.  This is covered in \refsec{regex-groups}.

\section{Greedy Quantifiers}

There are operators for optionality or multiple instances that go
under the general heading of ``greedy'' because of they match as
many times as they can.  In the next section, we consider their
``reluctant'' counterparts that do the opposite.

\subsection{Optionality}

The simplest greedy quantifier is the optionality marker.  The regex
\code{\codeVar{A}?} matches a string that matches \codeVar{A} or the
empty string.  For example,
%
\commandlinefollow{ant -Dregex="a?" -Dtext="a" regex-match}
\begin{verbatim}
Regex=|a?|    Text=|a|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="a?" -Dtext={\bk}"{\bk}" regex-match}
\begin{verbatim}
Regex=|a?|    Text=||    Matches=true
\end{verbatim}

The greediness of the basic optionality marker, which tries to match
before trying to match the empty string, is illustrated using
\code{regex-find},
%
\commandlinefollow{ant -Dregex="a?" -Dtext="aa" regex-find}
\begin{verbatim}
Found |a| at (0,1)    Found |a| at (1,2)    Found || at (2,2)
\end{verbatim}
%
The first two substrings found match \code{a} rather than
the empty string.  Only when we are at position 2, at the
end of the string, do we match the empty string because we
can no longer match \code{a}.

The greediness of optionality means that the \code{\codeVar{A}?}
behaves like the disjunction \code{(\codeVar{A}|)} of \codeVar{A} and
the empty string.  Because it is the first disjunct, a match
against \codeVar{A} is tried first.


\subsection{Kleene Star}

A regular expression \codeVar{x} may have the Kleene-star operator%
%
\footnote{Named after Stephen Kleene, who invented regular expressions
as a notation for his characterization of regular languages.}
%
applied to it to produce the regular expression \codeVar{A}\code{*}.
The regex \codeVar{A}\code{*} matches a string if the string is
composed of a sequence of zero or more matches of \codeVar{A}.  For
example, \code{[01]*} matches any sequence composed only of \code{0}
and \code{1} characters,
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext="00100100" regex-match}
\begin{verbatim}
Regex=|[01]*|    Text=|00100100|    Matches=true
\end{verbatim}
%
It will also match the empty string, but will not match a string with
any other character.

Using find, the standard Kleene-star operation is greedy in that it
consumes as much as it can during a \code{find()} operation.  For
example, consider
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext="001a0100" regex-find}
\begin{verbatim}
Found |001| at (0,3)    Found || at (3,3)    Found |0100| at (4,8)
Found || at (8,8)
\end{verbatim}
%
The first result of calling \code{find()} consumes the expression
\code{[01]} as many times as possible, consuming the first three
characters, \code{001}.  After that, the expression matches the empty
string spanning from 3 to 3.  It then starts at position 4, finding
\code{0100} and then the empty string again after that.  Luckily,
\code{find()} is implemented cleverly enough that it only returns the
empty string once.  

Kleene star may also be understood in terms of disjunction.  The
greedy Kleene star regex \code{\codeVar{A}*} behaves like the
disjunction of \code{\codeVar{A}(\codeVar{A}*)} and the empty regex.
Thus it first tries to match \codeVar{A} followed by another match of
\code{\codeVar{A}*}, and only failing that tries to match the empty
string.  For instance, the two regexes in the following patterns match
exactly the same strings.
%
\codeblock{RegexFragments.1}

Kleene star interacts with disjunction in the expected way.  For
example, matching consumes an entire string, as with
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext="abcab" regex-match}
\begin{verbatim}
Regex=|(ab|abc)*|    Text=|abcab|    Matches=true
\end{verbatim}
%
while finding returns only an initial match, 
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext="abcab" regex-find}
\begin{verbatim}
Found |ab| at (0,2)    Found || at (2,2)    Found |ab| at (3,5)
Found || at (5,5)
\end{verbatim}
%
This is a result of the greediness of the Kleene-star operator
and the evaluation order of disjunctions.  If we reorder, we 
get the whole string,
%
\commandlinefollow{ant -Dregex="(abc|ab)*" -Dtext="abcab" regex-find}
\begin{verbatim}
Found |abcab| at (0,5)    Found || at (5,5)
\end{verbatim}
%
because we first match \code{abc} against the disjunct, then continue
trying to match \code{(abc|ab)*}, which matches \code{ab}.

\subsection{Kleene Plus}

The Kleene-plus operator is like the Kleene star, but requires at
least one match.  Thus \codeVar{A}\code{+} matches a string if the
string is composed of a sequence of one or more matches of
\codeVar{A}.  The Kleene-plus operator may be defined in terms
of Kleene star and concatenation, with \code{\codeVar{A}+} behaving
just like \code{\codeVar{A}\codeVar{A}*}.  

Use Kleene plus instead
of star to remove those pesky empty string matches.  For instance, 
%
\commandlinefollow{ant -Dregex="(abc|ab)+" -Dtext="abcab" regex-find}
\begin{verbatim}
Found |abcab| at (0,5)
\end{verbatim}

\subsection{Match Count Ranges}

We can specify an exact number or a range of possible number of
matches.  The regular expression \code{\codeVar{A}\{\codeVar{m}\}}
matches any string that that may be decomposed into a sequence of
\codeVar{m} strings, each of which matches \codeVar{A}.
%
\commandlinefollow{ant -Dregex="a\{3\}" -Dtext="aaa" regex-match}
\begin{verbatim}
Regex=|a{3}|    Text=|aaa|    Matches=true
\end{verbatim}
%

There is similar notation for spans of counts.  The regex
\code{\codeVar{A}\{\codeVar{m},\codeVar{n}\}} matches any string that
may be decomposed into a sequence of between \codeVar{m} (inclusive)
and \codeVar{n} (inclusive) matches of \codeVar{A}.  The greediness
comes in because it prefers to match as many instances as possible.
For example,
%
\commandlinefollow{ant -Dregex="a\{2,3\}" -Dtext="aaaaa" regex-find}
\begin{verbatim}
Found |aaa| at (0,3)    Found |aa| at (3,5)
\end{verbatim}
%
The first result found matches the regex \code{a} three times
rather than twice.  

There is also an open-ended variant.  The regex
\code{\codeVar{A}\{\codeVar{m},\}} matches any string that can be
decomposed into \codeVar{m} or more strings each of which matches
\codeVar{A}.

\section{Reluctant Quantifiers}

There are a range of reluctant quantifiers that parallel the more
typical greedy quantifiers.  For matching, the reluctant quantifiers
behave just like their greedy counterparts, whereas for find
operations, reluctant quantifiers try to match as little as possible.

The reluctant quantifiers are written like the greedy quantifiers
followed by a question mark.  For instance, \code{\codeVar{A}*?}  is
the reluctant version of the Kleene star regex \code{\codeVar{A}*},
\code{\codeVar{A}\{m,n\}?} is the reluctant variant of the range regex
\code{\codeVar{A}\{m,n\}}, and \code{\codeVar{A}??} is the reluctant
variant of the optionality regex \code{\codeVar{A}?}.

Reluctant quantifiers may be understood by reversing all the disjuncts
in the definitions of the greedy quantifier equivalents.  For
instance, we can think of \code{\codeVar{A}??} as
\code{\codeVar{(|\codeVar{A})}} and \code{\codeVar{A}*?} as
\code{(|\codeVar{A}\codeVar{A}*?)}. 

Here we repeat some key examples of the previous section using reluctant
quantifiers.
%
\commandlinefollow{ant -Dregex="a??" -Dtext="aa" regex-find}
\begin{verbatim}
Found || at (0,0)    Found || at (1,1)    Found || at (2,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="(abc|ab)+?" -Dtext="abcab" regex-find}
\begin{verbatim}
Found |abc| at (0,3)    Found |ab| at (3,5)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="a\{2,3\}?" -Dtext="aaaaa" regex-find}
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%


\section{Possessive Quantifiers}

The third class of quantified expression is the possessive quantifier.
Possessive quantifiers will not match a fewer number of instances of
their pattern if they can match more.  Procedurally, they commit to
a match once they've made it and do not allow backtracking.

The syntax for a possessive quantifier follows the quantifier symbol
with a plus sign (\code{+}); for instance, \code{?+} is possessive
optionality and \code{*+} is greedy Kleene star.

Consider the difference between a greedy Kleene star
%
\commandlinefollow{ant -Dregex="[0-9]*1" -Dtext="1231" regex-match}
\begin{verbatim}
Regex=|[0-9]*1|    Text=|1231|    Matches=true
\end{verbatim}
%
which matches, and a possessive Kleene star,
%
\commandlinefollow{ant -Dregex="[0-9]*+1" -Dtext="1231" regex-match}
\begin{verbatim}
Regex=|[0-9]*+1|    Text=|1231|    Matches=false
\end{verbatim}
%
which does not match.  Even though \code{[0-9]*} indicates a greedy
match, it is able to back off and only match the first three
characters of the input, \code{123}.  The possessive quantifier, once
it has matched \code{1231}, does not let it go, and the overall match
fails.

\subsection{Independent Group Possessive Marker}\label{section:group-possess-marker}

If \codeVar{A} is a regex, then \code{(?>\codeVar{A})} is a regex that
matches the same thing as \codeVar{A}, but groups the first match
possessively.  That is, once \code{(?>\codeVar{A})} finds a match
for \codeVar{A}, it does not allow backtracking.   We can see this
with a pair of examples.
%
\commandlinefollow{ant -Dregex="(?>x+)xy" -Dtext="xxy" regex-match}
\begin{verbatim}
Regex=|(?>x+)xy|    Text=|xxy|    Matches=false
\end{verbatim}
%
This doesn't match, because the \code{x+} matches both
instances of \charmention{x} in the text being matched and doesn't
allow backtracking.  Contrast this with
%
\commandlinefollow{ant -Dregex="(?>x+)y" -Dtext="xxy" regex-match}
\begin{verbatim}
Regex=|(?>x+)y|    Text=|xxy|    Matches=true
\end{verbatim}

The parentheses in this construction do not count for grouping
(see \refsec{regex-groups}).


\section{Parentheses, Groups, and Capturing}\label{section:regex-groups}

Parentheses come in matched pairs, and
each picks out the unique subexpression \codeVar{A} it wraps.
The pairs of parentheses in a regular expression are numbered
from left to right, beginning with 1. 
There is an implicit pair of parentheses around the entire pattern, 
with group number 0.  
The following example shows how this numbering works:
%
\begin{verbatim}
 a(b(cd)(e))
0 1 2   3
\end{verbatim}
%
We have lined up the identifier of each parentheses group with the opening paren.
Group 1 is \code{b(cd)(e)},
group 2 is \code{cd}, and group 3 is \code{e}.  
The entire expression is group 0.

The identities of the groups are used for pulling out substring matches.
They are also used as back references in regexes (see
\refsec{regex-back-references}) and for replace operations
based on regexes (see
\refsec{regex-replace}). 

The \code{Matcher} class contains the method
\code{group(int)} which picks out the subsequence of match captured by the
specified group number.
The \code{group()} method is equivalent to \code{group(0)}.
The start and end position of a group may also be
retrieved, using \code{start(int)} and \code{end(int)}.
The methods \code{start()}, and \code{end()} 
are just shorthand for
\code{start(0)}, and \code{end(0)}.
If there hasn't been a match or the last find did not succeed, attempting to retrieve
groups or positions raises an illegal state exception.

The example class \code{RegexGroup} builds on \code{RegexMatch}
in that it takes a pattern and a string as arguments and looks for a match.
If the string matches the pattern, it prints out all capturing groups.
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexGroup.java}}
%
\codeblock{RegexGroup.1}
%
When we use this program to match the string \code{abcde} against the pattern \code{a(b(cd)(e))},
the result corresponds to our numbering above.
%
\commandlinefollow{ant -Dregex="a(b(cd)(e))" -Dtext="abcde" regex-group}
\begin{verbatim}
Group: 0 captures: |abcde| at (0,5)
Group: 1 captures: |bcde| at (1,5)
Group: 2 captures: |cd| at (2,4)
Group: 3 captures: |e| at (4,5)
\end{verbatim}
%

A typical linguistic example would be to look for the word \stringmention{Mr}
and try to get the following name.
We consider a few examples and concoct the following regex:
\code{Mr(({\bk}s({\bk}p\{Lu\}{\bk}p\{L\}*))+)}.
This regex specifies that after the \stringmention{Mr} we expect to find
a series of initials or proper names.
The innermost regex \code{({\bk}p\{Lu\}{\bk}p\{L\}*)}, group 3,
specifies an upper-case letter followed by zero or more letters.
Group 2 consists of whitespace followed by group 3.
Group 1 consists of one or more of these.
%
\commandlinefollow{ant -Dregex="Mr(({\bk}s({\bk}p\{Lu\}{\bk}p\{L\}*))+)" -Dtext="Mr~J~Smith" regex-group}
\begin{verbatim}
Group: 0 captures: |Mr J Smith| at (0,10)
Group: 1 captures: | J Smith| at (2,10)
Group: 2 captures: | Smith| at (4,10)
Group: 3 captures: |Smith| at (5,10
\end{verbatim}
%
The captured input associated with a group is always the subsequence that the group most recently matched.
Therefore, in this example, group 3 matches just the surname
and group 2 matches the surname and the whitespace immediately preceeding it.
Try running this example with the text \stringmention{Mr JJ John Jacob Jingleheimer Smith}.

This regex is relatively brittle.
A more complex regex would deal with the extra leading space, 
allow optional periods after the \stringmention{Mr} with the
appropriate escape, and also deal with periods in names.
Matching complicated patterns with regexes is a tricky business.

\subsection{References to Capturing Groups}\label{section:regex-back-references}

The regex \code{\bk\codeVar{n}}\, is a back reference to the match of
the \codeVar{n}-th capturing group before it.  We can use matching
references to find pairs of duplicate words in text.  For instance,
consider
%
\commandlinefollow{ant -Dregex="({\bk}d+).*({\bk}1)" -Dtext="10 out of 10" regex-group}
\begin{verbatim}
Group: 1 captures: |10| at (0,2)
Group: 2 captures: |10| at (10,12)
\end{verbatim}
% 
The regex \code{{\bk}1} will match whatever matched group 1.  
Group 1 is \code{({\bk}d+)} and group 2 is \code{({\bk}1)}; both
match the expression \stringmention{10}, only at different places.
The text \stringmention{9 out of 10} doesn't match.
\commandlinefollow{ant -Dregex="({\bk}d+).*({\bk}1)" -Dtext="9 out of 10" regex-group}
%
\begin{verbatim} 
Regex=|(\d+).*(\1)|
Text=|9 out of 10|
Not matched
\end{verbatim}
%
If the match index is out of bounds for the number of groups, matching
fails without raising an exception.

Capturing groups can be referenced from within the \code{Matcher.replaceAll}
method.
The sequence \code{\${n}} references the \codeVar{n}-th capturing group
in the current match.%
%
\footnote{Therefore any occurances of the character \stringmention{\$}
in the string argument to \code{replaceAll} must be escaped.}
%
\codeblock{RegexFragments.4}
%
In the linguistic example above, this could be used to change the text
\stringmention{Mr J J Smith} to \stringmention{Smith}.

\subsection{Named References}\label{section:regex-named-references}

As of Java 7,
a capturing group can be assigned a name
so that it can be back-referenced later by name instead of by number.
The regex \code{(?<NAME>\codeVar{A})} specifies a capturing group with name \codeVar{NAME}
that matches regex \codeVar{A}.
Group names must start with a letter and may only contain ASCII letters and digits.

The regex \code{{\bk}{\bk}k<NAME>} can be used to reference this group within the regex.
The sequence \code{\$\{NAME\}} references the named group in the \code{replaceAll} method.


\section{Non-Capturing Regexes}\label{section:non-capturing-regex}

Some regexes match virtual positions in an input without consuming any
text themselves.  
Boundary matchers match specific sequences, but do not consume any
input themselves.  
Non-capturing groups are enclosed by parenthesis but these parentheses
aren't counted by the \code{Matcher.groupCount} method, nor can they
be referenced.


\subsection{Begin- and End-of-Line Matchers}

The caret (\code{\^{}}) is a regular expression that matches the end
of a line and the dollar sign (\code{\$}) a regular expression
matching the beginning of a line.  For example, 
%
\commandlinefollow{ant -Dregex="\^{}abc\$" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|^abc$|    Text=|abc|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab\$c" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|ab$c|    Text=|abc|    Matches=false
\end{verbatim}
%
The begin- and end-of-line regexes do not themselves consume any
characters.

These begin-of-line and end-of-line regexes do not match new lines
inside of strings unless the \code{MULTILINE} flag is set (see
\refsec{pattern-modes}).  By default, these regexes match new-line
sequences for any platform (Unix, Macintosh, or Windows) and many more
(see the table below).  If
the
\code{UNIX\_LINES} flag is set, they only match Unix newlines (see
\refsec{pattern-modes}).

\subsubsection{Line Terminators and Unix Lines}\label{section:regex-lines}

\begin{center}
\begin{tabular}{lll}
\tblhead{Code Point(s)} & \tblhead{Description} & \tblhead{Java} 
\\ \hline
\unicode{000A} & \unicodedesc{line feed} & \code{{\bk}n}
\\
\unicode{000D} & \unicodedesc{carriage return} & \code{{\bk}r}
\\
\unicode{000D}, \unicode{000A} & \unicodedesc{carriage return},
\unicodedesc{line feed} & \code{{\bk}r{\bk}n}
\\
\unicode{0085} & \unicodedesc{next line} & \code{{\bk}u0085} 
\\
\unicode{2028} & \unicodedesc{line separator} & \code{{\bk}u2028}
\\
\unicode{2029} & \unicodedesc{paragraph separator} & \code{{\bk}u2029}
\end{tabular}
\end{center}


\subsection{Begin and End of Input}

Because begin-of-line and end-of-line have variable behavior, there
are regexes \code{{\bk}A} for the beginning of the input and
\code{{\bk}z} for the end of the input.  These will match the begin
and end of the input no matter what the match mode is.  For
instance,
%
\commandlinefollow{ant -Dregex="{\bk}A(mnp){\bk}z" -Dtext="mnp" regex-group}
\begin{verbatim}
regex=|\A(mnp)\z|    text=|mnp|
Group  0=|mnp| at (0,3)    Group  1=|mnp| at (0,3)
\end{verbatim}
%
Here we use the demp program \code{RegexGroup}:
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexGroup.java}}
%
which shows the positions at which the grouping parentheses match.
We go into more detail on grouping in \refsec{regex-groups}.

\subsection{Word Boundaries}

The regex \code{{\bk}b} matches a word boundary and \code{{\bk}B} a
non-word boundary, both without consuming any input.  Word boundaries
are the usual punctuation and spaces and the begin and end of input.
For example,
%
\commandlinefollow{ant -Dregex="{\bk}b{\bk}w+{\bk}b" -Dtext="John ran quickly." regex-find}
\begin{verbatim}
Found |John| at (0,4)        Found |ran| at (5,8)    
Found |quickly| at (9,16)
\end{verbatim}

\subsection{Non-Capturing Groups}

Non-capturing regexes are enclosed by parenthesis 
but the parentheses aren't counted as capturing groups. 
In all cases the opening parenthesis is immediately followed by a question mark.
Note that named capturing groups (see \refsec{regex-named-references}) begin with
a question mark; all other groups that begin with a question mark are non-capturing.
The regex \code{(?>\codeVar{A})} is one example,
(see \refsec{group-possess-marker}).

If \codeVar{X}
is a regex, then \code{(?:\codeVar{X})} matches the same things as
\codeVar{X}, but the parentheses are not treated as capturing and so
they aren't counted by the method \code{groupCount()}.
To see this, we return to the run the \code{match-group} example in \refsec{regex-groups}.
We change the expression changing \code{a(b(cd)(e))} to
to \code{a(b(?:cd)(e))} to
%
\commandlinefollow{ant -Dregex="a(b(?:cd)(e))" -Dtext="abcde" regex-group}
\begin{verbatim}
Regex=|a(b(?:cd)(e))|
Text=|abcde|
Group: 0 captures: |abcde| at (0,5)
Group: 1 captures: |bcde| at (1,5)
Group: 2 captures: |e| at (4,5)
\end{verbatim}
%

\subsection{Positive and Negative Lookahead}

Often you want to match something only if it occurs in a given
context.  If \codeVar{A} is a regex, then \code{(?=\codeVar{A})} is
the positive lookahead and \code{(?!\codeVar{A})} the negative
lookahead regular expression.  These match a context that either
matches or doesn't match the specified regular expression.  They
must be used following other regular expressions.

One reason to use lookahead is that further finds can match
the material that the lookahead matched; this material is beyond
the offset returned by the \code{Matcher.end} method.
The example class \code{RegexFindVerbose} shows how a matcher consumes
the input string.
%
\displ{\filepath{src/regex/src/com/lingpipe/book/regex/RegexFindVerbose.java}}
%
\codeblock{RegexFindVerbose.1}
%
We use the methods \code{Matcher.appendReplacement} and \code{appendTail}
(see \refsec{regex-replaceAll}) to get the input string from the
matcher, using a \code{StringBuffer} for intermediate storage.
We reset the length of the buffer to zero before the calling the
\code{appendTail} method, so that the only text we collect is the
text that has not yet been consumed by the matcher.

If we want to find instances of numbers preceding periods, we specify
%
\commandlinefollow{ant -Dregex="{\bk}d+(?={\bk}.)" -Dtext="12.3 45.6" regex-find-verbose}
\begin{verbatim}
Regex=|\d+(?=\.)|
Text=|12.3 45.6|
matched: |12| at (0,2)
remaining: |.3 45.6|
matched: |45| at (5,7)
remaining: |.6|
\end{verbatim}
%
How does this work?
Positive lookahead finds the period.  The matcher has only \emph{looked} ahead.
If we change this regex to \code{\bk}d+({\bk}.) (without positive lookahead),
we see that the match includes the period.
%
\commandlinefollow{ant -Dregex="{\bk}d+({\bk}.)" -Dtext="12.3 45.6" regex-find-verbose}
\begin{verbatim}
Regex=|\d+(\.)|
Text=|12.3 45.6|
matched: |12.| at (0,3)
remaining: |3 45.6|
matched: |45.| at (5,8)
remaining: |6|
\end{verbatim}

To find numbers not preceding periods, we could use:%
%
\footnote{Note the use of single quotes in order to prevent the shell from expanding the character '\code{!}' in the negative lookahead regular expression.}
%
\commandlinefollow{ant -Dregex='{\bk}d+(?!{\bk}.)' -Dtext="12.3" regex-find}
%
\begin{verbatim}
Found |1| at (0,1)    Found |3| at (3,4)
\end{verbatim}

\subsection{Positive and Negative Lookbehind}\label{section:regex-lookbehind}

There are backward-facing variants of the positive and negative
lookahead constructs, \code{(?<=\codeVar{X})} and 
\code{(?<!\codeVar{X})}.  These are more limited in that the
regular expression \codeVar{X} must expand to a simple sequence, and
thus may not contain the Kleene-star or Kleene-plus operations.

For example, the following example finds sequences of digits that do
not follow periods or digits.
%
\commandlinefollow{ant -Dregex='(?<![{\bk}.{\bk}d+]){\bk}d+'-Dtext="12.3 .45 67" regex-find}
\begin{verbatim} 
Found |12| at (0,2)
Found |67| at (9,11)
\end{verbatim}
%
In this example, the regular expression specifies a compound character class
which consists of either a single period or any sequence of digits.
The greedy quantifier \code{+} attaches to the character class \code{{\bk}d}.

\section{Pattern Compilation}\label{section:pattern-compile}

\code{Pattern} objects are immutable and therefore thread-safe.
Since all of the state of the matching of a regular expression
against a string resides in the \code{Matcher} object,
many matchers can and should share a compiled \code{Pattern}
since this reuse has the potential to improve program efficiency.

\subsection{Pattern Match Flags}\label{section:pattern-modes}

There are a set of flags, all represented as static integer constants
in \code{Pattern}, which may be supplied to the pattern compiler
factory method \code{Pattern.compile(String,int)} to control the
matching behavior of the compiled pattern.  
%
\begin{center}
\begin{tabular}{lrp{0.55\textwidth}}
\tblhead{Constant} & \tblhead{Value} & \tblhead{Description} 
\\ \hline { } \\[-6pt]
\code{DOTALL}
& 32
& Allows the wild card (\code{.}) expression to match any
character, including line terminators.  If this mode is not
set, the wild card does not match line terminators.
\\[4pt]
\code{MULTILINE}
& 8
& Allows the begin-of-line (\code{\^{}}) and end-of-line (\code{\$}) to
match internal line terminators.  If this is not set, they only
match before the first and after the last character.  The full Java
notion of newline is used unless the flag \code{UNIX\_LINES} is also set.
\\[4pt]
\code{UNIX\_LINES}
& 1
& Treat newlines as in Unix, with a single \unicode{000A},
\unicodedesc{line feed}, Java string escape \code{{\bk}n},
representing a new line.  This affects the behavior of wildcard
(\code{.}) and begin-of-line (\code{\^{}}) and end-of-line 
(\code{\$}) expressions. 
\\[4pt] 
\code{CASE\_INSENSITIVE} 
& 2
& Matching is insensitive to case.  Case folding is only for
the ASCII charset (\unicode{0000} to \unicode{007F}) unless
the flag \code{UNICODE\_CASE} is also set, which uses the Unicode
definitions of case folding.
\\[4pt]
\code{UNICODE\_CASE}
& 64
& If this flag and the \code{CASE\_INSENSITIVE} flag is set,
matching ignores case distinctions as defined by Unicode
case folding rules.
\\[4pt]
\code{CANON\_EQ} 
& 128
& Matches are based on canonical equivalence in Unicode 
(see \refsec{unicode-normalization-forms}).
\\[4pt]
\code{LITERAL} 
& 16
& Treats the pattern as a literal \ie{no parsing}.
\\[4pt]
\code{COMMENTS}
& 4
& Allows comments in patterns and causes pattern-internal whitespace to be ignored.
\end{tabular}
\end{center}

The flags are defined using a bit-mask pattern whereby multiple
flags are set by taking their bitwise-or value.%
%
\footnote{Although bitwise or looks like addition for flags like
these with only one bit on, it breaks down when you try to set
flags twice.  Thus \code{DOTALL~+~MULTILINE} evaluates to the
same thing as \code{DOTALL~|~MULTINE}, \code{DOTALL~+~DOTALL}
evaluates to the same thing as \code{UNICODE\_CASE}, whereas
\code{DOTALL~|~DOTALL} evaluates to the same thing as \code{DOTALL}.}
%
For instance,
the expression \code{DOTALL~|~MULTILINE} allows the wildcard
to match anything and the line-terminator expressions to match
internal newlines.  More than two flags may be set this way,
so we could further restrict to Unix newlines with
\code{DOTALL~|~MULTILINE~|~UNIX\_LINES}.  

Even stronger matching than canonical equivalence with unicode case
folding can be achieved by writing the regular expression using
compatibility normal forms and using the ICU package to perform a
compatibility decomposition on the input (see
\refsec{unicode-normalization-forms}).


\subsection{Pattern Construction Exceptions}

Attempting to compile a regular expression with a syntax error raises
a runtime exception, \code{PatternSyntaxException} from the
\code{java.util.regex} package.  The parser tries to provide a helpful
warning message.  For instance, here's what we see if we inadvertently
add a right parenthesis to our regex.
%
\commandlinefollow{ant -Dregex="aa)" -Dtext="aaab" regex-find}
%
\begin{verbatim}
Exception in thread "main" 
    java.util.regex.PatternSyntaxException:  
    Unmatched closing ')' near index 1
\end{verbatim}



\section{Thread Safety, Serialization, and Reuse}

\subsection{Thread Safety}

Because instances of \code{Pattern} are immutable, it is safe to use
them concurrently in multiple threads.  Because instances of
\code{Matcher} contain the state of the current match, it is not
thread safe to use matchers concurrently without synchronization.

\subsection{Serialization}

Patterns are serializable.  The string representing the pattern and
the compilation flags are stored and the version read back in is an
instance of \code{Pattern} behaving just like the original.  Often
patterns do not need to be serialized because they're effectively
singletons \ie{constants}.

\subsection{Reusing Matchers}

Matchers may be reused, although the typical usage pattern
is to construct them for a text, use them once, then discard them.
When reusing matchers, the \code{reset()} method is called on a
matcher to reset it to behave as if it had just been constructed with
its given pattern and character sequence.
The character sequence may
be changed.  The pattern may also be changed on the fly, without
changing the current position.  This may be useful if you alternately
match first one pattern then another.

\section{String Methods that Use Regexes}

There are many utility methods in the \code{String} class that
are based on regular expressions.   

The method \code{matches(String)} returns \code{true} if the string
matches the regex specified by the argument. 
The call \code{str.matches(regex)} yields exactly the same result as the expression
\code{Pattern.matches(regex, str).}

The method \code{replaceAll(String,String)} takes as arguments
a string representing a regex and a replacement string.
It returns the result
of replacing all the substrings in the string matching the regex
with the replacement string.
The call \code{str.replaceAll(regex, repl)} yields exactly the same result as the expression
\code{Pattern.compile(regex).matcher(str).replaceAll(repl)}.
Therefore the replacement may contain references to match groups.%
%
\footnote{ 
If the replacement string contains backslashes (\bk) and
dollar signs (\$) that are intended to be treated as literal
replacements they must be quoted.  Therefore to replace all forward
slashes in \code{String  str} with a backslash we write
\code{str.replaceAll("/","{\bk}{\bk}{\bk}{\bk}")}.
}
%
There is also a corresponding \code{replaceFirst(String,String)} method.
The call \code{str.replaceFirst(regex, repl)} yields exactly the same result as the expression
\code{Pattern.compile(regex).matcher(str).replaceFirst(repl)}.

One of the more useful utilities is \code{split(String)}, which splits
a string around the matches of a regular expression, returning an
array as a result.  For example,
\code{"foo12bar177baz\".split({\bk}d+)} splits on digits, returning
the string array \code{\{~"foo", "bar", "baz"~\}}.  Note that the
matching numbers are removed.

The method \code{split(String,int)}
takes a second \code{int} parameter that limits the number of
times the pattern is applied and therefore controls the length of the
resulting array.  If the limit \code{n} is greater than zero then
the pattern will be applied at most \code{n - 1} times, the array's length
will be no greater than \code{n}, and the array's last entry will contain all
input beyond the last matched delimiter. If \code{n} is less than zero
then the pattern will be applied as many times as possible and the array can
have any length. If \code{n} is zero then the pattern will be applied as many
times as possible, the array can have any length, and trailing empty
strings will be discarded.  

The method \code{split(String)} is shorthand for for \code{split(String,0)}.
The call \code{str.split(regex,n)} yields the same result as the expression
\code{Pattern.compile(regex).split(str,n)}. 
Therefore the call \code{str.split(regex)} 
is equivalent to 
\code{Pattern.compile(regex).split(str,0)}.

In the OpenJDK reference implementation of the \code{String} class,
the methods \code{matches}, \code{replaceAll}, \code{replaceFirst},
and \code{split} all call the corresponding methods in the pattern class
directly.
Here is the implementation of the one-arg and two-arg \code{String.split} methods
%
\codeblock{RegexFragments.3}
%
Each call to the \code{String.split} requires creating and compiling
a new \code{Pattern} object as well as a \code{Matcher}.





\section{Regexes for Ad-Hoc Parsing}\label{section:adhoc-parser}

It is tempting to use Regexes to process files that have SGML-style markup.
Examples.


A nice feature of replace operations is that they may reference
pieces of the match by group number and use them in the replacement.
An occurrence of \code{\$\codeVar{n}} in the replacement string
represents whatever matched group \codeVar{n} in the match.

For instance, we can extract the version number from a jar and
redisplay it using
%
\commandlinefollow{ant -Dregex="({\bk}w+){\bk}-([{\bk}d{\bk}.]+){\bk}.jar" -Dreplacement='{\bk}\$1.jar~v{\bk}\$2'
 -Dtext="foo-7.6.jar" regex-replace}

\begin{verbatim}
regex=|(\w+)\-([\d\.]+)\.jar|    replacement=|$1.jar v$2|
text=|foo-7.6.jar|               result=|foo.jar v7.6|
\end{verbatim}
%
Note that we had to escape the literal hyphen and period characters in
the regex.  Furthermore, we had to use single quotes and escape the group
reference \code{\$\codeVar{n}} in order to prevent the shell from interpreting
the references.%
\footnote{This is necessary for the Mac OS X Bash shell interpreter.}
%
The class \code{{\bk}w} is for word characters, which are
alphanumerics and the underscore.  The example regexes are very
fragile, and it is quite difficult to write more robust regexes.













