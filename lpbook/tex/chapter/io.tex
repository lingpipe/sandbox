\chapter{Input and Output}\label{chap:io}

\firstchar{J}ava provides a rich array of classes for dealing with
input and output.  At the basic level, input and output streams
provide a means to transfer data consisting of a sequence of bytes.
Data may be transferred among memory with memory-backed streams, the
file system via file streams or memory mapped files, the terminal via
standard input and output streams, and remote servers via sockets.
Stream filters may be put in place to compress or decompress data.
Streams that block awaiting input or output may be dealt with in
threads.

Bytes may encode anything, but we are particularly interested in the
case of natural language text data, with or without document
structure.  To support streams of \code{char} values, Java provides
\code{char} streams as byte streams.  In order to crete a character
stream from byte stream, the character encoding must be known.

We are also interested in sequences of bytes that encode Java objects
through serialization.  We use serialized objects to represent models
and their components, such as tokenizers.  


\section{URIs, URLs and URNs}\label{section:uri-url-urn}

A uniform resource identifier (URI) picks out something on the web by
name.  This is a very general notion, but we will only need a few
instances in this book.  There are two (overlapping) subtypes of URIs,
based on function.

A uniform resource name (URN) is a URI that provides a name for
something on the web, but may not say how or where to get it.  A
typical instance of a URN is the Digital Object Identifier (DOI)
system, which is becoming more and more widely used to identify text
resources such as journal articles.  For example, the DOI
\code{doi:10.1016/j.jbi.2003.10.001} picks out a paper on which
my wife was a co-author.  An alternative URN for the same paper is
\code{PMID:15016385}, which uses the PubMed identifier (PMID) for
the paper.  

A uniform resource locator (URL) provides a means of locating (a
concrete instance of) an item on the web.  A URL indicates how to get
something by providing a scheme name, such as \code{file://} for files
or \code{http://} for the hypertext transport protocol (HTTP).  For
example, the URL
\code{http://dx.doi.org/10.1016/j.jbi.2003.10.001} is for the same
paper as above, but specifies a web protocol, HTTP, and host,
\code{dx.doi.org} from which to fetch the resource.  There may be
many URLs that point to the same object.  For instance,
\code{http://linkinghub.elsevier.com/retrieve/pii/S1532046403001126}
is a URL for the same paper, which links to the publisher's site.


\section{Files}

Java provides the class \code{File} in the \code{java.io} package for
representing files and directories on the local file system.
Underlyingly, an instance of \code{File} is nothing more than a string
representing a path coupled with a convenient set of utility methods,
some of which access the underlying file system.  

\subsection{Relative vs.\ Absolute Paths}

Files may be either relative or absolute.  An absolute path name
provides a full description of where to find a file on the system in
question.  A relative path picks out a file or directory starting from
a root directory (the form of which will be operating system
specific).  Relative paths may pick out different resources in
different situations depending on the base directory.

The static method \code{File.listRoots()} provides an array of all of
the available root directories.  We wrote a simple demo in the
class \code{ListRoots}, the heart of which is
%
\codeblock{ListRoots.1}
%
Running it on my Windows machine returns
%
\commandlinefollow{ant list-roots}
\begin{verbatim}
Root Directories
     C:\
     E:\
\end{verbatim}
%
The root directories \code{C:\bk} and \code{E:\bk} correspond to my
two drives, but they could also correspond to partitions of a single
drive or a redundant array of independent disks (RAID), or even a
section of memory acting like a disk drive.

\subsubsection{Root of Relative Paths}

In Java, relative paths are interpreted relative to the directory from
which Java was called.  The same goes for Ant, except when a \code{basedir}
attribute is set on the top-level \code{project} element.  

A consequence of this behavior is that the empty string (\code{""}) is
a path that picks out the directory from which Java was called.


\subsection{Windows vs.\ UNIX File Conventions}

Due to the differing setup of the operating systems, \code{File}
objects behave differently on different platforms.  In all cases, they
respect the conventions of the file system on which they are run, but
it requires some care to create portable code or Ant tasks that involve
files.

On either Windows or UNIX, files are organized hierarchically into
directories under one or more root directories.  Each file other
than one of the root directories has a parent directory.  The most
prominent difference between the two operating system flavors is
that Windows uses a backslash (\code{\bk}), whereas UNIX uses
a forward slash (\code{/}) to separate directories and file names
in a path.

In Unix, there is a single root directory for the file system, and
absolute path names will start with a forward slash (\code{/}).  

In Windows, there may be more than one root directory.  Each root
directory is written as a drive letter followed by a colon-backslash
(\code{:\bk}), as in \code{C:\bk} for the root directory on the drive
named \code{C}.  

Windows also allows (UNC) network paths, which begin with two
backslashes (\code{\bk\bk}) followed by the name of the computer
or device on the network.  For instance, \code{{\bk\bk}MONTAGUE}
is the root of the shared files on the network computer named
\code{MONTAGUE}.  Each networked Windows computer makes visible its 
top-level shared files.  

The biggest difference is that in Windows, file names are not case
sensitive.  Thus \code{FOO}, \code{foo}, and \code{Foo} will all pick
out the same file.  


\subsection{Constructing a \code{File}}

There are four \code{File} constructors.  The simplest,
\code{File(String)}, simply takes a path name to construct
a file object.  The string may be anything, but separator characters
will be parsed and normalized.

Conveniently, Java lets you use either forward (Unix)
or backward (Windows) slashes interchangeably, as does Ant.  Thus in
Windows, I can use Unix-style forward slashes with the same effect as
backward slashes.  For example, \code{new File("c:/foo")}, constructs
the same object as \code{new File("c:{\bk}foo")}.  

There are also two-argument constructors taking a parent directory and
a file name.  The parent may be specified as a string using the constructor
\code{File(String,String)} or as a file itself, using the constructor
\code{File(File,String)}.

\subsubsection{URI/URL to File Conversion}

There is a fourth \code{File} constructor that takes a uniform
resource identifier (URI) argument, \code{File(URI)} (see
\refsec{uri-url-urn} for more information on URIs and URLs).  The
\code{URI} class is in the \code{java.net} package, which comes
standard with Java.

URIs for files have the form
\code{file://}\codeVar{host}\code{/}\codeVar{path}, where the
(optional) \codeVar{host} picks out a domain name and \codeVar{path} a
file path.  If the \codeVar{host} is not specified, the form devolves
to \code{file:///}\codeVar{path}, and the host is assumed to be the
the so-called localhost, the machine on which Java is running.

It is also possible to convert an instance of \code{File} to a URI,
using the method \code{toURI()} in \code{File}.  

It is also possible to get a uniform resource locator (URL) from a
file, by first converting to a URI and then calling the \code{URI}
method \code{toURL()}, which returns an instance of \code{URL}, also
in \code{java.net}.



\subsection{Getting a File's Canonical Path}

The method \code{getCanonicalFile()} returns a \code{File} based on an
absolute path with a conventionalized name.  For instance, if I happen
to be running in directory \code{c:{\bk}lpb} (on Windows), then the
following two expressions return equivalent files
%
\begin{verbatim}
new File("c:\lpb\Foo").getCanonicalPath()
\end{verbatim}
%
%
\begin{verbatim}
new File("foo").getCanonicalPath();
\end{verbatim}
%
Note that this is not truly a unique normal form.  The resulting files
will have different capitalizations for \code{foo} in this case, but
will be equivalent running under Windows.


\subsection{Comparison, Equality, and Hash Codes}

Equality of \code{File} objects is based on the underlying platform's
notion of equality.  For instance, on Windows, a file created with
\code{new File("Foo")} creates a file that is equal to \code{new
File("foo")}.  For better or worse, this comparison is based on the
platform's convention for file comparison, not by constructing a
canonical path and comparing that.  For instance, if I happen to
be running from directory \code{c:{\bk}lpb}, then 
\code{new File("foo")} is not equal to 
\code{c:{\bk}lpb{\bk}foo}, even though their canonical paths are
the same.




\section{I/O Exceptions}

Almost all of the I/O operations are declared to throw
\code{IOException}, a checked exception in the \code{java.io} package.
Like all exceptions, I/O exceptions should not be ignored.  In most
cases, methods should simply pass on exceptions raised by methods they
call.  Thus most methods using I/O operations will themselves be
declared to throw \code{IOException}.  

At some point, a method will have to step up and do something with an
exception.  In a server, this may mean logging an error and continuing
on.  In a short-lived command-line program, it may mean terminating
the program and printing an informative error message.  

It is important to clean up system resources in a long-running
program.  Thus it is not uncommon to see code in a \code{try} with a
\code{finally} block to clean up even if an I/O exception is raised.


\section{Closing Streams}\label{section:io-closeable}

Because most streams impose local or system overhead on open I/O
streams, it is good practice to close a stream as soon as you are done
with it.  Conveniently, all the streams implement the handy
\code{Closeable} interface in the package \code{java.io}.  The
\code{Closeable} interface specifies a single method, \code{close()},
which closes a stream and releases any resources it may be
maintaining.  

Care must be taken in closing streams, as the \code{close()} method
itself may throw an \code{IOException}.  Furthermore, if the stream
wasn't successfully created, the variable to which it was being
assigned may be null.

The typical idiom for closing a \code{Closeable} may be illustrated
with an input stream
%
\begin{verbatim}
InputStream in = null;
try {
    in = new FileInputStream(file);
    ...
} finally {
    if (in != null) {
        in.close();
    }
}
\end{verbatim}
%
Sometimes, the close method itself is wrapped to suppress
warnings, as in
%
\begin{verbatim}
try {
    in.close();
} catch (IOException e) {
    /* ignore exception */
}
\end{verbatim}
%
Note that even if the close method is wrapped, the operations in the
try block may throw I/O exceptions.  To remove these, I/O exceptions
may be caught in a block parallel to the \code{try} and
\code{finally}.

\subsubsection{LingPipe Close Utility}

If a sequence of streams need to be closed, things get ugly quickly.
LingPipe provides a utility method \code{Streams.close(Closeable)} in
\code{com.aliasi.util} that tests for null and swallows I/O exceptions
for close operations.  Basically, it's defined as follows.
%
\begin{verbatim}
static void close(Closeable c) {
    if (c == null) return;
    try {
        c.close();
    } catch (IOException e) {
        /* ignore exception */
    }
}
\end{verbatim}
%
If you need to log stream closing exceptions, a similar method may
be implemented with logging in the catch operation and a message to
pass as an argument in the case of errors.


\section{Input Streams}

The abstract class \code{InputStream} in \code{java.io} provides the
basic operations available to all byte input streams.  Concrete
input streams may be constructed in many ways, but they are all closed
through the \code{Closeable} interface.

\subsection{Single Byte Reads}

A concrete extension of the \code{InputStream} class need only
implement the top-level \code{read()} method.  The \code{read()}
method uses the C programming language pattern of returning an integer
representing an unsigned byte value between 0 (inclusive) and 255
(inclusive) as the value read, or -1 if the end of stream has been
reached.

\subsection{Byte Array Reads}

It is usually too inefficient to access data one byte at a time.
Instead, it is usually accessed in blocks through an array.  The
\code{read(byte[])} method reads data into the specified byte array
and returns the number of bytes that have been read.  If the return
value is -1, the end of the input stream has been reached.  There is a
similar method that reads into a slice of an array given an offset
and length.

\subsection{Available Bytes}

The method \code{available()} returns an integer representing the
number of bytes available for reading without blocking.  This is not
the same as the number of bytes available.  For one thing, streams may
represent terabytes of data, and \code{available()} only returns an
integer.  More importantly, some streams may block waiting for more
input.  For instance, the standard input (see \refsec{io-stdin-stdout} may
block while waiting for user input and show no avaialable bytes, even
if bytes may later become available.  

Because no bytes may be available without blocking, it's possible for
the block read method to return after reading no bytes.  This does not
mean there won't be more bytes to read later.  The \code{read()}
methods will return -1 when there are truly no more bytes to be read.

\subsection{Mark and Reset}

The method \code{markSupported()} returns \code{true} for markable
input streams.  If a stream is markable, calling \code{mark()} sets
the mark at the current position in the stream.  A later call to
\code{reset()} resets the stream back to the marked position.


\section{Output Streams}

The \code{OutputStream} abstract class in the package \code{java.io}
provides a general interface for writing bytes.  It is thus the
complement to \code{InputStream}.  Output streams implement the
\code{Closeable} interface, and should be closed in the same way
as other closeable objects (see \refsec{io-closeable}).

\code{OutputStream} itself implements the array writers in terms of
single byte writes, with the close and flush operations doing nothing.
Subclasses override some or all of these methods for additional
functionality or increased efficiency.


\subsection{Single Byte Writes}

A single abstract method needs to be implemented by concrete
subclasses, \code{write(int)}, which writes a byte in unsigned
notation to the output stream.  The low-order byte in the integer is
written and the three high-order bytes are simply ignored (see
\refsec{java-bytes} for more on the byte organization of integers).
Thus the value should be an unsigned representation of a byte between
0 (inclusive) and 255 (inclusive).

\subsection{Byte Array Writes}

Arrays of bytes may be written using the method \code{write(byte[])},
and a slice variant taking a byte array with a start position and
length.

The behavior is slightly different than for reads.  When a write
method returns, all of the bytes in the array (or specified slice
thereof) will have been written.  Thus it is not uncommon for array
writes to block if they need to wait for a resource such as a network,
file system, or user console input.

\subsection{Flushing Writes}

The method \code{flush()} writes any bytes that may be buffered
to their final destination.  As noted in the documentation, the
operating system may provide further buffering, for instance to
the network or to disk operations.  

The \code{OutputStream} class is defined to implement
\code{Flushable}, the interface in \code{java.io} for flushable
objects.  Like the general \code{close} method from the
\code{Closeable} interface, it may raise an \code{IOException}.

Most streams call the \code{flush()} method from their \code{close()}
method so that no data is left in the buffer as a result of closing
an object.


\section{File Input and Output Streams}



\section{Standard Input and Output}\label{section:io-stdin-stdout}

Java provides two streams corresponding to the Unix notion of standard
input and standard output.






