\chapter{Rendering Text}\label{chap:render}

\firstchar{W}hen software fails to render text correctly
pinpointing the source of error can be surprisingly difficult.
If the program outputs a series of random glyphs or a string of
question marks or fuzzy boxes, is this due to program error,
improper environment configuration, or is the system unable to
display the text due to missing fonts?

The example programs for this chapter are in the code directory:
%
\displ{\filepath{src/diags/src/com/lingpipe/book/diags}}

\section{Validating and Verifying the Data}

The first step in troubleshooting text that fails to render correctly
is to verify that the text itself is well-formed.
The example class ValidateUtf16 (see \refsec{valid-utf16})
checks that a \code{CharSequence}
consists of a valid sequence of UTF-16 byte pairs.

The next step is to examine the actual text.
The example class  \code{ByteToString} (see \refsec{example-conversions})
contains the method \code{dumpString(String)} 
which displays the hex value of the chars in a string. 
%
\codeblock{ByteToString.2}
%
Since hex codes consist of ASCII characters, they can always  
be displayed in a file viewer or terminal window.  




Once we have verified that the data is good data, we can
troubleshoot the rendering process itself.

\section{Text in the Unix Shell}

Programs run from the command line interact with the Unix shell.
We have modified the \code{HelloWorld.java} example from \refchap{getting-started}
so that it prints out the Japanese equivalent of ``Hello World.''%
%
\footnote{The unicode characters for Japanese are taken from
O'Reilly's \title{Java Servlet Programming}, example 12-7.}
%
\codeblock{HelloWorldJp.1}
%

screenshots running on Mac OS X terminal app
and running on Windows inside the cygwin terminal
make terminal windows small enough so that we can take screenshot
of entire window.

\code{System.out} is a \code{java.io.PrintStream} (see \refsec{io-printstream-format}).
The call to the \code{println(String)} method converts the string argument into 
a stream of bytes that are written to the shell's standard output stream \code{stdout}.
The terminal program in which the shell is running maps 
these bytes to characters according to its character encoding.
The operating system uses sets of installed fonts to display these characters.
Failure can occur at each step
\begin{enumerate}
\item The string argument to \code{System.out.println} may contain characters which 
either malformed or unmappable outside of the platform's default character encoding.
These will be replaced by the contents of the replacement byte array.
The initial replacement byte array value is \code{\{ (byte)'?'\}}.
\item The terminal program may have the wrong character encoding specified.
\item The OS may be missing the font for one or more characters.
If the font is missing or a character isn't defined for the specified font,
then the missing character glyph is displayed instead.
\end{enumerate}

\subsection{Default Charset of the JVM}

Every instance of the Java virtual machine has a default charset,
which may or may not be one of the standard charsets. The default
charset is determined during virtual-machine startup and typically
depends upon the locale and charset being used by the underlying
operating system.
The JVM stores this information in the Java environment variable named \code{file.encoding}.
The demo class \code{GetDefaultEncoding} 
calls \code{System.getProperty(String)} to inspect this variable.
%
\codeblock{GetDefaultEncoding.1}
%
The ant task \code{get-encoding} compiles and runs this program.
On Mac running OS X the encoding is \code{US-ASCII}
while on Windows running XP the output is \code{cp1257}.

\subsection{Setting the Terminal's Character Encoding}

The terminal program may have the wrong character encoding specified.
These must be configured using controls on the application itself.
On the Mac Terminal.app the character encoding control is reached from the
Preferences/Settings/Advanced panel.



We apply these perscriptions to troubleshoot \code{HelloWorldJp}.
To compile the jarfile and then run the program
we first move into the
the subdirectory \code{/src/intro},
then create a jarfile with Ant,
and finally invoke the java executible
%
\commandlinefollow{cd \$BOOK/src/intro}
\commandlinefollow{ant jar}
\commandlinefollow{java -cp build/intro-4.0.jar com.lingpipe.book.intro.HelloWorldJp}
%
\begin{verbatim} 
?????
\end{verbatim}
%




\section{Text in a Web Browser}


\section{Multi-Lingual Hello World Example}\label{section:ant-console-config-utf8}

We are always interacting with our program via at least one intermediate program.
We are interacting with the Unix shell when we run programs from the command line,
either indirectly via Ant or directly via the \code{java} command.
Our demo programs send a stream of bytes to the Unix virtual devices
\code{stdout} and \code{stderr}. 
The shell maps these bytes to characters.
This mapping is determined by the \stringmention{character encoding} of the shell.
The operating system uses sets of installed fonts to display these characters.
If the font is missing or a character isn't defined for the specified font,
then the missing character glyph is displayed instead.

In order to make sure that the shell console display and Ant are
configured to use UTF-8 as the default character encoding, we have written
a simple test program called \code{Toast.java} that prints toasts in many
languages to standard output.
In later chapters we cover the techniques used in this program.
For now we'll just use this program to see if
Ant is sending UTF-8 output to the terminal window and if the
terminal is expecting to get UTF-8 encoded data.
\commandlinefollow{ant make-toast}
\begin{verbatim} 
Before we drink, we say a toast 
in English: cheers  
in French:  santé
in Norwegian: skål
...
\end{verbatim}
Executing this ant task from the command line will result in a mix of
English, French, Norwegian, Russian, Japanese, and Korean characters
printed on standard out.

If the output instead consists of a mix of english characters and question marks
then the Ant program is not using UTF-8 as its default encoding.  Ant cannot handle
characters outside of the default character set and instead it replaces them with
a question mark, as in the following example.
\begin{verbatim}
Before we drink, we say a toast 
in English: cheers  
in French:  sant??
in Norwegian: sk??l
in Russian: ???? ????????????
in Japanese: ??????
in Korean: ??????
\end{verbatim} 
To correct this, we need to set the \code{ANT\_OPTS} environment variable
\begin{verbatim} 
export ANT\_OPTS="-Dfile.encoding=UTF-8"
\end{verbatim}
The Ant \code{make-toast} task creates a file \code{toast.txt} in the 
\filepath{com/lingpipe/book/intro} directory.
Once the \code{ANT\_OPTS} environment variable is set, the output of the Ant
\code{make-toast} task should match the result
\commandlinefollow{cat toast.txt}
\begin{verbatim}
Before we drink, we say a toast
in English: cheers
in French:  santé
...
\end{verbatim}

If the output consists of a mix of english characters and special characters,
such as foreign currency symbols ({\textyen})  or the copyright symbol ({\copyright}),
then is it likely that the terminal display has the wrong character encoding.

For the Mac terminal.app, choose the \code{Preferences} option under
the Terminal menu.  From the \code{Settings} panel select the \code{Advanced} tab.
Make sure that the character encoding is set to Unicode (UTF-8).
On cygwin, right-click on the top menu bar and select \code{Options\ldots}.
Choose the \code{Text} submenu and make sure that that character set is UTF-8.

If the display is set to UTF-8 and the European langauges display correctly but
not all of the Russian, Japanese, or Korean symbols display, then it is likely
that the fonts needed to display these characters are missing.

