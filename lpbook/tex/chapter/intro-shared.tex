Before beginning with a ``hello world'' example that will verify that
everything's in place for compiling and executing the code in the
book, we'll take some time to explain the tools we'll be using or that
you might want to use.  All of these tools are open source and freely
available, though under a perplexing array of licensing terms and
conditions.  After describing and motivating our choice of each tool,
we'll provide downloading and installation instructions.

\section{Tools of the Trade}

In this section, we go over the various tools we use for program
development.  Not all of these tools are needed to run every example,
and in many cases, we discuss several alternatives among a large
set of examples.  


\subsection{Unix Shell Tools}

We present examples as run from a unix-like command-line shell.
We have chosen this minimal approach for several reasons:
it's a short step from running a program from the command line to
embedding it in some larger text-processing pipeline or application
via a scripting language such as Python;
it avoids dependencies on a particular IDE;
and this is how we authors like to roll
when we write software.

In this book, we use the so-called ``Bourne Again Shell'' (bash) for
Unix-style commands.  Bash is the default shell in Cygwin on Windows,
for Mac OS X, and for Linux, and is also available for Solaris.

On the Mac, this is the Terminal.app under Applications/Utilities.

If you're working in Windows (XP, Vista or 7), we recommend the 
Cygwin suite of Unix command-line tools for Windows.  
Cygwin is released under version 2 of the GNU Public License (GPLv2), with
terms outlined here:
%
\urldisplay{http://cygwin.com/license.html}
%
and also available with a commercial license.

Cygwin can be downloaded and installed through Cygwin's home page,
%
\urldisplay{http://www.cygwin.com/}
%
The \code{setup.exe} program is small.  When you run it, it goes out
over the internet to find the packages from registered mirrors.  It
then lists all the packages available.  You can install some or all of
them.  You can just run the setup program again to update or install
new packages; it'll show you what version of what's already installed.

It might also be easier to list what Cygwin doesn't support.  We use
it mainly for running Unix-like commands in Windows, including pipes,
find, grep, (bash) shell support, tar and gzip, wget, aspell, which,
and so on.  We also use its implementation of the Subversion and CVS
version control systems.  We do not install emacs or TeX through
Cygwin.  These packages are indexed under various categories in
Cygwin, such as Web, Net, Devel, and Base.  

Although it's possible to get Python, Perl, Emacs, \TeX\ and \LaTeX,
and so on, we typically install these packages directly rather than
as part of Cygwin.


\subsubsection{Archive and Compression Tools}

In order to unpack data and library distributions, you need to be able
to run the \code{tar} archiving tool, as well as the unpacking commands
\code{unzip} and \code{gunizp}.  These may be installed as part of
Cygwin on Windows.


\subsection{Version Control}

If you don't live in some kind of version control environment, you should.
Not only can you keep track of your own code across multiple sites and/or
users, you can also keep up to date with projects with version control,
such as this book, the LingPipe sandbox, and projects hosted by open
source hosting services such as SourceForge or Google Code.

We are currently using Subversion (SVN) for LingPipe and this book.
You can install a shell-based version of Subversion, the command-name
for which is \code{svn}.  Subversion itself requires a secure shell
(SSH) client over which to run, at least for most installations.  Both
SVN and SSH can be installed through Cygwin for Windows users.

There are graphical interfaces for subversion.  
Web-SVN, which as its name implies, runs as a server and is
accessible through a web browser, 
%
\urldisplaynote{WebSVN}{http://websvn.tigris.org/}
%
and Tortoise SVN, which integrates with the Windows Explorer,
%
\urldisplaynote{Tortoise SVN}{http://tortoisesvn.net/}

Other popular version control systems include the older Concurrent
Version System (CVS), as well as the increasingly popular Git system,
which is used by the Linux developers.

The best reference for Subversion of which we are aware is the
official guide by the authors, available online at 
%
\urldisplay{http://svnbook.red-bean.com/}


\subsection{Text Editors}

In order to generate code, HTML, and reports, you will need to be able
to edit text.  We like to work in the emacs text editor, because of
its configurability.  It's as close as you'll get to an IDE in a
simple text editor. 

\subsubsection{Spaces, Not Tabs}

To make code portable, we highly recommend using spaces instead of
tabs.  Yes, it takes up a bit more space, but it's worth it.  We
follow Sun's coding standard for Java, so we use four spaces for a
tab.  This is a bit easier to read, but wastes more horizontal space.

\subsubsection{(GNU) Emacs}

We use the GNU Emacs distribution of emacs, which is available from
its home page,
%
\urldisplay{http://www.gnu.org/software/emacs/}
%
It's standard on most Unix and Linux distributions; for Windows, there
is a zipped binary distribution in a subdirectory of the main
distribution that only needs to be unpacked in order to be run.  We've
had problems with the Cygwin-based installations in terms of their
font integration.  And we've also not been able to configure XEmacs
for Unicode, which is the main reason for our preference for GNU Emacs.

We like to work with the Lucida Console font, which is distributed
with Windows; it's the font used for code examples in this book.  It
also supports a wide range of non-Roman fonts.  You can change the
font by pulling down the \code{Options} menu and selecting the
\code{Set Default Font...} item to pop up a dialog box.  Then use
the \code{Save Options} item in the same menu to save it.  It'll show
you where it saved a file called \code{.emacs} which you will need
to edit for the next customizations.

In order to configure GNU Emacs to run UTF-8, you need to add
the following text to your \code{.emacs} file:%
%
\footnote{The UTF-8 instructions are from the Sacrificial Rabbit blog entry
  \url{http://blog.jonnay.net/archives/820-Emacs-and-UTF-8-Encoding.html},
  downloaded 4 August 2010.}
%
\begin{verbatim}
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
(setq x-select-request-type 
    '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
(set-clipboard-coding-system 'utf-16le-dos)
\end{verbatim}
%
The requisite commands to force tabs to be replaced with spaces in
Java files are: 
%
\begin{verbatim}
(defun java-mode-untabify ()
  (save-excursion
    (goto-char (point-min))
    (if (search-forward "t" nil t)
        (untabify (1- (point)) (point-max))))
  nil)

(add-hook 'java-mode-hook
      '(lambda ()
         (make-local-variable 'write-contents-hooks)
         (add-hook 'write-contents-hooks 'java-mode-untabify)))

(setq indent-tabs-mode nil)
\end{verbatim}

\subsection{Java Standard Edition 7}

We chose Java as the basis for LingPipe because we felt it
provided the best tradeoff among efficiency, usability, portability,
and library availability.

The presentation here assumes the reader has a basic working knowledge
of the Java programming language.  We will focus on a few aspects of
Java that are particularly crucial for processing textual language
data, such as character and string representations, input and output
streams and character encodings, regular expressions, parsing HTML and
XML markup, etc.  In explaining LingPipe's design, we will also delve
into greater detail on general features of Java such as concurrency,
generics, floating point representations, and the collection package.

This book is based on the latest currently supported standard edition
of the Java platform (Java SE), which is version 7.  You will need the
Java development kit (JDK) in order to compile Java programs.  A java
virtual machine (JVM) is required to execute compiled Java programs.
A Java runtime environment (JRE) contains platform-specific support
and integration for a JVM and often interfaces to web browsers for
applet support.

Java is available for the Windows, Mac, Linux, and Solaris operating
systems in both 32-bit and 64-bit versions.
The 64-bit version
is required to allocate JVMs with heaps larger than 1.5 or 2 gigabytes
(the exact maximum for 32-bit Java depends on the platform).  
Java is updated regularly and it's worth having the latest version.
Updates include bug fixes and often include performance enhancements,
some of which can be quite substantial.

All currently supported versions of Java for all platforms can be downloaded from:
%
\urldisplay{http://www.oracle.com/technetwork/java/javase/downloads/index.html}
%
This page also contains licensing information as well as downloads of
Java demos, samples, and co-bundled NetBeans IDE.

Java must be added to the operating system's executables path so
that the shell commands and other packages like Ant can find it.

We have to manage multiple versions of Java, so typically we will
define an environment variable \envvar{JAVA\_HOME}, and add
\envvar{\$\{JAVA\_HOME\}/bin} (Unix) or
\envvar{\%JAVA\_HOME\%{\textbackslash}bin} (Windows) to the
\envvar{PATH} environment variable (or its equivalent for your
operating system).  We then set \envvar{JAVA\_HOME} to either
\envvar{JAVA\_1\_5}, \envvar{JAVA\_1\_6}, or \envvar{JAVA\_1\_7}
depending on use case.  Note that \envvar{JAVA\_HOME} is one level
above Java's \filepath{bin} directory containing the executable Java
commands.

You can test whether you can run Java with the following command, which
should produce similar results.
%
\commandlinefollow{java -version}
\begin{verbatim}
java version "1.7.0_10"
Java(TM) SE Runtime Environment (build 1.7.0_10-b18)
Java HotSpot(TM) 64-Bit Server VM (build 23.6-b04, mixed mode)
\end{verbatim}
%
Similarly, you can test for the Java compiler version, using
%
\commandlinefollow{javac -version}
\begin{verbatim}
javac 1.7.0_10
\end{verbatim}


\subsubsection{Java Source}

You can download the Java SE 6 JDK source files from:
%
\urldisplay{http://download.java.net/jdk6/source/}
%
The source is subject to yet another license, available at
%
\urldisplay{http://www.java.net/jrl.csp}
%
The source provides a fantastic set of examples of how to design,
code, and document Java programs.  We especially recommend studying
the source for strings, I/O and collections.  Further, like all
source, it provides a definitive answer to the questions of what a
particular piece of code does and how it does it.  This can be useful
for understanding deeper issues like thread safety, equality and
hashing, efficiency and memory usage.


\subsection{Ant}

We present examples for compilation and for running programs
using the Apache Ant build tool.  Ant has three key features that make
it well suited for expository purposes.  First, it's portable across
all the platforms that support Java.  Second, it provides clear XML
representations for core Java concepts such as classpaths and
command-line arguments.  Third, invoking a target in Ant directly
executes the dependent targets and then all of the commands in the
target.  Thus we find Ant builds easier to follow than those using the
classic Unix build tool Make or its modern incarnation Apache Maven, both
of which attempt to resolve dependencies among targets and determine
if targets are up to date before executing them.

Although we're not attempting to teach Ant, we'll walk through a basic
Ant build file later in this chapter to give you at least a reading
knowledge of Ant.  If you're using an IDE like Eclipse or NetBeans,
you can import Ant build files directly to create a project.

Ant is is an Apache project, and as such, is subject to the Apache license,
%
\urldisplay{http://ant.apache.org/license.html}
%
Ant is available from 
%
\urldisplay{http://ant.apache.org/}
%
You only need one of the binary distributions, which will
look like \code{apache-ant-}\codeVar{version}\code{-bin.tar.gz}.

First, you need to unpack the distribution.  We like directory
structures with release names, which is how ant unpacks, using
top-level directory names like {\tt apache-ant-1.8.1}.  Then, you need
to put the {\tt bin} subdirectory of the top-level directory into the
{\tt PATH} environment variable so that Ant may be executed from the
command line.

Ant requires the {\tt JAVA\_HOME} environment variable to be set to
the path above the {\tt bin} directory containing the Java
executables.  Ant's installation instructions suggest setting the {\tt
ANT\_HOME} directory in the same way, and then adding but it's not
necessary unless you will be scripting calls to Ant.

Ant build files may be imported directly into either the Eclipse or
NetBeans IDEs (see below for a description of these).

You can test whether Ant is installed with
%
\commandlinefollow{ant -version}
\begin{verbatim}
Apache Ant version 1.8.1 compiled on April 30 2010
\end{verbatim}


\subsection{Integrated Development Environment}

Many people prefer to write (and compile and debug) code in an
integrated development environment (IDE).  IDEs offer advantages such
as automatic method, class and constant completion, easily
configurable text formatting, stepwise debuggers, and automated tools
for code generation and refactoring.

LingPipe development may be carried out through an IDE.  The two most
popular IDEs for Java are Eclipse and NetBeans.

\subsubsection{Eclipse IDE}

Eclipse provides a full range of code checking, auto-completion
and code generation, and debugging facilities.  Eclipse is an open-source
project with a wide range of additional tools available as plugins.  It
also has modules for languages other than Java, such as C++ and PHP.

The full set of Eclipse downloads is listed on the following page,
%
\urldisplay{http://download.eclipse.org/eclipse/downloads/}
%
You'll want to make sure you choose the one compatible with the JDK
you are using.  Though originally a Windows-based system, Eclipse has been
ported to Mac OS X (though Carbon) and Linux.  

Eclipse is released under the Eclipse Public License (EPL), a slightly modified
version of the Common Public License (CPL) from IBM, the full text of which is
available from
%
\urldisplay{http://www.eclipse.org/legal/epl-v10.html}


\subsubsection{NetBeans IDE}

Unlike Eclipse, the NetBeans IDE is written entirely in Java.  Thus
it's possible to run it under Windows, Linux, Solaris Unix, and Mac OS
X. There are also a wide range of plug-ins available for NetBeans.

Netbeans is free, and may be downloaded from its home page,
%
\urldisplay{http://netbeans.org/}
%
Its licensing is rather complex, being released under a dual license
consisting of the Common Development and Distribution License (CDDL)
and version 2 of the GNU Public License version 2 (GPLv2).  Full details
are at
%
\urldisplay{http://netbeans.org/about/legal/license.html}


\subsection{Statistical Computing Environment}\label{section:intro-R}

Although not strictly necessary, if you want to draw nice plots of
your data or results, or compute $p$ values for some of the statistics
LingPipe reports, it helps to have a statistical computing language on
hand.  Such languages are typically interpreted, supported interactive
data analysis and plotting.  

In some cases, we will provide R code for operations not supported in
LingPipe.  All of the graphs drawn in the book were rendered as PDFs
in R and included as vector graphics.

\subsubsection{R Project for Statistical Computing}

The most popular open-source statistical computing language is still
the R Project for Statistical Computing (R).  R runs under all the
major operating systems, though the Windows installers and
compatibility with libraries seem to be a bit more advanced than those
for Linux or Mac OS X.

R implements a dialect of the S programming language for matrices and
statistics.  It has good built-in functionality for standard
distributions and matrix operations.  It also allows linking to C or
Fortran back-end implementations.  There are also plug ins (of varying
quality) for just about everything else you can imagine.  The
officially sanctioned plug ins are available from the Comprehensive R
Archive Network (CRAN).

R is available from its home page,
%
\urldisplay{http://www.r-project.org/}
%
The CRAN mirrors are also linked from the page and usually the first
web search results for statistics-related queries in R.

R is distributed under the GNU Public License version 2 (GPLv2).  



\subsubsection{SciPy and NumPy}

The Python programming/scripting language is becoming more and more
popular for both preprocessing data and analyzing statistics.  The
library NumPy provides a matrix library on top of Python and SciPy
a scientific library including statistics and graphing.  The place
to get started is the home page,
%
\urldisplay{http://numpy.scipy.org/}
%
NumPy and SciPy and Python itself are distributed under the much more
flexible BSD License.  

Like R, Python is interpreted and not very fast at operations like
looping.  NumPy helps by allowing some operations to be vectorized (as
does R).  Like R, Python also allows linking C and Fortran back-end
packages for efficiency.

\subsection{Full LingPipe Distribution}

LingPipe is distributed under both commercial licenses
and under a royalty-free license.  A copy of the royalty free
license is available at:
%
\urldisplay{http://alias-i.com/lingpipe/licenses/lingpipe-license-1.txt}

LingPipe may be downloaded with full source from its web site:
%
\urldisplay{http://alias-i.com/lingpipe/}
%
Other than unpacking the gzipped tarball, there is nothing required
for installation.  Downloading LingPipe is not technically necessary for
running the examples in this book because the LingPipe library jar is
included with this book's source download.


\subsection{Book Source and Libraries}

The code samples from this book are available via anonymous subversion checkout
from the LingPipe sandbox.  Specifically, the entire content of the book,
including code and text, may be checked out anonymously using,
%
\commandline{svn co https://aliasi.devguard.com/svn/sandbox/lpbook}
%
The distribution contains all of the code and Ant build files for
running it.  It also contains the \LaTeX\ source for the book itself
as well as the library we created to extract text from the source for
automatic inclusion in the book.  This last feature is actually
critical to ensure the code in the distribution and in the book match.  


\section{Hello World Example}

In this section, we provide a very simple hello world program.  If you
can run it, you'll be all set to jump into the next chapter and get
started with the real examples.  We'll also take this opportunity to
walk through a simple Ant build file.

\subsection{Running the Example}

To the extent we are able, we'll start each discussion with an example
of how to run examples.  This is pretty easy for the hello-world
example.  As with all of our examples, we begin by changing
directories into the directory containing the example.  We suppose
that \relpath{} is the directory in which the code for the book was unpacked.
We then execute the change directory (\code{cd}) command to move
into the subdirectory \code{/src/intro},
%
\commandline{cd \$BOOK/src/intro}
%
Note that we have italicized the commands issued by the user.
%
We then run the demo using Ant.  In this case, the target is \code{hello},
invoked by
%
\commandline{ant hello}
%
which produces the following output
%
\begin{verbatim}
Buildfile: /Users/lpbook/src/intro/build.xml

jar:
    [mkdir] Created dir: /Users/lpbook/src/intro/build/classes
    [javac] Compiling 2 source files to /Users/lpbook/src/intro/
build/classes
      [jar] Building jar: /Users/lpbook/src/intro/build/lp-book-
intro-4.0.jar

hello:
     [java] Hello World

BUILD SUCCESSFUL
Total time: 2 seconds
\end{verbatim}
%
First, Ant echoes the name of the build file, here
\filepath{/Users/lpbook/src/intro/build.xml}.  When Ant is
invoked without specifying a particular build file, it uses the
\filepath{build.xml} in the directory from which it was called.  

Reading down the left side of the output, you see the targets that are
invoked.  The first target invoked is the \code{jar} target, and the
second target is the \code{hello} target.  The targets are left aligned
and followed by semicolons.  A target consists of an ordered list of
dependent targets to invoke before the current target, and an ordered
list of tasks to execute after the dependent targets are invoked.

Under the targets, you see the particular tasks that the target
executes.  These are indented, square bracketed, and right aligned.
The \code{jar} target invokes three tasks, \code{mkdir}, \code{javac},
and \code{jar}.  The \code{hello} target invokes one task, \code{java}.
All of the output for each task is shown after the task name.  If
there is more than one line of output, the name of the task is
repeated.

In this example, the \code{mkdir} task makes a new directory, here the 
\filepath{build/classes} directory.  The \code{javac} task runs the
Java compiler, here compiling a single source file into the
newly created directory.  The \code{jar} task builds the Java
library into the build subdirectory \code{build} in file
\code{lp-book-intro-4.0.jar}.  Moving onto the \code{hello} target,
the \code{java} task runs a command-line Java program, in this
case printing the output of the hello world program.

The reason the \code{jar} target was invoked was because the
\code{hello} target was defined to depend on the \code{jar} target.
Ant invokes all dependent targets (recursively) before the invoked
target.

Finally, Ant reports that the build was successful and reports the
amount of time taken.  In the future, we will usually only show the
output of the Java program executed and not all of the output from the
compilation steps.  To save more space, we also remove the
\code{[java]} tag on the task.  Under this scheme, the \code{hello}
target invocation would be displayed in this book as
%
\commandlinefollow{ant hello}
\begin{verbatim}
Hello World
\end{verbatim}

\subsection{Hello with Arguments}

Often we need to supply arguments to programs from the command
line.  The easiest way to do this with Ant is by setting the
properties on the command line.  Our second demo uses this facility
to provide a customized greeting.
%
\commandlinefollow{ant -Dfirst=Bobby -Dlast=C hello-name}
\begin{verbatim}
Hello, Bobby C.
\end{verbatim}
%
Each argument to a program corresponds to a named property, here
\code{first} and \code{last}.  In general, properties are specified
\code{-D\codeVar{key}=\codeVar{val}}.%
%
\footnote{Depending on your shell, this may also require varying
  amounts of quoting and/or escaping special characters.  For example,
  keys or values with spaces typically require double quotes on
  Windows.}


\subsection{Code Walkthrough}\label{section-intro-hello-code}

The code for the hello world program can be found in
\relpath{src/intro/src/com/lingpipe/book/intro/HelloWorld.java}.
Throughout the book, the files are organized this way, under the
top-level \filepath{src} directory, then the name of the chapter (here
\filepath{intro}), followed by \filepath{src}, followed by the path to
the actual program.  We follow the Java convention of placing files in
a directory structure that mirrors their package structure, so the
remaining part of the path is
\filepath{com/lingpipe/book/intro/HelloWorld.java}.  The contents of
the \filepath{HelloWorld.java} program file is as follows.
%
\codeblock{HelloWorld.1}
%
As usual for Java programs, the first thing in the file is the package
declaration, here \code{com.lingpipe.book.intro}; note how it matches
the end of the path to the file, \filepath{com/lingpipe/book/intro}.
Next is the class definition, \code{HelloWorld}, which matches the
name of the file, \filepath{HelloWorld.java}.

When a Java class is invoked from the command line (or equivalently
through Ant), it must implement a static method with a signature like
the one shown.  Specifically, the method must be named \code{main},
must take a single string array argument of type \code{String[]}, must
not have a return value \ie{return type \code{void}}, and must be
declared to be both public and static using the
\code{public} and \code{static} modifiers.  The method may optionally throw
any kind of exception.

The body of the program here just prints \code{Hello World} to the
system output.  As usual, Java provides a handle to the system output
through the public static variable \code{out} of type
\code{java.io.PrintStream} in the \code{java.lang.System} class.

The more complex program \code{HelloName} that takes two
command-line arguments varies in the body of its \code{main()} method, 
%
\codeblock{HelloName.1}
%
As a convention, we assign the command-line arguments read
from the array \code{args} to a sequence of named variables.  
We then use these same names in the Ant properties (see \refsec{intro-ant-properties}).

\section{Introduction to Ant}

Although we will typically skip discussing the Ant build files,
as they're almost all the same, we will go over the one for the
hello world program in some detail.  

The build file for hello world is located at
\relpath{src/intro/build.xml}, where \relpath{} is the root of the
directory in which this book's files have been unpacked.  In general, the
build files will be broken out by chapter and/or section.  The goal is
to make each of them relatively self contained so that they may be
used as a minimal basis for further development.

\subsection{XML Declaration}

The first thing in any Ant build file is the XML declaration, here
%
\begin{verbatim}
<?xml version="1.0" encoding="ASCII"?>
...
\end{verbatim}
%
This just tells Ant's XML parser that what it's looking at is an XML
file and that the ASCII character encoding is being used for
subsequent data.  We chose ASCII because we didn't anticipate using
any non-ASCII characters; we could have chosen Latin1 or UTF-8 or even
Big5 and written the build file in Chinese.  Most XML parsers are
robust enough to infer the character encoding, but it's always good
practice to make it explicit.

The ellipses (\code{...}) indicate elided material that will be
filled in (or not) in continuing discussion.  

\subsection{Top-Level Project Element} 

The top-level element in the XML file is the project declaration,
which is just
%
\begin{verbatim}
<project>
...
</project>
\end{verbatim}
%
Given our convention for ellipses, the file actually looks as follows,

\begin{verbatim}
<?xml version="1.0" encoding="ASCII"?>
<project>
...
</project>
\end{verbatim}
%
with the remaining ellipses to be filled in below.

The project element's tag is \code{project}, and there are no required
attributes.  The project declaration may optionally be given a name as
the value of attribute \code{name}, a default target to invoke as the
value of attribute \code{default}, and a base directory from which to
run as the value of \code{basedir}.  The base directory defaults
to the directory containing the build file, which is where we set
everything up to run from.  We will not need a default target as we
will specify all targets explicitly for clarity.  The name doesn't
really have a function.

\subsection{Ant Properties}\label{section:intro-ant-properties}

We organize Ant build files in the conventional way starting with
properties, which are declared first in the project element's content.
The properties define constant values for reuse.  Here, we have
%
\begin{verbatim}
  <property name="version"
            value="4.0"/>

  <property name="jar"
            value="build/lp-book-intro-${version}.jar"/>
\end{verbatim}
%
The first property definition defines a property \code{version} with
value \code{4.0} (all values are strings).  The second property is
named \code{jar}, with a value, defined in terms of the first property,
of \code{build/lpb-intro-4.0.jar}.  note that the value of the
property \code{version} has been substituted for the substring \code{\$\{version\}}.
In general, properties are accessed by
\code{\$\{...\}} with the property filled in for the ellipses.

Properties may be overridden from the command line by declaring
an environment variable for the command.  For example,
%
\commandline{ant -Djar=foo.jar jar}
%
calls the build file, setting the value of the \code{jar}
property to be the string \code{foo.jar} (which would create a library
archive called \code{foo.jar}).  The value of a property in Ant is
always the first value to which it is set; further attempts to set it
(as in the body of the Ant file) will be ignored.


\subsection{Ant Targets}

Next, we have a sequence of targets, each of which groups together
a sequence of tasks.  The order of targets is not important.  

\subsubsection{Clean Target}

The first target we have performs cleanup.
%
\begin{verbatim}
  <target name="clean">
    <delete dir="build"/>
  </target>
  ...
\end{verbatim}
%
This is a conventional clean-up target, given the obvious name of
\code{clean}.  Each target has a sequence of tasks that will be
executed whenever the target is invoked.  Here, the task
is a delete task, which deletes the directory named \code{build}.

It is conventional to have a clean task that cleans up all of the
automatically generated content in a project.  Here, the \code{.class}
files generated by the compiler (typically in a deletable subdirectory
\code{build}), and the \code{.jar} file produced by the Java archiver
(typically in the top-level directory).

\subsubsection{Compilation/Archive Target}

The next target is the compilation target, named \code{jar},

\begin{verbatim}
  <target name="jar">
    <mkdir dir="build/classes"/>
    <javac debug="yes"
           debuglevel="source,lines,vars"
           destdir="build/classes"
           includeantruntime="false">
      <compilerarg value="-Xlint:all"/>
      <src path="src/"/>
    </javac>
    <jar destfile="${jar}">
      <fileset dir="build/classes"
               includes="**/*.class"/>
    </jar>
  </target>
  ...
\end{verbatim}
%
Invoking the \code{jar} target executes three tasks, a make-directory
(\code{mkdir}), java compilation (\code{javac}), and Java archive
creation (\code{jar}).  Note that, as we exploit here, it is
allowable to have a target with the same name as a task, because Ant
keeps the namespaces separate.

The first task is the make-directory task, \code{mkdir}, takes the
path for a directory and creates that directory and all of its
necessary parent directories.  Here, it builds the directory
\filepath{build/classes}.  All files are relative to the base
directory, which is by default the directory containing the
\code{build.xml} file, here \relpath{src/intro}.

The second task is the Java compilation task, \code{javac}, does the
actual compilation.  Here we have supplied the task element with four
attributes.  The first two, \code{debug} and \code{debuglevel} are
required to insert debugging information into the compiled code so
that we can get stack traces with line numbers when processes crash.
These can be removed to save space, but they can be very helpful for
deployed systems, so we don't recommend it.  The \code{debug} element
says to turn debugging on, and the \code{debuglevel} says to debug the
source down to lines and variable names, which is the maximal amount
of debugging information available.  The \code{javac} task may specify
the character encoding used for the Java program using the attribute
\code{encoding}.

The destination directory attribute, \code{destdir} indicates where
the compiled classes will be stored.  Here, the path is \filepath{build/classes}.
Note that this is in the directory we first created with the
make-directory task.  Further recall that the \filepath{build} directory
will be removed by the clean target.

Finally, we have a flag with attribute \code{includeantruntime} that
says the Ant runtime libraries should not be included in the classpath
for the compilation.  In our opinion, this should have defaulted to
\code{false} rather than \code{true} and saved us a line in all the
build files.  If you don't specify this attribute, Ant gripes and
tells you what it's defaulting to.

The java compilation task here has content, starting with a compiler
argument.  The element \code{compilerarg} passes the value of the
attribute \code{value} to the underlying call to the \code{javac}
executable in the JDK.  Here, we specified a value of 
\code{-Xlint:all}.  The \code{-X} options to \code{javac} are
documented by running the command \code{javac -X}.  This \code{-X}
option specifies \code{lint:all}, which says to turn all lint
detection on.  This provides extended warnings for form, including
deprecation, unchecked casts, lack of serial version IDs, lack or
extra override specifications, and so on.  These can be turned on and
off one by one, but we prefer to leave them all on and produce
lint-free programs.  This often involves suppressing warnings that
would otherwise be unavoidable, such as casts after object I/O or
internal uses of deprecated public methods.

When compilation requires external libraries, we may add the classpath
specifications either as attributes or elements in the \code{javac}
task.  For instance, we can have a classpath specification, which
is much like a property definition,

\begin{verbatim}
  <path id="classpath">
    <pathelement location="${jar}"/>
    <pathelement location="../../lib/icu4j-4_4_1.jar"/>
  </path>
\end{verbatim}
%
And then we'd add the element 
%
\begin{verbatim}
<classpath refid="classpath"/>
\end{verbatim}
%
as content in the \code{javac} target.

The java compilation task's content continues a source element with
tag \code{src}.  This says where to find the source code to compile.
Here we specify the value of attribute for the path to the source,
\code{path}, as \code{src/}.  As usual, this path is interpreted
relative to the base directory, which by default is the one holding
the \code{build.xml} file, even if it's executed from elsewhere.

The third task is the Java archive task, \code{jar}, which packages up
the compiled code into a single compressed file, conventionally
suffixed with the string \code{.jar}.  The file created is specified
as the value of the \code{destfile} attribute, here given as
\code{\$\{jar\}}, meaning the value of the \code{jar} property will be
substituted, here \code{build/lpb-intro-4.0.jar}.  As ever, this is
interpreted relative to the base project directory.  Note that the jar
is being created in the \code{build} directory, which will be cleaned
by the clean target.  

\subsubsection{Java Execution Task}

The final target is the one that'll run Java,

\begin{verbatim}
  <target name="hello"
          depends="jar">
    <java classname="com.lingpipe.book.intro.HelloWorld"
          classpath="${jar}"
          fork="true">
    </java>
  </target>
\end{verbatim}
%
Unlike the previous targets, this target has a dependency, as
indicated by the \code{depends} attribute on the target element.
Here, the value is \code{jar}, meaning that the \code{jar} target is
invoked before the tasks in the \code{hello} target are executed.
This means that the compilation and archive tasks are always executed
before the \code{hello} target's task.  

It may seem at this point that Ant is using some notion of targets
being up to date.  In fact, it's Java's compiler, \code{javac}, and
Java's \code{jar} command which are doing the checking.  In
particular, if there is a compiled class in the compilation location
that has a later date than the source file, it is not recompiled.%
%
\footnote{This leads to a confusing situation for statics.  Static
constants are compiled by value, rather than by reference if the value
can be computed at compile time.  These values are only recomputed
when a file containing the static constant is recompiled.  If you're
changing the definition of classes on which static constants depend,
you need to recompile the file with the constants.  Just clean first.}
%
Similarly, the \code{jar} command will not rebuild the archive if
all the files from which it were built are older than the archive
itself.

In general, there can be multiple dependencies specified as target
names separated by commas, which will be invoked in order before the
target declaring the dependencies.  Furthermore, if the targets
invoked through \code{depends} themselves have dependencies, these
will be invoked recursively.

The \code{hello} target specifies a single task as content.  The task
is a run-Java task, with element tag \code{java}.  The attribute
\code{classname} has a value indicating which class is executed.  This
must be a fully specified class with all of its package qualifiers
separated by periods (\code{.}).  

To invoke a Java program, we must also have a classpath indicating where
to find the compiled code to run.  In Ant, this is specified with
the \code{classpath} attribute on the \code{java} task.  The value here
is \code{\$\{jar\}}, for which the value of the Java archive for the
project will be substituted.  In general, there can be multiple archives
or directories containing compiled classes on the classpath, and the
classpath may be specified with a nested element as well as an attribute.
Ant contains an entire syntax for specifying path-like structures.

Finally, there is a flag indicated by attribute \code{fork} being
set to value \code{true}, which tells Ant to fork a new process with
a new JVM in which to run the indicated class.  

The target \code{hello-name} that we used for the hello program with
two arguments consists of the following Java task.
%
\begin{verbatim}
    <java classname="com.lingpipe.book.intro.HelloName"
          classpath="${jar}"
          fork="true">
      <arg value="${first}"/>
      <arg value="${last}"/>
    </java>
\end{verbatim}
%
This time, the element tagged \code{java} for the Java task has
content, specifically two argument elements.  Each argument element is
tagged \code{arg} and has a single attribute \code{value}, the value
of which is passed to the named Java programs \code{main()} program as
arguments.  As a convention, our programs will all create string
variables of the same name as their first action, just as in our
hello program with arguments, which we repeat here,
%
\codeblock{HelloName.1}

In more elaborate uses of the \code{java} task, we can also specify
arguments to the Java virtual machine such as the maximum amount of
memory to use or to use ordinary object pointer compression, set Java
system properties, and so on.

The attributes and elements of the Ant \code{java} task code up the
command-line arguments to the java executable.
The command-line equivalent of the \code{hello} task would be:
%
\begin{verbatim}
java -cp build/lp-book-intro-4.0.jar com.lingpipe.book.intro.HelloWorld
\end{verbatim}
%

\subsection{Property Files}

Properties accessed in an Ant build file may also be specified in an
external Java properties file.  This is particular useful in a setting
where many users access the same build file in different environments.
Typically, the build file itself is checked into version control.  If
the build file specifies a properties file, each user may have their
own version of the properties file.

Properties may be loaded directly from the build file, or they may be
specified on the command line.  From within an Ant build file, the
\code{file} attribute in the \code{property} element may be used to
load properties.  For example,
%
\begin{verbatim}
<property file="build.properties"/>
\end{verbatim}
%
From the command line, a properties file may be specified with
%
\commandline{ant -propertyfile build.properties ...}

The properties file is interpreted as a Java properties file.  For
instance, we have supplied a demo properties file
\code{demo.properties} in this chapter's directory we can use with
the named greeting program.  The contents of this file is
%
\begin{verbatim}
first: Jacky
last: R
\end{verbatim}
%
We invoke the Ant target \code{hello-name} to run the demo,
specifying that the properties from the file \code{demo.properties}
be read in.
%
\commandlinefollow{ant -propertyfile demo.properties hello-name}
\begin{verbatim}
Hello, Jacky R.
\end{verbatim}
%
Any command-line specifications using \code{-D} override properties.
For example, we can override the value of \code{first},
%
\commandlinefollow{ant -Dfirst=Brooks -propertyfile demo.properties hello-name}
\begin{verbatim}
Hello, Brooks R.
\end{verbatim}

\subsubsection{Parsing Properties Files}

The parser for properties file is line oriented, allowing the Unix
(\code{{\bk}n}), Macintosh (\code{{\bk}r{\bk}n} Windows
(\code{\bk{r}}) line-termination sequences.  Lines may be continued
like on the shell with a backslash character.

Lines beginning with the hash sign \code{\#} or exclamation point
(\code{!}) are taken to be comments and ignored.  Blank lines are also
ignored.

Each line is interpreted as a key followed by a value.  The characters
equal sign (\code{=}), colon (\code{:}) or a whitespace character
(there are no line terminators within lines; line parsing has already
been done).

Character escapes, including Unicode escapes, are parsed pretty much
as in Java string literals with a bit
more liberal syntax, a few additional escapes (notably for the colon
and equals sign) and some excluded characters (notably backspace).


\subsection{Precedence of Properties}

In Ant, whichever property is read first survives.  The command
line properties precede any other properties, followed by properties
read in from a command-line properties file, followed by the
properties read in from Ant build files in the order they appear.

\subsection{Troubleshooting Ant}

Invoking Ant with the \code{-v} flag causes ant to be extra verbose and can be
very useful when trying to understand unexpected behaviors.


