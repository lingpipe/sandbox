\chapter{Getting Started}

\firstchar{T}his book is intended to provide two things.  First and
foremost, it presents a hands-on introduction to the use of the
LingPipe natural language processing library for building natural
language processing components and applications.  Our main focus is on
programming with the LingPipe library.  Second, the book contains
precise mathematical definitions of all of the models and substantial
algorithms underlying LingPipe.  Understanding the finer mathematical
points will not be assumed for the practical sections of the book.  Of
course, it's impossible to fully sidestep mathematics while explaining
what is essentially a collection of algorithms implementing mathematical
models of language.

Before beginning with a ``hello world'' example that will verify that
everything's in place for compiling and executing the code in the
book, we'll take some time to explain the tools we'll be using or that
you might want to use.  All of these tools are open source and freely
available, though under a perplexing array of licensing terms and
conditions.  After describing and motivating our choice of each tool,
we'll provide downloading and installation instructions.

\section{Tools of the Trade}

In this section, we go over the various tools we use for program
development.  Most are required at some point for running examples
in this book, the exceptions being the full LingPipe download and
interactive development environments, neither of which are needed
to run the examples.


\subsection{Unix Shell Tools}

We present examples as run from a unix-like command-line shell.
One reason to use the shell is that it's easy to script operations so
that they may be repeated.  

The main problem with scripts is that they are not portable across
operating systems or even types of command-line shells.  In this book,
we use the so-called ``Bourne Again Shell'' (bash) for Unix-style
commands.  Bash is the default shell in Cygwin on Windows, for Mac OS
X, and for Linux, and is also available for Solaris.

If you're working in Windows (XP, Vista or 7), we recommend the 
Cygwin suite of Unix command-line tools for Windows.  

Cygwin is released under version 2 of the Gnu Public License (GPLv2), with
terms outlined here:
%
\begin{quote}
\hrefurl{http://cygwin.com/license.html}
\end{quote}
%
and also available with a commercial license.

Cygwin can be downloaded and installed through Cygwin's home page,
%
\begin{quote}
\hrefurl{http://www.cygwin.com/}
\end{quote}
%
The {\tt setup.exe} program is small.  When you run it, it goes out
over the internet to find the packages from registered mirrors.  It
then lists all the packages available.  You can install some or all of
them.  You can just run the setup program again to update or install
new packages; it'll show you what version of what's already installed.

\subsubsection{Archive and Compression Tools}

In order to unpack data and library distributions, you need to be able
to run the {\tt tar} archiving tool, as well as the unpacking commands
{\tt unzip} and {\tt gunizp}.  These may be installed as part of
Cygwin on Windows.


\subsection{Version Control}

If you don't live in some kind of version control environment, you should.
Not only can you keep track of your own code across multiple sites and/or
users, you can also keep up to date with projects with version control,
such as this book, the LingPipe sandbox, and projects hosted by open
source hosting services such as SourceForge or Google Code.

We are currently using Subversion (SVN) for LingPipe and this book.
You can install a shell-based version of Subversion, the command-name
for which is {\tt svn}.  Subversion itself requires a secure shell
(SSH) client over which to run, at least for most installations.  Both
SVN and SSH can be installed through Cygwin for Windows users.

There are also graphical versions of subversion, the two most popular
being Web-SVN, which as its name implies, runs as a server and is
accessible through a web browser, and Tortoise SVN, which integrates
with the Windows Explorer.  The home pages for these products are
%
\begin{itemize}
\item WebSVN: \hrefurl{http://websvn.tigris.org/}
\item Tortoise SVN: \hrefurl{http://tortoisesvn.net/}
\end{itemize}

There are also other popular version control systems, the older
concurrent version system (CVS), as well as the increasingly popular
Git system, which is used by the Linux developers.  

The best reference for Subversion of which we are aware is
{\it Version Control with Subversion} (Second Edition,
2008, O'Reilly Press), which is available free online in HTML or PDF
formats from
%
\begin{quote}
\hrefurl{http://svnbook.red-bean.com/}
\end{quote}



\subsection{Text Editors}

In order to generate code, HTML, and reports, you will need to be able
to edit text.  We like to work in the emacs text editor, because of
its configurability.  It's as close as you'll get to an IDE in a
simple text editor.  We use the XEmacs distribution of emacs, which is
available from its home page,
%
\begin{quote}
\hrefurl{http://www.xemacs.org/}
\end{quote}
%
There's an installer for Windows.  We found the install from {\tt
xemacs.org} to work better than the one that comes with Cygwin as far
as interacting with Windows.  We like to work with the Lucida Console
font, which is distributed with Windows; it's the font used for code
examples in this book.

\subsubsection{Spaces, Not Tabs}

To make code portable, we highly recommend using spaces instead of
tabs.  Yes, it takes up a bit more space, but it's worth it.  The
requisite commands are shown in \reffig{emacs-tabs}.  To apply these
commands, first select the {\tt Edit Init File} selection from the {\tt
Options} menu in XEmacs, add the text in \reffig{emacs-tabs}, then
save using the {\tt Save Options to Custom File} selection from the
{\tt Options} menu.

\begin{figure}
{\small
\begin{verbatim}
(defun java-mode-untabify ()
  (save-excursion
    (goto-char (point-min))
    (if (search-forward "t" nil t)
        (untabify (1- (point)) (point-max))))
  nil)

(add-hook 'java-mode-hook
          '(lambda ()
             (make-local-variable 'write-contents-hooks)
             (add-hook 'write-contents-hooks 'java-mode-untabify)))

(setq indent-tabs-mode nil)\end{verbatim}}%
\caption{Required configuration for emacs so that it uses spaces rather than tabs for Java.}\label{fig:emacs-tabs}
\end{figure}



\subsection{Java Standard Edition 6}

We chose Java as the basis for LingPipe because we felt it
provided the best tradeoff among efficiency, usability, portability,
and library availability.

The presentation here assumes the reader has a basic working knowledge
of the Java programming language.  We will focus on a few aspects of
Java that are particularly crucial for processing textual language
data, such as character and string representations, input and output
streams and character encodings, regular expressions, parsing HTML and
XML markup, etc.  In explaining LingPipe's design, we will also delve
into greater detail on general features of Java such as concurrency,
generics, floating point representations, and the collection package.

This book is based on the latest currently supported standard edition
of the Java platform (Java SE), which is version 6.  You will need the
Java development kit (JDK) in order to compile Java programs.  A java
virtual machine (JVM) is required to execute compiled Java programs.
A Java runtime environment (JRE) contains platform-specific support
and integration for a JVM and often interfaces to web browsers for
applet support.

Java is available in 32-bit and 64-bit versions.  The 64-bit version
is required to allocate JVMs with heaps larger than 1.5 or 2 gigabytes
(the exact maximum for 32-bit Java depends on the platform).  


Licensing terms for the JRE are at
%
\begin{quote}
\hrefurl{http://www.java.com/en/download/license.jsp}{}
\end{quote}
and for the JDK at
%
\begin{quote}
\hrefurl{http://java.sun.com/javase/6/jdk-6u20-license.txt}
\end{quote}

Java is available for the Windows, Linux, and Solaris operating
systems in both 32-bit and 64-bit versions from
%
\begin{quote}
\hrefurl{http://java.sun.com/javase/downloads/index.jsp}
\end{quote}
%
The Java JDK and JRE are included as part of Mac OS X.  Updates are
available through
%
\begin{quote}
\hrefurl{http://developer.apple.com/java/download/}
\end{quote}
%
Java is updated regularly and it's worth having the latest version.
Updates include bug fixes and often include performance enhancements,
some of which can be quite substantial.

Java must be installed on the operating system so that shell commands
will execute it.  We have to manage multiple versions of Java, so
typically we will define an environment variable {\tt JAVA\_HOME}, and
add {\tt \$\{JAVA\_HOME\}/bin} (Unix) or {\tt \%JAVA\_HOME\%{\textbackslash}bin} (Windows) 
to the {\tt PATH}.  We then set {\tt JAVA\_HOME} to either {\tt
JAVA\_1\_5}, {\tt JAVA\_1\_6}, or {\tt JAVA\_1\_7} depending on use
case.  Note that {\tt JAVA\_HOME} is one level above Java's {\tt bin}
directory containing the executable Java commands.

You can test whether you can run Java with the following command, which
should produce similar results.
%
\begin{quote}
{\small
\ttfamily
> {\it\ttfamily java -version}
\\
java version "1.6.0\_18"
\\
Java(TM) SE Runtime Environment (build 1.6.0\_18-b07)
\\
Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)
}
\end{quote}
%
Similarly, you can test for the Java compiler version, using
%
\begin{quote}
{\small\ttfamily
> {\it\ttfamily javac -version}
\\
javac 1.6.0\_20
}
\end{quote}


\subsection{Ant}

We present examples for compilation and for running programs
using the Apache Ant build tool.  Ant has three key features that make
it well suited for expository purposes.  First, it's portable across
all the platforms that support Java.  Second, it provides clear XML
representations for core Java concepts such as classpaths and
command-line arguments.  Third, invoking a target in Ant directly
executes the dependent targets and then all of the commands in the
target.  Thus we find Ant builds easier to follow than those using the
classic Unix build tool Make or its modern incarnation Apache Maven, both
of which attempt to resolve dependencies among targets and determine
if targets are up to date before executing them.

Although we're not attempting to teach Ant, we'll walk through a basic
Ant build file later in this chapter to give you at least a reading
knowledge of Ant.  If you're using an IDE like Eclipse or NetBeans,
you can import Ant build files directly to create a project.

Ant is is an Apache project, and as such, is subject to the Apache license,
\begin{quote}
\hrefurl{http://ant.apache.org/license.html}
\end{quote}
%
Ant is available from 
%
\begin{quote}
\hrefurl{http://ant.apache.org/}
\end{quote}
%
You only need one of the binary distributions, which will
look like {\ttfamily apache-ant-{\it\ttfamily version}-bin.tar.gz}.

First, you need to unpack the distribution.  We like directory
structures with release names, which is how ant unpacks, using
top-level directory names like {\tt apache-ant-1.8.1}.  Then, you need
to put the {\tt bin} subdirectory of the top-level directory into the
{\tt PATH} environment variable so that Ant may be executed from the
command line.

Ant requires the {\tt JAVA\_HOME} environment variable to be set to
the path above the {\tt bin} directory containing the Java
executables.  Ant's installation instructions suggest setting the {\tt
ANT\_HOME} directory in the same way, and then adding but it's not
necessary unless you will be scripting calls to Ant.

Ant build files may be imported directly into either the Eclipse or
NetBeans IDEs (see below for a description of these).

You can test whether Ant is installed with

\begin{quote}
{\small\ttfamily
> {\it\ttfamily ant -version}
Apache Ant version 1.8.1 compiled on April 30 2010
}
\end{quote}

\subsection{Integrated Development Environment}

Many pepeople prefer to write (and compile and debug) code in an
integrated development environment (IDE).  IDEs offer advantages such
as automatic method, class and constant completion, easily
configurable text formatting, stepwise debuggers, and automated tools
for code generation and refactoring.

LingPipe development may be carried out through an IDE.  The two most
popular IDEs for Java are Eclipse and NetBeans.

\subsubsection{Eclipse IDE}

Eclipse provides a full range of code checking, auto-completion
and code generation, and debugging facilities.  Eclipse is an open-source
project with a wide range of additional tools available as plugins.  It
also has modules for languages other than Java, such as C++ and PHP.

The full set of Eclipse downloads is listed on the following page,
%
\begin{quote}
\hrefurl{http://download.eclipse.org/eclipse/downloads/}
\end{quote}
%
You'll want to make sure you choose the one compatible with the JDK
you are using.  Though originally a Windows-based system, Eclipse has been
ported to Mac OS X (though Carbon) and Linux.  

Eclipse is released under the Eclipse Public License (EPL), a slightly modified
version of the Common Public License (CPL) from IBM, the full text of which is
available from
%
\begin{quote}
\hrefurl{http://www.eclipse.org/legal/epl-v10.html}
\end{quote}


\subsubsection{NetBeans IDE}

Unlike Eclipse, the NetBeans IDE is written entirely in Java.  Thus
it's possible to run it under Windows, Linux, Solaris Unix, and Mac OS
X. There are also a wide range of plug-ins available for NetBeans.

Netbeans is free, and may be downloaded from its home page,
%
\begin{quote}
\hrefurl{http://netbeans.org/}
\end{quote}
%
Its licensing is rather complex, being released under a dual license
consisting of the Common Development and Distribution License (CDDL)
and version 2 of the Gnu Public License version (GPLv2).  Full details
are at
%
\begin{quote}
\hrefurl{http://netbeans.org/about/legal/license.html}
\end{quote}


\subsection{Full LingPipe Distribution}

LingPipe is distributed under both commercial licenses
and under a royalty-free license.  A copy of the royalty free
license is available at:
%
\begin{quote}
\hrefurl{http://alias-i.com/lingpipe/licenses/lingpipe-license-1.txt}
\end{quote}

LingPipe may be downloaded with full source from its web site:
%
\begin{quote}
\hrefurl{http://alias-i.com/lingpipe/}
\end{quote}
%
Other than unpacking the gzipped tarball, there is nothing required
for installation.  Downloading LingPipe is not technically necessary for
running the examples in this book because the LingPipe library jar is
included with this book's source download.


\subsection{Book Source and Libraries}

The code samples from this book are available via anonymous subversion checkout
from the LingPipe sandbox.  Specifically, the entire content of the book,
including code and text, may be checked out anonymously using,

\begin{quote}
{\small\ttfamily
> svn co https://aliasi.devguard.com/svn/sandbox/lpbook
}
\end{quote}
%
The distribution contains all of the code and Ant build files for
running it.  It also contains the \LaTeX\ source for the book itself
as well as the system to extract text from the source for automatic
inclusion in the book.


\section{Hello World Example}

In this section, we provide a very simple hello world program.  If you
can run it, you'll be all set to jump into the next chapter and get
started with the real examples.  We'll also take this opportunity to
walk through a simple Ant build file.

\subsection{Running the Example}

To the extent we are able, we'll start each discussion with an example
of how to run examples.  This is pretty easy for the hello-world
example.  As with all of our examples, we begin by changing
directories into the directory containing the example.  We suppose
that \relpath{} is the home page for the book and execute the
{\small\tt cd} command,
%
\commandline{cd \$BOOK/intro}
%
Note that we have italicized the commands issued by the user.
%
We then run the demo using Ant.  In this case, the target is {\small\tt hello},
invoked by
\\[8pt]
{\ttfamily \$ \it\ttfamily ant hello}
\\[8pt]
which produces the following output
%
{\small\begin{verbatim}
Buildfile: c:\lpb\src\intro\build.xml

jar:
    [mkdir] Created dir: c:\lpb\src\intro\build\classes
    [javac] Compiling 1 source file to c:\lpb\src\intro\build\classes
      [jar] Building jar: c:\lpb\src\intro\build\lp-book-intro-4.0.jar

hello:
     [java] Hello World

BUILD SUCCESSFUL
Total time: 1 second
\end{verbatim}}
%
First, Ant echoes the name of the build file, here {\tt
c:{\bk}lpb{\bk}src{\bk}intro{\bk}build.xml}.  When Ant is
invoked without specifying a particular build file, it uses the
{\tt build.xml} in the directory from which it was called.  

Reading down the left side of the output, you see the targets that are
invoked.  The first target invoked is the {\tt jar} target, and the
second target is the {\tt hello} target.  The targets are left aligned
and followed by semicolons.  A target consists of an ordered list of
dependent targets to invoke before the current target, and an ordered
list of tasks to execute after the dependent targets are invoked.

Under the targets, you see the particular tasks that the target
executes.  These are indented, square bracketed, and right aligned.
The {\tt jar} target invokes three tasks, {\tt mkdir}, {\tt javac},
and {\tt jar}.  The {\tt hello} target invokes one task, {\tt java}.
All of the output for each task is shown after the task name.  If
there is more than one line of output, the name of the task is
repeated.

In this example, the {\tt mkdir} task makes a new directory, here the {\tt
build{\bk}classes} directory.  The {\tt javac} task runs the
Java compiler, here compiling a single source file into the
newly created directory.  The {\tt jar} task builds the Java
library into the build subdirectory {\tt build} in file
{\tt lp-book-intro-4.0.jar}.  Moving onto the {\tt hello} target,
the {\tt java} task runs a command-line Java program, in this
case printing the output of the hello world program.

The reason the {\tt jar} target was invoked was because the {\tt
hello} target was defined to depend on the {\tt jar} target.  Ant
invokes all dependent targets (recursively) before the invoked target.

Finally, Ant reports that the build was successful and reports the
amount of time taken.  In the future, we will usually only show the
output of the Java program executed and not all of the output from the
compilation steps.  To save more space, we also remove the {\tt
[java]} tag on the task.  Under this scheme, the {\tt hello} target
invocation would be displayed in this book as
\\[8pt]
{\ttfamily \$ \it\ttfamily ant hello}
{\small\begin{verbatim}
Hello World
\end{verbatim}}


\subsection{A Quick Introduction to Ant}

Although we will typically skip discussing the Ant build files,
as they're almost all the same, we will go over the one for the
hello world program in some detail.  

The build file for hello world is located at
\relpath{src/intro/build.xml}, where \relpath{} is the root of the
directory in which this book's files have been unpacked.  In general, the
build files will be broken out by chapter and/or section.  The goal is
to make each of them relatively self contained so that they may be
used as a minimal basis for further development.

\subsubsection{XML Declaration}

The first thing in any Ant build file is the XML declaration, here
%
\begin{verbatim}
<?xml version="1.0" encoding="ASCII"?>
...
\end{verbatim}
%
This just tells Ant's XML parser that what it's looking at is an XML
file and that the ASCII character encoding is being used for
subsequent data.  (See
\refchap{char} for more information on character encodings).  
We chose ASCII because we didn't anticipate using any non-ASCII
characters; we could have chosen Latin1 or UTF-8 or even Big5 and
written the build file in Chinese.  Most XML parsers are robust enough
to infer the character encoding, but it's always good practice to make
it explicit.

The ellipses (\code{...}) indicate ellided material that will be
filled in or not in continuing discussion.  

\subsubsection{Top-Level Project Element} 

The top-level element in the XML file is the project declaration,
which is just
%
\begin{verbatim}
<project>
...
</project>
\end{verbatim}
%
Given our convention for ellipses, the file actually looks as follows,

\begin{verbatim}
<?xml version="1.0" encoding="ASCII"?>
<project>
...
</project>
\end{verbatim}
%
with the remaining ellipses to be filled in below.

The project element's tag is \code{project}, and there are no required
attributes.  The project declaration may optionally be given a name as
the value of attribute \code{name}, a default target to invoke as the
value of attribute \code{default}, and a base directory from which to
run as the value of \code{basedir}.  The base directory defaults
to the directory containing the build file, which is where we set
everything up to run from.  We will not need a default target as we
will specify all targets explicitly for clarity.  The name doesn't
really have a function.

\subsubsection{Ant Properties}

We organize Ant build files in the conventional way starting with
properties, which are declared first in the project element's content.
The properties define constant values for reuse.  Here, we have
%
\begin{verbatim}
  <property name="version"
            value="4.0"/>

  <property name="jar"
            value="build/lp-book-intro-${version}.jar"/>
\end{verbatim}
%
The first property definition defines a property \code{version} with
value \code{4.0} (all values are strings).  The second property is
named \code{jar}, with a value, defined in terms of the first property,
of \code{build/lpb-intro-4.0.jar}.  note that the value of the
property \code{version} has been substituted for the substring \code{\$\{version\}}.
In general, properties are accessed by
\code{\$\{...\}} with the property filled in for the ellipses.

Properties may be overridden from the command line using, for example,
%
\begin{verbatim}
ant -Djar=foo.jar jar
\end{verbatim}
%
would call the build file, setting the value of the \code{jar}
property to be the string \code{foo.jar} (which would create a library
archive called \code{foo.jar}).  The value of a property in Ant is
always the first value to which it is set; further attempts to set it
(as in the body of the Ant file) will be ignored.

Properties may also be specified in an external Java properties file,
which is very helpful for setting local variables that vary by
install, but we will not need that option for this book.

\subsubsection{Ant Targets}

Next, we have a sequence of targets, each of which groups together
a sequence of tasks.  The order of targets is not important.  The
first target we have is

\begin{verbatim}
  <target name="clean">
    <delete dir="build"/>
  </target>
  ...
\end{verbatim}
%
This is a conventional clean-up target, given the obvious name of
\code{clean}.  Each target has a sequence of tasks that will be
executed whenever the target is invoked.  Here, the task
is a delete task, which deletes the directory named \code{build}.

It is conventional to have a clean task that cleans up all of
the automatically generated content in a project.  Here, the
\code{.class} files generated by the compiler and \code{.jar}
file produced by the archiver will be deleted, as should soon be
evident.

The next target is the compilation target, named \code{jar},

\begin{verbatim}
  <target name="jar">
    <mkdir dir="build/classes"/>
    <javac debug="yes"
           debuglevel="source,lines,vars"
           destdir="build/classes"
           includeantruntime="false">
      <src path="src/"/>
    </javac>
    <jar destfile="${jar}">
      <fileset dir="build/classes"
               includes="**/*.class"/>
    </jar>
  </target>
  ...
\end{verbatim}
%
Invoking the \code{jar} target executes three tasks, a make-directory
(\code{mkdir}), java compilation (\code{javac}), and Java archive
creation (\code{jar}).  Note that, as we exploit here, it is
allowable to have a target with the same name as a task, because Ant
keeps the namespaces separate.

The first task is the make-directory task, \code{mkdir}, takes the path for a directory and creates
that directory and all of its necessary parent directories.  Here,
it builds the directory \filepath{build/classes}.  All files are
relative to the base directory, which is here the directory containing
the \code{build.xml} file, namely \relpath{src/intro}.

The second task is the Java compilation task, \code{javac}, does the
actual compilation.  Here we have supplied the task element with four
attributes.  The first two, \code{debug} and \code{debuglevel} are
required to insert debugging information into the compiled code so
that we can get stack traces with line numbers when processes crash.
These can be removed to save space, but they can be very helpful for
deployed systems, so we don't recommend it.  The \code{debug} element
says to turn debugging on, and the \code{debuglevel} says to debug the
source down to lines and variable names, which is the maximal amount
of debugging information available.

The destination directory attribute, \code{destdir} indicates where
the compiled classes will be stored.  Here, the path is \filepath{build/classes}.
Note that this is in the directory we first created with the
make-directory task.  Further recall that the \filepath{build} directory
will be removed by the clean target.

Finally, we have a flag with attribute \code{includeantruntime} that
says the Ant runtime libraries should not be included in the classpath
for the compilation.  In our opinion, this should have defaulted to
\code{false} rather than \code{true} and saved us a line in all the
build files.  If you don't specify this attribute, Ant gripes and
tells you what it's defaulting to.

The java compilation task here has content, namely a single
source element with tag \code{src}.  This says where to find
the source code to compile.  Here we specify the value of
attribute for the path to the source, \code{path}, as
\code{src/}.  Again, this is interpreted relative to the base directory,
which is the one holding the \code{build.xml} file.  

In more elaborate builds, we would specify a classpath element as
further content to the java-compilation task if we depend on external
libraries.  

The third task is the Java archive task, \code{jar}, which packages up
the compiled code into a single compressed file, conventionally
suffixed with the string \code{.jar}.  The file created is specified
as the value of the \code{destfile} attribute, here given as
\code{\$\{jar\}}, meaning the value of the \code{jar} property will be
substituted, here \code{build/lpb-intro-4.0.jar}.  As ever, this is
interpreted relative to the base project directory.  Note that the jar
is being created in the \code{build} directory, which will be cleaned
by the clean target.  

The final target is the one that'll run Java,

\begin{verbatim}
  <target name="hello"
          depends="jar">
    <java classname="com.lingpipe.book.intro.HelloWorld"
          classpath="${jar}"
          fork="true">
    </java>
  </target>
\end{verbatim}
%
Unlike the previous targets, this target has a dependency, as
indicated by the \code{depends} attribute on the target element.
Here, the value is \code{jar}, meaning that the \code{jar} target is
invoked before the tasks in the \code{hello} target are executed.
This means that the compilation and archive tasks are always executed
before the \code{hello} target's task.  

It may seem at this point that Ant is using some notion of targets
being up to date.  In fact, it's Java's compiler, \code{javac}, and
Java's \code{jar} command which are doing the checking.  In
particular, if there is a compiled class in the compilation location
that has a later date than the source file, it is not recompiled.%
%
\footnote{This leads to a confusing situation for statics.  Static
constants are compiled by value, rather than by reference if the value
can be computed at compile time.  These values are only recomputed
when a file containing the static constant is recompiled.  If you're
changing the definition of classes on which static constants depend,
you need to recompile the file with the constants.  Just clean first.}
%
Similarly, the \code{jar} command will not rebuild the archive if
all the files from which it were built are older than the archive
itself.

In general, there can be multiple dependencies specified as target
names separated by commas, which will be invoked in order before the
target declaring the dependencies.  Furthermore, if the targets
invoked through \code{depends} themselves have dependencies, these
will be invoked recursively.

The \code{hello} target specifies a single task as content.  The task
is a run-Java task, with element tag \code{java}.  The attribute
\code{classname} has a value indicating which class is executed.  This
must be a fully specified class with all of its package qualifiers
separated by periods (\code{.}).  

To invoke a Java program, we must also have a classpath indicating where
to find the compiled code to run.  In Ant, this is specified with
the \code{classpath} attribute on the \code{java} task.  The value here
is \code{\$\{jar\}}, for which the value of the Java archive for the
project will be substituted.  In general, there can be multiple archives
or directories containing compiled classes on the classpath, and the
classpath may be specifeid with a nested element as well as an attribute.
Ant contains an entire syntax for specifying path-like structures.

Finally, there is a flag indicated by attribute \code{fork} being
set to value \code{true}, which tells Ant to fork a new process with
a new JVM in which to run the indicated class.  

In more elaborate uses of the \code{java} task, we can also specify
command-line arguments and other arguments to the Java virtual machine
(JVM).  


\subsection{Code Walkthrough}
















