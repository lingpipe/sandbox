\chapter{Input and Output}\label{chap:io}

\firstchar{J}ava provides a rich array of classes for dealing with
input and output.  At the basic level, input and output streams
provide a means to transfer data consisting of a sequence of bytes.
Data may be transferred among memory with memory-backed streams, the
file system via file streams or memory mapped files, the terminal via
standard input and output streams, and remote servers via sockets.
Stream filters may be put in place to compress or decompress data.
Streams that block awaiting input or output may be dealt with in
threads.

Bytes may encode anything, but we are particularly interested in the
case of natural language text data, with or without document
structure.  To support streams of \code{char} values, Java provides
\code{char} streams as byte streams.  In order to crete a character
stream from byte stream, the character encoding must be known.

We are also interested in sequences of bytes that encode Java objects
through serialization.  We use serialized objects to represent models
and their components, such as tokenizers.  


\section{Files}

Java provides the class \code{File} in the \code{java.io} package for
representing files and directories on the local file system.
Underlyingly, an instance of \code{File} is nothing more than a string
representing a path coupled with a convenient set of utility methods,
some of which access the underlying file system.  

\subsection{Relative vs.\ Absolute Paths}

Files may be either relative or absolute.  An absolute path name
provides a full description of where to find a file on the system in
question.  A relative path picks out a file or directory starting from
a root directory (the form of which will be operating system
specific).  Relative paths may pick out different resources in
different situations depending on the base directory.

The static method \code{File.listRoots()} provides an array of all of
the available root directories.  We wrote a simple demo in the
class \code{ListRoots}, the heart of which is
%
\codeblock{ListRoots.1}
%
Running it on my Windows machine returns
%
\commandlinefollow{ant list-roots}
\begin{verbatim}
Root Directories
     C:\
     E:\
\end{verbatim}
%
The root directories \code{C:\bk} and \code{E:\bk} correspond to my
two drives, but they could also correspond to partitions of a single
drive or a redundant array of independent disks (RAID), or even a
section of memory acting like a disk drive.

\subsubsection{Root of Relative Paths}

In Java, relative paths are interpreted relative to the directory from
which Java was called.  The same goes for Ant, except when a \code{basedir}
attribute is set on the top-level \code{project} element.  

A consequence of this behavior is that the empty string (\code{""}) is
a path that picks out the directory from which Java was called.


\subsection{Windows vs.\ UNIX File Conventions}

Due to the differing setup of the operating systems, \code{File}
objects behave differently on different platforms.  In all cases, they
respect the conventions of the file system on which they are run, but
it requires some care to create portable code or Ant tasks that involve
files.

On either Windows or UNIX, files are organized hierarchically into
directories under one or more root directories.  Each file other
than one of the root directories has a parent directory.  The most
prominent difference between the two operating system flavors is
that Windows uses a backslash (\code{\bk}), whereas UNIX uses
a forward slash (\code{/}) to separate directories and file names
in a path.

In Unix, there is a single root directory for the file system, and
absolute path names will start with a forward slash (\code{/}).  

In Windows, there may be more than one root directory.  Each root
directory is written as a drive letter followed by a colon-backslash
(\code{:\bk}), as in \code{C:\bk} for the root directory on the drive
named \code{C}.  

Windows also allows Universal Naming Convention (UNC) network paths,
which begin with two backslashes (\code{\bk\bk}) followed by the name
of the computer or device on the network.  For instance,
\code{{\bk\bk}MONTAGUE} is the root of the shared files on the network
computer named
\code{MONTAGUE}.  Each networked Windows computer makes visible its 
top-level shared files.  

The biggest difference is that in Windows, file names are not case
sensitive.  Thus \code{FOO}, \code{foo}, and \code{Foo} will all pick
out the same file.  


\subsection{Constructing a \code{File}}

There are four \code{File} constructors.  The simplest,
\code{File(String)}, simply takes a path name to construct
a file object.  The string may be anything, but separator characters
will be parsed and normalized.

Conveniently, Java lets you use either forward (Unix)
or backward (Windows) slashes interchangeably, as does Ant.  Thus in
Windows, I can use Unix-style forward slashes with the same effect as
backward slashes.  For example, \code{new File("c:/foo")}, constructs
the same object as \code{new File("c:{\bk}foo")}.  

There are also two-argument constructors taking a parent directory and
a file name.  The parent may be specified as a string using the constructor
\code{File(String,String)} or as a file itself, using the constructor
\code{File(File,String)}.

\subsubsection{URI/URL to File Conversion}

There is a fourth \code{File} constructor that takes a uniform
resource identifier (URI) argument, \code{File(URI)} (see
\refsec{uri-url-urn} for more information on URIs and URLs).  The
\code{URI} class is in the \code{java.net} package, which comes
standard with Java.

URIs for files have the form
\code{file://}\codeVar{host}\code{/}\codeVar{path}, where the
(optional) \codeVar{host} picks out a domain name and \codeVar{path} a
file path.  If the \codeVar{host} is not specified, the form devolves
to \code{file:///}\codeVar{path}, and the host is assumed to be the
the so-called localhost, the machine on which Java is running.

It is also possible to convert an instance of \code{File} to a URI,
using the method \code{toURI()} in \code{File}.  

It is also possible to get a uniform resource locator (URL) from a
file, by first converting to a URI and then calling the \code{URI}
method \code{toURL()}, which returns an instance of \code{URL}, also
in \code{java.net}.



\subsection{Getting a File's Canonical Path}

The method \code{getCanonicalFile()} returns a \code{File} based on an
absolute path with a conventionalized name.  For instance, if I happen
to be running in directory \code{c:{\bk}lpb} (on Windows), then the
following two expressions return equivalent files
%
\begin{verbatim}
new File("c:\lpb\Foo").getCanonicalPath()
\end{verbatim}
%
%
\begin{verbatim}
new File("foo").getCanonicalPath();
\end{verbatim}
%
Note that this is not truly a unique normal form.  The resulting files
will have different capitalizations for \code{foo} in this case, but
will be equivalent running under Windows.  Further note that the
canonical path is not used for equality (see \refsec{io-files-equality}).


\subsection{Exploring File Properties}

There are many methods on \code{File} objects which explore the type
of a file.  The method \code{exists()} tests whehter it exists,
\code{isAbsolute()} tests whether it
denotes an absolute path, \code{isDirectory()} whether it's directory,
\code{isFile()} whether it's an ordinary file, and
\code{isHidden()} tests whether it's hidden (starts with a period (\code{.}) in
Unix or is so marked by the operating system in Windows).

What permissions an application has for a file can be probed with
\code{canExecute()},\code{canRead()}, and \code{canWrite()}, all of
which return boolean values.

The time it was last modified, available through
\code{lastModified()}, returns the time as a \code{long} denoting
milliseconds since the epoch (the standard measure of time on
computers, and the basis of Java's date and calendar representations).

The number of bytes in a file is returned as a \code{long} by
\code{length()}.

The name of the file itself (everything but the parent), is returned
by \code{getName()}.  The methods \code{getParent()} and
\code{getParentFile()} return the parent directory as a string or as a
file, returning \code{null} if no parent was specified.

\subsection{Listing the Files in a Directory}

If a file is a directory, the method \code{listFiles()} returns an
array of files that the directory contains; it returns \code{null}
if the file's not a directory.  The files may also be listed
by name using \code{list()}. 

File listings may be filtered with an implementation of
\code{FileFilter}, an interface in \code{java.io} specifying a single
method \code{accept(File)} returning \code{true} if the file is
acceptable.  An older interface, \code{FilenameFilter}, is also
available for file name listings.


\subsubsection{LingPipe's \code{FileExtensionFilter}}

LingPipe provides a convenience class \code{FileExtensionFilter}, which
implements a \code{FileFilter} based on the extension of a file.  A
file's extension is here defined to mean the string after the final
period (\code{.}) in the file's name.  This is purely a convention for
naming files, which is especially useful in Windows or web browsers,
where each extension may be associated with a program to open or view
files with that extesnion.

A file extension filter takes a single or multiple strings
specified as an array.

A file extension filter is configured with a flag indicating
whether it should automatically accept directories or not, which
is convenient for recursive descents through a file system.  The
default for the unmarked constructors is to accept directories.

File extension filters would implement \code{FilenameFilter}
directly if they could, but it causes a conflict with the
polymorphic file method \code{listFiles(FilenameFilter)} and
\code{listFiles(FileFilter)}.  Instead, a file extension filter
provides a method \code{fileNameFilter()} which returns the
corresponding file name filter.  This is only necessary if you want to
test or list files by name rather than as files.

There are two static utility methods in the class \code{Files} in
\code{com.aliasi.util} that break file names apart into their suffix
and their base name.  The method \code{Files.extension(File)} returns
the extesnion of a file, consisting of the text after the final
period (\code{.}), or \code{null} if there is no period.  The method
\code{baseName(File)} returns the base name of a file, which excludes
the last period and extension.  For instance, a file named \code{io.tex}
has extension \code{tex} and base name \code{io}, whereas \code{foo.bar.baz}
has extension \code{baz} and base name \code{foo.bar}.


\subsection{Exploring Partitions}

Each file in an operating system exists in a partition, which is a
top-level root directory.  This is of interest because a file can't be
created in a partition that's larger than the available space in that
partition.

There are methods in \code{File} for exploring partitions.  The
methods \code{getFreeSpace()}, \code{getTotalSpace()}, and
\code{getUsableSpace()} return the respective amounts of space on the
partition as a \code{long} value.


\subsection{Comparison, Equality, and Hash Codes}\label{section:io-files-equality}

Equality of \code{File} objects is based on the underlying platform's
notion of equality.  For instance, on Windows, a file created with
\code{new File("Foo")} creates a file that is equal to \code{new
File("foo")}.  For better or worse, this comparison is based on the
platform's convention for file comparison, not by constructing a
canonical path and comparing that.  For instance, if I happen to
be running from directory \code{c:{\bk}lpb}, then 
\code{new File("foo")} is not equal to 
\code{c:{\bk}lpb{\bk}foo}, even though their canonical paths are
the same.


\subsection{Example Program Listing File Properties}

We wrote a simple program \code{FileProperties}, which given the name
of a file as an argument, lists all of its properties, its canonical
path, its URI form, and provides a listing if it is a directory.  The
code is just a litany of prints for all of the methods described above.

Calling it with the Ant target \code{file-properties}, it uses the
\code{file.in} Ant property to specify an argument.  We can call it
on its own source file using a relative path,
%
\commandlinefollow{ant -Dfile.in=src/com/lingpipe/book/io/FileProperties.java file-properties}
%
\begin{verbatim}
arg=|src/com/lingpipe/book/io/FileProperties.java|
toString()=src\com\lingpipe\book\io\FileProperties.java
getcanonicalFile()=C:\lpb\src\io\src\com\lingpipe\book\
     io\FileProperties.java
getName()=FileProperties.java
getParent()=src\com\lingpipe\book\io
toURI()=file:/c:/lpb/src/io/src/com/lingpipe/book/
     io/FileProperties.java
toURI().toURL()=file:/c:/lpb/src/io/src/com/lingpipe/
     book/io/FileProperties.java
exists()=true
isAbsolute()=false
isDirectory()=false
isFile()=true
isHidden()=false
hashCode()=-72025272
lastModified()=1279224002134
new Date(lastModified())=Thu Jul 15 16:00:02 EDT 2010
length()=2141
canRead()=true
canExecute()=true
canWrite()=true
getFreeSpace()=320493494272
getTotalSpace()=500105736192
getUsableSpace()=320493494272
listFiles()={    }
\end{verbatim}
%
The line breaks plus indents were inserted by hand so it'd fit in the
book.

\subsection{Creating, Deleting, and Modifying Files and Directories}

In addition to inspecting files, the \code{File} class lets you modify
files, too.  

Calling \code{createNewFile()} creates an empty file for the path
specified by the \code{File} on which it is called, returning
\code{true} if a new file was created and \code{false} if it already
existed.

The \code{delete()} method attempts to delete a file, returning
\code{true} if it's successful.  If applied to a directory, \code{delete()}
will only succeed if the directory is empty.  To get around this
limitation, LingPipe includes a static utility method \code{removeRecursive(File)} 
in the class \code{File} in package \code{com.aliasi.util}, which attempts
to remove a file and all of its descendants.

The properties of a file may be modified using, for example,
\code{setExecutable(boolean, boolean)} which attempts to make a file executable
for everyone or just the owner of the file.  Similar methods
are available for readability, writability and last modification date.

Files may be ranemd using \code{renameTo(File)}, which returns \code{true}
if it succeeds.  

The method \code{mkdir()} creates the directory corresponding to the file.
This method only creates the directory itself, so the parent must exist.
The method \code{mkdirs()} recursively creates the directory and all of its
parent directories.


\subsection{Temporary Files}

It is sometimes useful to create a temporary file.  One of the
properties used to create the Java virtual machine is a directory for
``temporary'' files.  

This is typically a platform default directory, like
\code{/tmp} in UNIX or \code{C:{\bk}WINNT{\bk}TEMP} on Windows, but it
may be configured when the JVM starts up.

The static \code{File} method \code{createTempFile(String,String)}
attempts to create a temporary file in the default temporary file with
the specified prefix and suffix, and it returns the file that's
created.  After the file is created, it will exist, but have length
zero.

The temporariness of the file doesn't mean it'll
be guaranteed to disappear.  It is a matter of whether you delete the
file yourself or whether the operating system occassionally cleans out
the temp directory.

Invoking the method \code{deleteOnExit()} on a file tells the
operating system that the file should be deleted when the JVM exits.
Unfortunately, this method is buggy on Windows, so should not be taken
as provided strong cross-platform guarantees.  It's always a good idea
to make sure to use a \code{finally} block to clear out temporary
files.  


\section{I/O Exceptions}\label{section:io-ioexception}

Almost all of the I/O operations are declared to throw
\code{IOException}, a checked exception in the \code{java.io} package.
Like all exceptions, I/O exceptions should not be ignored.  In most
cases, methods should simply pass on exceptions raised by methods they
call.  Thus most methods using I/O operations will themselves be
declared to throw \code{IOException}.  

At some point, a method will have to step up and do something with an
exception.  In a server, this may mean logging an error and continuing
on.  In a short-lived command-line program, it may mean terminating
the program and printing an informative error message.  

It is important to clean up system resources in a long-running
program.  Thus it is not uncommon to see code in a \code{try} with a
\code{finally} block to clean up even if an I/O exception is raised.

\subsection{Catching Subclass Exceptions} 

Some methods are declared to throw exceptions that are instances
of subclasses of \code{IOException}.  For instance, the constructor
\code{FileInputStream(File)} may throw a \code{FileNotFoundException}.

If you are passing on exceptions, don't fall into the trap of
passing just a general \code{IOException}.  Declare your method
to throw \code{FileNotFoundException} and to throw \code{IOException}.
This provides more information to clients of the method, who then have
the option to handle the exceptions generically at the \code{IOException}
level, or more specifically, such as for a \code{FileNotFoundException}.
It also helps readers of your Javadoc understand what specifically could
go wrong with their method calls.

In general, it's a good idea to catch subclasses of exceptions
separately so that error handling and error messages may be as
specific as possible.  If the methods called in the \code{try} block
are declared to throw the more general \code{IOException}, you'll

To do so, you need to declare the more specific catches first.  For
example, it's legal to write
%
\begin{verbatim}
try {
    in = new FileInputStream(file);
} catch (FileNotFoundException e) { 
    ...
} catch (IOException e) {
    ...
}
\end{verbatim}
%
but if you try to catch the I/O exception first, the compiler will gripe that the
\code{FileNotFoundException} has already been caught.



\section{Security and Security Exceptions}

Almost all of the I/O operations that attempt to read or modify a file
may also throw an unchecked \code{SecurityException} from the base
package \code{java.lang}. Typically, such exceptions are thrown when
a program attempts to overstep its permissions.

File security is managed through an instance of
\code{SecurityManager}, also in \code{java.lang}.  This is a very
flexible interface that is beyond the scope of this book.




\section{Input Streams}

The abstract class \code{InputStream} in \code{java.io} provides the
basic operations available to all byte input streams.  Concrete
input streams may be constructed in many ways, but they are all closed
through the \code{Closeable} interface (see \refsec{io-closeable}).

\subsection{Single Byte Reads}

A concrete extension of the \code{InputStream} class need only
implement the top-level \code{read()} method.  The \code{read()}
method uses the C programming language pattern of returning an integer
representing an unsigned byte value between 0 (inclusive) and 255
(inclusive) as the value read, or -1 if the end of stream has been
reached.

\subsection{Byte Array Reads}

It is usually too inefficient to access data one byte at a time.
Instead, it is usually accessed in blocks through an array.  The
\code{read(byte[])} method reads data into the specified byte array
and returns the number of bytes that have been read.  If the return
value is -1, the end of the input stream has been reached.  There is a
similar method that reads into a slice of an array given an offset
and length.

\subsection{Available Bytes}

The method \code{available()} returns an integer representing the
number of bytes available for reading without blocking.  This is not
the same as the number of bytes available.  For one thing, streams may
represent terabytes of data, and \code{available()} only returns an
integer.  More importantly, some streams may block waiting for more
input.  For instance, the standard input (see \refsec{io-stdin-stdout} may
block while waiting for user input and show no avaialable bytes, even
if bytes may later become available.  

Because no bytes may be available without blocking, it's possible for
the block read method to return after reading no bytes.  This does not
mean there won't be more bytes to read later.  The \code{read()}
methods will return -1 when there are truly no more bytes to be read.

\subsection{Mark and Reset}

The method \code{markSupported()} returns \code{true} for markable
input streams.  If a stream is markable, calling \code{mark()} sets
the mark at the current position in the stream.  A later call to
\code{reset()} resets the stream back to the marked position.

\subsection{Skipping}

There is also a method \code{skip(long)}, which attempts to skip past
the specified number of bytes, returning the number of bytes it
actually skipped.  The only reason to use this method is that it is
often faster than actually reading the bytes and then throwing them
away, because it skipping bypasses all the byte assignments that
would otherwise be required for a read.


\section{Output Streams}

The \code{OutputStream} abstract class in the package \code{java.io}
provides a general interface for writing bytes.  It is thus the
complement to \code{InputStream}.  Output streams implement the
\code{Closeable} interface, and should be closed in the same way
as other closeable objects (see \refsec{io-closeable}).

\code{OutputStream} itself implements the array writers in terms of
single byte writes, with the close and flush operations doing nothing.
Subclasses override some or all of these methods for additional
functionality or increased efficiency.


\subsection{Single Byte Writes}

A single abstract method needs to be implemented by concrete
subclasses, \code{write(int)}, which writes a byte in unsigned
notation to the output stream.  The low-order byte in the integer is
written and the three high-order bytes are simply ignored (see
\refsec{java-bytes} for more on the byte organization of integers).
Thus the value should be an unsigned representation of a byte between
0 (inclusive) and 255 (inclusive).

\subsection{Byte Array Writes}

Arrays of bytes may be written using the method \code{write(byte[])},
and a slice variant taking a byte array with a start position and
length.

The behavior is slightly different than for reads.  When a write
method returns, all of the bytes in the array (or specified slice
thereof) will have been written.  Thus it is not uncommon for array
writes to block if they need to wait for a resource such as a network,
file system, or user console input.

\subsection{Flushing Writes}

The method \code{flush()} writes any bytes that may be buffered
to their final destination.  As noted in the documentation, the
operating system may provide further buffering, for instance to
the network or to disk operations.  

The \code{OutputStream} class is defined to implement
\code{Flushable}, the interface in \code{java.io} for flushable
objects.  Like the general \code{close} method from the
\code{Closeable} interface, it may raise an \code{IOException}.

Most streams call the \code{flush()} method from their \code{close()}
method so that no data is left in the buffer as a result of closing
an object.


\section{Closing Streams}\label{section:io-closeable}

Because most streams impose local or system overhead on open I/O
streams, it is good practice to close a stream as soon as you are done
with it.  Conveniently, all the streams implement the handy
\code{Closeable} interface in the package \code{java.io}.  The
\code{Closeable} interface specifies a single method, \code{close()},
which closes a stream and releases any resources it may be
maintaining.  

Care must be taken in closing streams, as the \code{close()} method
itself may throw an \code{IOException}.  Furthermore, if the stream
wasn't successfully created, the variable to which it was being
assigned may be null.

The typical idiom for closing a \code{Closeable} may be illustrated
with an input stream
%
\begin{verbatim}
InputStream in = null;
try {
    in = new FileInputStream(file);
    ...
} finally {
    if (in != null) {
        in.close();
    }
}
\end{verbatim}
%
Sometimes, the close method itself is wrapped to suppress
warnings, as in
%
\begin{verbatim}
try {
    in.close();
} catch (IOException e) {
    /* ignore exception */
}
\end{verbatim}
%
Note that even if the close method is wrapped, the operations in the
try block may throw I/O exceptions.  To remove these, I/O exceptions
may be caught in a block parallel to the \code{try} and
\code{finally}.

\subsubsection{LingPipe Close Utility}

If a sequence of streams need to be closed, things get ugly quickly.
LingPipe provides a utility method \code{Streams.close(Closeable)} in
\code{com.aliasi.util} that tests for null and swallows I/O exceptions
for close operations.  Basically, it's defined as follows.
%
\begin{verbatim}
static void close(Closeable c) {
    if (c == null) return;
    try {
        c.close();
    } catch (IOException e) {
        /* ignore exception */
    }
}
\end{verbatim}
%
If you need to log stream closing exceptions, a similar method may
be implemented with logging in the catch operation and a message to
pass as an argument in the case of errors.


\section{Readers}

The \code{Reader} abstract base class is to \code{char} data as
\code{InputStream} is to \code{byte} data.  For instance,
\code{read()} reads a single \code{char} coded as an \code{int}, with
-1 indicating the end of the streamstream.  There is a block reading
method \code{read(char[])} that returns the number of values read,
with -1 indicating end of stream, and a similar method taking a slice
of an array of \code{char} values.  There is also a \code{skip(int)}
method that skips up to the specified number of \code{char} values,
returning the number of values skipped.  The \code{Reader} class
implements the \code{Closeable} interface, and like streams, have a
single \code{close()} method.  All of these methods are declared to
throw \code{IOException}.

Unlike input streams, concrete subclasses must implement the abstract
methods \code{close()} and the slice-based bulk read method
\code{read(char[],int,int)}.

Some readers are markable, as indicated by the same
\code{markSupported()} method, with the same \code{mark()} method to
set the mark at the current position and \code{reset()} method to
return to the marked position.

\subsection{The \code{Readable} Interface}

The \code{Reader} class also implements the \code{Readable} interface
in \code{java.lang}.  This interface has a single method
\code{read(CharBuffer)} that reads \code{char} values into a specified
buffer, returning the number of values read or -1 for end of stream
(see \refsec{char-charbuffer} for more on \code{CharBuffer}).


\section{Writers}




\section{File Input and Output Streams}

Streaming access to files is handled by the subclasses
\code{FileInputStream} and \code{FileOutputStream}, which
extned the obvious base classes.  

\subsection{Constructing File Streams}

A file input stream may be constructed with either a file using the
constructor \code{FileInputStream(File)} or the name of a file, using
\code{FileInputStream(String)}.  

Similarly, output streams may be constructed using
\code{FileOuptutStream(File)} and \code{FileOuptutStream(String)}.
If constructed this way, if the file exists, it will be overwritten
and resized to the output produced by the output stream.  To append
to a file, construct an output stream using
\code{FileOuptutStream(File,boolean)}, where the boolean flag
specifies whether or not to append.

The constructors are declared to throw the checked exception
\code{FileNotFoundException}, in package \code{java.io}, which is a
subcclass of \code{IOException}.  

\subsection{Finalizers}

Both the input and output file streams declare finalizer methods which
may release any system resources when the related stream is no longer
in scope.  The problem with finalization is that it's not guaranteed
to happen until the JVM on which the code was running is terminated.
In any case, whether it exits normally or not, the operating system
will recover any process-specific file handles.



\subsection{File Descriptors}\label{section:io-file-descriptors}

The \code{FileDescriptor} class in \code{java.io} provides an
encapsulation of a file input or output stream.  Every time a file
input or output stream is created, it has an associated file
descriptor.  The file descriptor may be retrieved from a file input
stream or file output stream using the method \code{getFD()}.  A new
input or output stream may be constructed based on a file descriptor.

\subsection{Examples of File Streams}


\subsubsection{Counting the Bytes in a File}\label{section:io-file-byte-count}

We wrote a demo program \code{FileByteCount} that opens a file input
stream and then reads all of its content, counting the number of
instances of each byte.  The work is done with
%
\codeblock{FileByteCount.1}
%
Note that the \code{main()} method is declared to throw both
a \code{FileNotFoundException} and its superclass
\code{IOException} (see \refsec{io-ioexception} for more information
on I/O exceptions and their handling).  

The body of the method creates an instance of \code{File} using the
command-line argument, then an input stream, based on the file.  It
then allocates an array of \code{long} values the size of the number
of bytes, which is used to store the counts (recall that primitive
numbers are always initialized to 0 in Java, including in arrays).
Then we use the C-style read method to read each bye into the integer
variable \code{b}.  If the value is -1, indicating the end of stream
(end of file here), the loop is exited.  In the body of the read loop,
the count for the byte just read is incremented.

We call the method using the Ant target \code{file-byte-count}, 
specifying the \code{file.in} property for the file to be counted. 
Here we call it on its own source code,
%
\commandlinefollow{ant -Dfile.in=src/com/lingpipe/book/io/FileByteCount.java file-byte-count}
\begin{verbatim}
Dec  Hex      Count
 10    a         33
 32   20        189
 33   21          1
...
123   7b          2
125   7d          2
\end{verbatim}
%
Because the file is encoded in ASCII, these bytes can be read as
characters.  For instance, character hexadecimal value 0A is the
linefeed, 20 is a newline, 32 is the digit 2, up through 7D, which is
the right curly bracket (\code{\}}).  We can infer that the file has
34 lines, because there are 33 line feeds.  

\subsubsection{Copying from One File to Another}\label{section:io-copy-file}

Our next sample program, \code{CopyFile}, copies the bytes in one file
into another file and illustrates the use of array-based reads and
writes.%
%
\footnote{The same functionality is available through the LingPipe
static utility method \code{copyFile(File,File)} from the \code{Files}
class in \code{com.aliasi.util}.}
%
After reading in the command-line arguments, the work is carried out by
%
\codeblock{CopyFile.1}
%
We first create the file input and output streams.  We've assigned
them to variables of type \code{InputStream} and \code{OutputStream}
rather than to their specific subclasses because we do not need any of
the functionality specific to file streams.  We then allocate an array
\code{buf} of bytes to act as a buffer and declare a variable \code{n} to hold
the count of the number of bytes read.  The loop continually reads
from the input stream into the buffer, assigning the number of bytes
read to \code{n}, and exiting the loop if the number of bytes read is
less than zero (signaling end of stream).  In the body of the loop, we
write the bytes in the buffer to the output stream, being careful to
specify that we only want to write \code{n} bytes.  Unlike reads,
writes either succeed in writing all their bytes (perhaps having to
block), or throw an exception.  When we're done, we close both streams.%
%
\footnote{We don't need elaborate try-finally logic to close
the file streams because they are closed automatically when the
command-line program exits.  We could get into trouble if another
program were to call this \code{main()} without exiting the JVM after
the call.  A more robust version of this program might catch I/O
exceptions thrown by the write method and delete the output stream
rather than leaving a partial copy.  We've shown what this would look
like in the source file for \code{CopyFile} in a parallel method
named \code{main2()}.}






\section{Buffered Streams}

Some sources of input, such as an HTTP connection or a file, are most
efficiently dealt with in larger chunks than a single byte.  In most
cases, when using such streams, it is more efficient to buffer the
input or output.  To that end, streams that buffer larger chunks of
input are available through the classes \code{BufferedInputStream} and
\code{BufferedOutputStream}. 

\subsection{Constructing Buffered Streams}

The buffered byte streams have constructors
\code{BufferedInputStream(InputStream,int)} and
\code{BufferedOutputStream(OutputStream,int)} that wrap a specified
stream and use a buffer of the specified size to hold bytes.  
The buffer sizes may be dropped, in which case a default size is used.

For example, we may created a buffered input stream from
a file input stream using
%
\begin{verbatim}
File file = ...;
InputStream in = new FileInputStream(file);
InputStream bufIn = new BufferedInputStream(in);
\end{verbatim}
%
The variable \code{bufIn} is then used where the unbuffered stream
\code{in} would've been used.  By assigning all these streams of
different types to a base \code{InputStream}, it makes it easier to
change the code later.

There is often a measurable performance improvement from getting the
buffer size right for the underlying platform and application, but
performance measurement is a tricky business (see
\refsec{reading-java} for recommended reading on performance tuning).

The constructors only save a pointer to the underlying stream and
create a buffer, so they don't throw I/O exceptions, because they're
not doing any I/O.

\subsection{Built-in Buffering}

Many of the streams (or readers and writers) have built-in buffering.
For instance, the GZIP input and output streams have built-in buffers.
In these cases, there's no need to buffer twice for efficiency's sake.

If you are eventually going to wrap a byte stream in a buffered
reader or writer, the byte stream doesn't itself need to be buffered.
The buffering, though use of block reads and writes, carries itself through.

Similarly, if your own code does buffering, as in our example in
\code{CopyFile} (see \refsec{io-copy-file}), there's no need to buffer
the file input or output streams.


\section{Array-Backed Streams}


\section{Compressed Streams}


\section{Accessing Resources from the Classpath}



\section{Print Streams and Formatted Output}\label{section:io-printstream-format}

A print stream is a very flexible output stream that supports standard
stream output, conversion of characters to bytes for output, and
structured C-style formatting.  This provides most of the
functionality of a \code{Writer}'s methods, while extending the base
class \code{InputStream}.%
%
\footnote{It's not possible in Java to be both a \code{Writer} and a
  \code{InputStream} because these are both abstract base classes, and
  a class may only extend one other class.  In retrospect, it'd be
  much more convenient if the streams were all defined as interfaces.}

\subsection{Constructing a Print Stream}

A print stream may be constructed by wrapping another input stream or
providing a file to which output should be written.  The character
encoding and whether auto-flushing should be carried out may also be
specified.  We recommend restricting your attention to the
constructors \code{PrintStream(File,String)} that writes to a file
given a specified encoding, and
\code{PrintStream(OutputStream,boolean,String)}, which prints to the
specified output stream, optionally using auto-flushing, using a
specified character encoding.  The othe methods are shorthands that
allow some parameters to be dropped.

\subsection{Exception Buffering}

The second unusual feature of print streams is that none of their
methods is declared to throw an I/O exception.  Instead, what it does
is implement an exception buffering pattern, only without an actual
buffer.%
%
\footnote{This pattern is sometimes implemented so
that the actual exceptions that were raised are accessible as a list.}
%
In cases where other streams would raise an I/O exception, the print
stream methods exit quietly, while at the same time setting an error
flag.  The status of this flag is available through the method
\code{checkError()}, which returns \code{true} if a method has caught
an I/O exception.

\subsection{Formatted Output}

One of the most convenient aspects of print streams is their
implementation of C-style \code{printf()} methods for formatted
printing.  These methods implicitly use an instance of
\code{Formatter} in \code{java.util} to convert a sequence of objects
into a string.  

Format syntax is very elaborate, and for the most part, we restrict
our attention to a few operations.  The method's signature is
\code{printf(Locale,String,Object...)}, where the string is the
formatting string and the variable-length argument \code{Object...}
is zero or more objects to format.  How the objects are formatted
depends on the format string and the \code{Locale} (from
\code{java.util}).  The locale is optional; if it is not supplied, the
default locale will be used.  The locale impacts the printing of
things like dates and decimal numbers, which are conventionally
printed differently in different places.  Although we are obsessive
about maintaining unadulterated character data and work in many
languages, a discussion of the intricacies f application
internationalization is beyond the scope of this book.

For example, the sample program \code{FileByteCount} (see
\refsec{io-file-byte-count}) uses string, decimal and hexadecimal
formatting for strings and numbers,
%
\codeblock{FileByteCount.2}
%
The first \code{printf()} has the format string
\code{"\%4s~\%4s~\%10s{\bk}n"}, which says to write the first string
using 4 characters, the second string using 4 characters, and the
third string using 10 characters; if they are too short, they align to
the right, and if they are too long, they run over their alloted
space.  The second \code{printf()} uses \code{\%4d} for a four place
integer (right aligned), and \code{\%4h} for a four-digit hexadecimal
representation.  Note that auto-boxing (see \refsec{java-autoboxing})
converts the integers \code{i} and \code{counts[i]} to instances of
\code{Integer} to act as inputs to \code{printf()}.  Formatted prints
do not automatically occupy a line; we have manually added UNIX-style
line boundary with the line feed character escape \code{{\bk}n}.

Finally, note that the two \code{printf()} statements
intentionally use the same width so the output is formatted like a table
with headings aligned above the columns.  


\section{Standard Input, Output, and Error Streams}\label{section:io-stdin-stdout}

In many contexts, the environment in which a program is executed
provides streams for input, output, and error messages.  These streams
are known as standard input, standard output, and standard error.
Standard UNIX pipelines direct these streams in two ways.  They can
direct the standard input to be read from a file or the standard
output or error to be written to a file.  Second, they can pipe
processes together, so that the standard output from one process is
used for the standard input of the next process.
Shell scripts and scripting languages such as Python manage standard
input and output from processes in a similar way to shells.%
%
\footnote{Java provides an implementation of Unix-style pipes through
  piped streams and readers and writers.  These are based on the
  classes \code{PipedInputStream}, \code{PipedOutputStream},
  \code{PipedReader}, and \code{PipedWriter} in the standard
  \code{java.io} package.  These classes are multi-threaded so that
  they may asynchronously consume the output of one process to provide
  the input to the next, blocking if need be to wait for a read or write.}
%

\subsection{Accessing the Streams}

Java provides access to these streams through three static variables
in the class \code{System} in the package \code{java.lang}.  The
variable \code{System.in} is of type \code{InputStream}
and may be used to read bytes from the shell's standard input.  The
standard and error output streams, \code{System.out} and
\code{System.err}, are provided constants of type \code{PrintStream}
(see \refsec{io-printstream} for more information on print streams).
The standard output and error print streams use the platform's
default encoding (see below for how to reset this).

\subsection{Redirecting the Streams}

The standard input and output streams may be reset using the methods
\code{setIn(InputStream)}, \code{setOut(PrintStream)} and
\code{setErr(PrintStream)}.  This is convenient for writing Java
programs that act like Python or shell scripts.  

The mutability of the output and error streams enables a Java program
to reset their character encodings.  For example, to reset standard
output to use UTF-8, insert the following statement before any
output is produced,
%
\begin{verbatim}
System.setOut(new PrintStream(System.out,true,"UTF-8"));
\end{verbatim}
%
The value \code{true} enables auto-flushing.  The new standard
output wraps the old standard output in a new print stream
with the desired encoding. 

The output streams may be similarly redirected to files by using a
\code{PrintStream} constructed from a file in the same way.  For
example,
%
\begin{verbatim}
System.setErr(new PrintStream("stdout.utf8.txt","UTF-16BE"));
\end{verbatim}
%
sends anyting the program writes to the standard error stream to the
file \code{stdout.utf8.txt}, using the UTF-16BE character encoding
to convert characters to bytes.

The standard input stream may be wrapped in an
\code{InputStreamReader} or \code{BufferedReader} to interpret byte
inputs as characters.  Standard output and error may be wrapped in the
same way, which is an alternative to resetting the streams.



\section{URIs, URLs and URNs}\label{section:uri-url-urn}

A uniform resource identifier (URI) picks out something on the web by
name.  This is a very general notion, but we will only need a few
instances in this book.  The specifications for these standards are
quite complex, and beyond the scope of this book.  

\subsection{Uniform Resource Names}

There are two (overlapping) subtypes of URIs, based on function.  A
uniform resource name (URN) is a URI that provides a name for
something on the web, but may not say how or where to get it.  A
typical instance of a URN is the Digital Object Identifier (DOI)
system, which is becoming more and more widely used to identify text
resources such as journal articles.  For example, the DOI
\code{doi:10.1016/j.jbi.2003.10.001} picks out a paper on which my
wife was a co-author.  An alternative URN for the same paper is
\code{PMID:15016385}, which uses the PubMed identifier (PMID) for the
paper.

\subsection{Uniform Resource Locators}

A uniform resource locator (URL) provides a means of locating (a
concrete instance of) an item on the web.  A URL indicates how to get
something by providing a scheme name, such as \code{file://} for files
or \code{http://} for the hypertext transport protocol (HTTP).  For
example, the URL
\code{http://dx.doi.org/10.1016/j.jbi.2003.10.001} is for the same
paper as above, but specifies a web protocol, HTTP, and host,
\code{dx.doi.org} from which to fetch a specific embodiment of
the resource.  There may be many URLs that point to the same object.
For instance, \code{http://linkinghub.elsevier.com/retrieve/pii/S1532046403001126}
is a URL for the same paper, which links to the publisher's site.

\subsection{URIs and URLs in Java}

The standard \code{java.net} package has a class \code{URI} for URIs
and a class \code{URL} for URLs.  Both of them may be constructed
using a string representation of the resource.  Once constructed, the
classes provide a range of structured access to the fields making up
the resource.  For instance, both objects have methods such as
\code{getHost()} and \code{getPort()}, which may return proper values
or indicators like \code{null} or -1 that there is no host or port.

The demo program \code{UrlProperties} constructs a URL from a
command-line argument and prints out its available properties.  The
beginning of the \code{main()} method is
%
\codeblock{UrlProperties.1}
%
The rest of the program just prints out the rest of the properties.
The \code{main()} method throws a \code{MalformedURLException}, a
subclass of \code{IOException}, if the URL specified on the command
line is not well formed.  This ensures that once a URL is constructed,
it is well formed.  There are no exceptions to catch for the get
methods; they operate only on the string representations and are
guaranteed to succeed if the URL was constructed.

The Ant target \code{url-properties} calls the command supplying as
an argument the value of the property \code{url.in}.
%
\commandlinefollow{ant -Durl.in="http://google.com/webhp?q=dirichlet" url-properties}
\begin{verbatim}
getAuthority()=google.com
getDefaultPort()=80
getFile()=/webhp?q=dirichlet
getHost()=google.com
getPath()=/webhp
getPort()=-1
getProtocol()=http
getQuery()=q=dirichlet
getRef()=null
getUserInfo()=null
toExternalForm()=http://google.com/webhp?q=dirichlet
toString()=http://google.com/webhp?q=dirichlet
\end{verbatim}
%
Looking over the output shows how the URL is parsed into components
suc as host, path and query.

\subsection{Reading from URLs}

URLs know how to access resources.  These resources may reside locally
or remotely.  Wherever they arise, and whatever their content, 
resources are all coded as byte streams.  Java provides built-in support
for protocols \code{http}, \code{https}, \code{ftp}, \code{file}, and 
\code{jar}.  

Once a URL is created, the method \code{openStream()} returns an
\code{InputStream} that may be used to read the bytes from the URL.
Depending on the URL itself, these bytes may be from a local or
networked file, a local or remote web server, or elsewhere.  Opening
the stream may throw an I/O exception, as a connection is opened to
the URL.  Once the input stream is opened, it may be used like
any other stream.  

The sample program \code{ReadUrl} shows how to read the
bytes from an URL and relay them to standard output.
%
\codeblock{ReadUrl.1}
%
The code between the stream creation and its closing is just a generic
buffered stream copy.  

The Ant target \code{read-url} is configured to call the sample
program using as URL the value of the property \code{url.in}.
%
\commandlinefollow{ant -Durl.in=http://lingpipe.com url-read}
\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html ...
<html ...
<head>
<title>LingPipe Home</title>
<meta http-equiv="Content-type"
      content="application/xhtml+xml; charset=utf-8"/>
...
pageTracker._trackPageview();
} catch(err) {}</script></body>
</html>
\end{verbatim}
%
As with most pages these days, LingPipe's home page starts with
a title, content type, and cascading stylesheet (CSS) declaration,
and ends with some Javascript.  
Whether you can see all of the output of a page depends on your
shell; you can save the output to a file and then view it in a
browser.  

\subsection{URL Connections}

The output stream method we used above, \code{getOutputStream()}, is
just a convenience method for calling the \code{openConnection()}
method to get an instance of \code{URLConnection} and calling its
\code{getOutputStream()} method.  URL connections allow various
properties of the connection to be inspected and set.  

Although the \code{URL} method \code{openConnection()} is declared to
return a \code{URLConenction}, if the URL uses the HTTP protocol, the
documentation specifies that a \code{HttpURLConnection} will be
returned.  Thus the \code{URLConnection} may be cast to
\code{HttpURLConnection} at run time.  The HTTP-based connection
provides additional methods for manipulating HTTP headers and
responses, such as content types, last-modified dates, character
encodings, handling redirected web pages, fetching HTTP respose codes,
managing timeouts and keep-alive times for the connection, and other
intricacies of HTTP management.

A URL connection may also be used to write to a URL.  This makes it
possible to attach data for a POST-based request and thus implement
general web services.


\section{The Input Source Abstraction}


\section{File Channels and Memory Mapped Files}

As an alternative to streaming I/O, memory mapping essentially
provides a random access interface for files.  The method is by
providing an array-like access abstraction on top of files.  It is
then up to the operating system's file manager to deal with actual
commits to and reads from disk.

Memory mapped files are great for random access to data on disk.  For
instance, databases and search engines make heavy use of memory
mapping.

Both the file input and file output stream classes implement a
\code{getChannel()} method which returns an instance of
\code{FileChannel}.  File channels are part of the ``new'' I/O,
rooted at package name \code{java.nio}, specifically in the
package \code{java.nio.channels}.  

File channels support reading and writing into \code{ByteBuffer}
instances.  Byte buffers and other buffers are in the \code{java.nio}
package.  Byte buffers may be wrapped to act as character buffers or
other primitive type buffers.  See \refsec{char-charbuffer} for a
basic overview of buffers focusing on character buffers.

File channels may also be used to produce a \code{MappedByteBuffer},
which creates a memory-mapped file accessible as a \code{ByteBuffer}.
The other way to create a file channel which may be used to produce a
memory mapped buffer is through the \code{RandomAccessFile} class in
\code{java.io}.  The random access file class implements the
\code{DataInput} and \code{DataOutput} interfaces, which provide utilities
to write arbitrary primitives and strings in addition to bytes.


\section{Lingpipe I/O Utilities}