\chapter{Regular Expressions}\label{chapter:regex}

Generalized regular expressions, as implemented in Java and all the
scripting languages like Perl and Python, provide a general means for
describing spans of Unicode text.  Given a regular expression (regex)
and some text, basic regex functionality allows us to test whether a
string matches the regex or find non-overlapping substrings of a
string matching the regex.

\section{Matching and Finding}

Despite the rich functionality of regexes, Java's
\code{java.util.regex} package contains only two classes,
\code{Pattern} and \code{Matcher}.  An instance of \code{Pattern}
provides an immutable representation of a regular expression.  An
instance of \code{Matcher} represents the state of the matching of a
regular expression against a string.

\subsection{Matching Entire Strings}

It's easiest to start with an example of using a regular expression
for matching, which we wrote as a
\code{main()} method in the class \code{RegexMatch}, the work of
which is done by
%
\codeblock{RegexMatch.1}
%
First, we read the regex from the first command-line argument, then
the text from the second argument.  We then use the regular expression
to compile a pattern, using the static factory method
\code{pattern.compile()}.  This pattern is reusable.  We next
create a matcher instance, using the method \code{matcher()} on the
pattern we just created.  Finally, we assign a boolean variable
\code{matches} the value of calling the method \code{matches()} 
on the matcher.  And then we print out the result.

Regular expressions may consist of strings, in which case they
simply carry out exact string matching.  For example, the regex
\code{aab} does not match the string \stringmention{aabb}.  
There is an Ant target \code{regex-match} which feeds the command-line
arguments to our program.  For the example at hand, we have
%
\commandlinefollow{ant -Dregex="aab" -Dtext="aabb" regex-match}
\begin{verbatim}
Regex=|aab|    Text=|aabb|    Matches=false
\end{verbatim}
%
On the other hand, the regex \code{abc} does match
the string \stringmention{abc}.
%
\commandlinefollow{ant -Dregex="abc" -Dtext="abc" regex-match}
\begin{verbatim}
Regex=|abc|    Text=|abc|    Matches=true
\end{verbatim}
%
Note that we have used the vertical bar to mark the boundaries of the
regular expression and text in our output.  These vertical bars are
not part of the regular expression or the text.  This is a useful
trick in situations where space may appear as the prefix or suffix of
a string.  It may get confusing if there is a vertical bar within the
string, but the outer vertical bars are always the ones dropped.

\subsection{Finding Matching Substrings}

The second main application of regular expressions is to find
substrings of a string that match the regular expression.  The main
method in our class \code{RegexFind} illustrates this.  We read in two
command-line aguments into string variables \code{regex} and \code{text}
as we did for \code{RegexMatch} in the previous section.  We begin
by compling the pattern and creating a matcher for the text just
as in \code{RegexFind}.
%
\codeblock{RegexFind.1}
%
The first call of the \code{find()} method on a matcher returns
\code{true} if there is a substring of the text that matches the
pattern.  If \code{find()} returned \code{true}, then the are method
\code{group()} returns the substring that matched, and the methods
\code{start()} and \code{end()} return the span of the match, which is
from the start (inclusive) to the end (exclusive).

Subsequent calls to \code{find()} return \code{true} if there is a
match starting on or after the end position of the previous calls.
Thus the loop structure in the program above is the standard idiom
for enumerating all the matches.  

As an example, we use the Ant target \code{regex-find}, which takes
the same arguments as \code{regex-match}.
%
\commandlinefollow{ant -Dregex=aa -Dtext=aaaaab regex-find}
%
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%
As before, the vertical bars are delimeters, not part of the matching
substring.  The string \stringmention{aa} actually shows up in four
distinct locations in \stringmention{aaaaab}, at spans (0,2), (1,3),
(2,4), and (3,5).  Running find only returns two of them.  The matcher
works from the start to the end of the string, returning the first
match it finds after the first call to \code{find()}.  In this case,
that's the substring of \stringmention{aaaaab} spanning (0,2).  The
second call to \code{find()} starts looking for a match at position 2,
succeeding with the span (2,4).  Next, it starts looking at position
4, but there is no substring starting on or after position 4 that
matches \stringmention{aa}.


\section{Character Regexes}

The most basic regular expressions describe single characters.  Some
characters have special meanings in regexes and thus need to be
escaped for use in regular expresions.

\subsection{Characters as Regexes}

A single character may be used a regular expression.  A regular
expression consisting of a single character only matches that single
character.  For instance,
\code{Pattern.compile("a").matcher("a").matches()} would evaluate to
\code{true}.  Using our Ant match target, 
%
\commandlinefollow{ant -Dregex=b -Dtext=b regex-match}
\begin{verbatim}
Regex=|b|    Text=|b|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=b -Dtext=c regex-match}
\begin{verbatim}
Regex=|b|    Text=|c|    Matches=false
\end{verbatim}
%
Within a Java program, Java character literals may be used within the
string denoting the regex.  For instance, we may write
\code{Pattern.compile("{\bk}u00E9")} to compile the regular expression
that matches the character \unicode{00E9}, \unicodedesc{latin small e
  with acute}, which would be written as \charmention{\'e}.

\subsection{Unicode Escapes}

Arbitrary unicode characters may be escaped in the same way as in
Java.  That is, \code{{\bk}u}\codeVar{hhhh} is a regular expression
matching the character with Unicode code point
\unicode{\codeVar{hhhh}}.  For example,
%
\commandlinefollow{ant -Dregex={\bk}u0041 -Dtext=A regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%
Note that we did not have to escape the backslash for the shell
because the following character, \code{u}, is not an escape.  Unicode
escapes are useful for for matching the period character,
\unicode{002E}, \unicodedesc{full stop}, which is a reserved character
in regexes representing wildcards (see \refsec{regex-wildcard}).
%
\commandlinefollow{ant -Dregex="{\bk}u002E" -Dtext="." regex-match}
%
\begin{verbatim}
Regex=|\u002E|    Text=|.|    Matches=true
\end{verbatim}
%

In a Java program, we'd still have to write
\code{Pattern.compile("{\bk}{\bk}u002E")}.  

Unicode escapes in regexes are confusing, because they use the same
syntax as Java unicode literals.  Further complicating matters, the
literal for backslashes in Java programs is itself an escape sequence,
\code{{\bk}{\bk}}.  There is a world of difference between the
patterns produced by \code{Pattern.compile("{\bk}u002E")} and
\code{Pattern.compile("{\bk}{\bk}u002E")}.  The former is the same
as \code{Patten.compile(".")}, and matches any character, whereas
the latter uses a regex escape, and only matches the period
character.

\subsection{Other Escapes}

There are also other built-in escapes, such as \code{{\bk}n} for
newline and \code{\bk\bk} for a backslash character.  Again, we have
to be careful about distinguishing Java string escapes, which are used
to create a regex, which itself may contain regex escapes.  

To confuse matters, Java itself also uses a backslash for escapes, so
that the character for backslash is written \code{'\bk\bk'} and so the
regex \code{{\bk}n} must be written as the string literal
\code{"\bk{\bk}n"}.  To create the regex \code{\bk\bk}, we need to use
two backslash escapes in our string literal, writing
\code{Pattern.compile("\bk\bk\bk\bk")}.  

This is all further confused by the command-line shell, which has its
own escape sequences.  Our sample program reads a command from the
command line, which is being supplied by Ant and set as a property on
the command-line call to Ant.  For instance, consider this puzzler,
%
\commandlinefollow{ant -Dregex="\bk\bk\bk\bk" -Dtext="\bk\bk" regex-match}
%
\begin{verbatim}
Regex=|\\|    Text=|\|    Matches=true
\end{verbatim}
%
On the command line, backslash is escaped as \code{\bk\bk}.%
%
\footnote{Usually backslash doesn't need to be escaped because the
following character isn't a valid escape; here, the following
character is a quote (\code{"}), and \code{\bk"} is a valid escape
sequence for the shell.}
%
Our Java program gets a value for \code{regex} consisting of a
length-two string made up of two backslashes, and value for text
consisting of a single backslash.  The match succeeds because the
regex \code{\bk\bk} is the escaped backslash character, which matches
a single backslash.


\section{Character Classes}

Regular expressions provide a range of built-in character classes
based on ASCII or Unicode, as well as the ability to define new
classes.  Each character class matches a set of characters.  The
reason to use classes rather than disjunctions is that they have


\subsection{WildCards}\label{section:regex-wildcard}

A singe period (\code{.}) is a regular expression that matches any
single characer.  We may think of it as the universal character class.
For instance, the regex \code{.} matches the string \stringmention{a},
and \code{a.c} matches \stringmention{abc}.%
%
\commandlinefollow{ant -Dregex=a.c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|a.c|    Text=|abc|    Matches=true
\end{verbatim}
%

Whether or not a wildcard matches an end-of-line sequence depends on
whether or not the \code{DOTALL} flag is set (see
\refsec{pattern-modes}); if it is set, the wildcard matches
end-of-line sequences.  The following two expressions evaluate to
\code{true},
%
\begin{verbatim}
Pattern.compile(".").matcher("A").matches()
Pattern.compile(".",DOTALL).matcher("\n").matches()
\end{verbatim}
%
whereas the following expression evaluates to \code{false},
%
\begin{verbatim}
Pattern.compile(".").matcher("\n").matches()
\end{verbatim}

\subsection{Unicode Classes}

Unicode defines a range of categories for characters, such as the
category \code{Lu} of uppercase letters (see
\refsec{unicode-categories} for more information).  The regular
expression \code{p\{\codeVar{X}\}} matches any unicode character
belonging to the Unicode category \codeVar{X}.  For example,
the class \code{Lu} picks out uppercase letters, so we have
%
\commandlinefollow{ant -Dregex={\bk}p\{Lu\} -Dtext=A regex-match}
\begin{verbatim}
Regex=|\p{Lu}|    Text=|A|    Matches=true
\end{verbatim}
%


\subsection{ASCII Classes}

There are character classes built in for ASCII characters.  For
instance, \code{{\bk}d} is for digits, \code{{\bk}s} for whitespace,
and \code{{\bk}w} for alphanumeric characters.  For example,
%
\commandlinefollow{ant -Dregex={\bk}d -Dtext=7 regex-match}
\begin{verbatim}
Regex=|\d|    Text=|7|    Matches=true
\end{verbatim}
%
For these three ASCII classes, the capitalized forms match
ASCII characters that don't match the lowercase forms.  So
\code{{\bk}D} matches non-digits, \code{{\bk}S} non whitespace,
and \code{{\bk}W} non-alphanumeric characters.

There are a range of built-in ASCII classes from the POSIX standard
built in.  They use the same syntax as the Unicode classes described
in the previous section.  For example, \code{{\bk}p\{ASCII\}} matches
any ASCII character and \code{{\bk}p\{Punct\}} for ASCII punctuation
characters.

The ASCII characters must be used with care, because they will not
have their described behavior when interpreted over all of Unicode.
For example, there are whitespaces in Unicode that don't match
\code{{\bk}s} and digits that don't match \code{{\bk}d}.

\subsection{Compound Character Classes}

Character classes may be built up from single characters and/or other
character classes using set operations like union, intersection, and
negation.

The syntax for compound character classes uses brackets around a
character class expression.  The atomic character class expressions
are single characters like \code{a}, and the character class escapes
like \code{{\bk}p\{Lu\}} for is any uppercase Unicode character.
Compound character classes may also be nested.  For example,


Character classes may be unioned, which confusingly uses a
concatenation syntax.  For instance, \code{[aeiou]} is the character
class picking out the ASCII vowels.  It is composed of the union of
character class expressions \code{a}, \code{e}, \ldots, \code{u}.  
%
\commandlinefollow{ant -Dregex="[aeiou]" -Dtext=i regex-match}
\begin{verbatim}
Regex=|[abc]|    Text=|i|    Matches=true
\end{verbatim}
%
Class escapes may be used, so that \code{[{\bk}p\{Lu\}{\bk}p\{N\}]}
picks out upper case letters and numbers.

The use of range notation may be used as shorthand for unions.
For instance, \code{[0-9]} picks out the ASCII digits \charmention{0},
\charmention{1}, \ldots, \charmention{9}.  For example,
%
\commandlinefollow{ant -Dregex="[I-P]" -Dtext=J regex-match}
\begin{verbatim}
Regex=|[I-P]|    Text=|J|    Matches=true
\end{verbatim}

Character classes may be complemented.  The syntax involves a caret,
with \code{[\^{}\codeVar{A}]} picking out the class of characters not
in class \codeVar{A}.  The expression \codeVar{A} must be either a
range or a sequence of character class primitives.  For instance,
\code{[\^{}z]} represents the class of every character other than
\charmention{z}.  
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext=z regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|z|    Matches=false
\end{verbatim}
%
\commandlinefollow{ant -Dregex="[\^{}z]" -Dtext=a regex-match}
\begin{verbatim}
Regex=|[^z]|    Text=|a|    Matches=true
\end{verbatim}
%
Unlike the usual rules governing the logical operations disjunction,
conjunction, and negation, the character class complementation
operator binds more weakly than union.  Thus \code{[\^{}aeiou]} picks
out every character that is not an ASCII vowel.

Character classes may also be intersected.  The syntax is the same as
for logical conjunction, with \code{[\codeVar{A}\&\&\codeVar{B}]}
picking out the characters that are in the classes denoted by both
\codeVar{A} and \codeVar{B}.  For instance, we could write
\code{[[a-z]\&\&[\^{}aeiou]]} to pick out all ASCII characters other
than the vowels,
%
\commandlinefollow{ant -Dregex="[[a-z]\&\&[\^{}aeiou]]" -Dtext=i regex-match}
\begin{verbatim}
Regex=|[[a-z]&&[^aeiou]]|    Text=|i|    Matches=false
\end{verbatim}

As described in the Javadoc for \code{Pattern}, the order of
attachment for character class operations is
%
\begin{center}
\begin{tabular}{rll}
\tblhead{Order} & \tblhead{Expression} & \tblhead{Example} 
\\ \hline
1 & Literal Escape & \code{{\bk}x}
\\
2 & Grouping & \code{[...]} 
\\
3 & Range & \code{0-9}
\\
4 & Union & \code{ab}, \code{[0-9][ab]}, 
\\
5 & Intersection & \code{[a-z\&\&[aeiou]]}
\end{tabular}
\end{center}
%
Thus the square brackets act like grouping parentheses for character
classes.  Complementaton must be treated separately.  Complementation
only applies to character groups or ranges, and must be closed within
brackets before being combined with union or intersection or the scope
may not be what you expect.  For instance, \code{[\^{}a[b-c]]} is
not equivalent to \code{[\^{}abc]}, but rather is equivalent to
\code{[[\^{}a][b-c]]}.


\section{Concatenation}

As we saw in our early examples, characters may be concatenated
together to form a regular expression that matches the string.  This
is not the same operation as character classes, which confusingly
uses the same notation.  

With a list of objects being concatenated, the boundary condition is
an empty list, which is why we start this section with a discussion of
the empty regex.

\subsection{Empty Regex}

The simplest regular expression is the empty regular expression.  It
only matches the empty string.  For example, the expression
\code{Pattern.compile("").matcher("").matches()} would evaluate to
\code{true}.  Using our test code from the command-line proves tricky,
because we have to escape the quotes if we want to assign environment
variables, as in 
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext={\bk}"{\bk}"  regex-match}
\begin{verbatim}
Regex=||    Text=||    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex={\bk}"{\bk}" -Dtext=a regex-match}
\begin{verbatim}
Regex=||    Text=|a|    Matches=false
\end{verbatim}


\subsection{Concatenation}

Two regular expressions \codeVar{x} and \codeVar{y} may be
concatenated to produce a compound regular expression \codeVar{xy}.
The regex \codeVar{xy} matches any string that can be decomposed into
a string that matches \codeVar{x} followed by a string that matches
\codeVar{y}.  For example, if we have a regex \code{[aeiou]} that
matches vowels and a regex \code{0-9} that matches digits, we can put
them together to produce a regex that matches a vowel followed by a
digit.
%
\commandlinefollow{ant -Dregex=[aeiou][0-9] -Dtext=i7 regex-match}
\begin{verbatim}
Regex=|[aeiou][0-9]|    Text=|i7|    Matches=true
\end{verbatim}

Concatenation is associative, meaning that if we have three regexes
\codeVar{x}, \codeVar{y}, and \codeVar{z}, the regexes
\code{(\codeVar{x}\codeVar{y})\codeVar{z}} and
\code{\codeVar{x}(\codeVar{y}\codeVar{z})} match exactly the same set
of strings.  Because parentheses may be used for groups (see
\refsec{regex-groups}), the two regexes do not always behave exactly
the same way.  


\section{Disjunction}

If \codeVar{X} and \codeVar{Y} are regular expressions, the regular
expression \codeVar{x}\code{|}\codeVar{y} matches any string that
matches either \codeVar{X} or \codeVar{Y} (or both).  For example,
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=ab regex-match}
\begin{verbatim}
Regex=|ab|cd|
Text=|ab|
Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=cd regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|cd|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex="ab|cd" -Dtext=bc regex-match}
\begin{verbatim}
Regex=|ab|cd|    Text=|bc|    Matches=false
\end{verbatim}
%
Concatenation takes precedence over disjunction, so that \code{ab|cd}
is read as \code{(ab)|(cd)}, not \code{a(b|c)d}.  

The order of disjunctions doesn't matter for matching (other than for
efficiency), but it matters for the find operation.  For finds,
disjunctions are evaluated left-to-right and the first match returned.
%
\commandlinefollow{ant -Dregex="ab|abc" -Dtext=abc regex-find}
\begin{verbatim}
Found |ab| at (0,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="abc|ab" -Dtext=abc regex-find}
\begin{verbatim}
Found |abc| at (0,3)
\end{verbatim}
%

Because complex disjunctions are executed through backtracking,
disjunctions that have to explore many branches can quickly lead to
inefficient regular expressions.  Even a regex as short as
\code{(a|b)(c|d)(e|f)} has $2^3 = 8$ possible search paths to explore.
Each disjunction doubles the size of the search space, leading to
exponential growth in the search space in the number of interacting
disjunctions.  In practice, disjunctions often fail earlier.  For
instance, if there is no match for \code{a|b}, further
disjunctions are not explored.  

A simple pathological case can be created by concatenating instances
of the regex \code{(|a)} and then matching a long string of \code{a}
characters.  You can try it out yourself with
%
\commandline{ant -Dregex="(|a)(|a)...(|a)(|a)" -Dtext=aa...aa regex-find}
%
where the elipses are meant to indicate further copies of \code{a}.
This expression will explore every branch of every disjunction.
Around 25 or 26 copies of \code{(|a)} there are tens of millions of
paths to explore, and with 30, there's over a billion.  You'll be
waiting a while for an answer.  But if the building block is
\code{(a|b)}, there's no problem, because each disjunction has to
match \code{a}.
%
\commandline{ant -Dregex="(b|a)(b|a)...(b|a)(b|a)" -Dtext=aa...aa regex-find}

\section{Greedy Quantifiers}

There are operators for optionality or multiple instances that go
under the general heading of ``greedy'' because of they match as
many times as they can.  In the next section, we consider their
``reluctant'' counterparts that do the opposite.

\subsection{Optionality}

The simplest greedy quantifier is the optionality marker.  The regex
\code{\codeVar{A}?} matches a string that matches \codeVar{A} or the
empty string.  For example,
%
\commandlinefollow{ant -Dregex=a? -Dtext=a regex-match}
\begin{verbatim}
Regex=|a?|    Text=|a|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=a? -Dtext={\bk}"{\bk}" regex-match}
\begin{verbatim}
Regex=|a?|    Text=||    Matches=true
\end{verbatim}

The greediness of the basic optionality marker, which tries to match
before trying to match the empty string, is illustrated using
\code{find()},
%
\commandlinefollow{ant -Dregex=a? -Dtext=aa regex-find}
\begin{verbatim}
Found |a| at (0,1)    Found |a| at (1,2)    Found || at (2,2)
\end{verbatim}
%
The first two substrings found match \code{a} rather than
the empty string.  Only when we are at position 2, at the
end of the string, do we match the empty string because we
can no longer match \code{a}.

The greediness of optionality means that the \code{\codeVar{A}?}
behaves like the disjunction \code{(\codeVar{A}|)} of \codeVar{A} and
the empty string.  Because it is the first disjunct, a match
against \codeVar{A} is tried first.


\subsection{Kleene Star}

A regular expression \codeVar{x} may have the Kleene-star operator%
%
\footnote{Named after Stephen Kleene, who invented regular expressionsn
as a notation for his characterization of regular languages.}
%
applied to it to produce the regular expression \codeVar{A}\code{*}.
The regex \codeVar{A}\code{*} matches a string if the string is
composed of a sequence of zero or more matches of \codeVar{A}.  For
example, \code{[01]*} matches any sequence composed only of \code{0}
and \code{1} characters,
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext=00100100 regex-match}
\begin{verbatim}
Regex=|[01]*|    Text=|00100100|    Matches=true
\end{verbatim}
%
It will also match the empty string, but will not match a string with
any other character.

Using find, the standard Kleene-star operation is greedy in that it
consumes as much as it can during a \code{find()} operation.  For
example, consider
%
\commandlinefollow{ant -Dregex="[01]*" -Dtext=001a0100 regex-find}
\begin{verbatim}
Found |001| at (0,3)    Found || at (3,3)    Found |0100| at (4,8)
Found || at (8,8)
\end{verbatim}
%
The first result of calling \code{find()} consumes the expression
\code{[01]} as many times as possible, consuming the first three
characters, \code{001}.  After that, the expression matches the empty
string spanning from 3 to 3.  It then starts at position 4, finding
\code{0100} and then the empty string again after that.  Luckily,
\code{find()} is implemented cleverly enough that it only returns the
empty string once.  

Kleene star may also be understood in terms of disjunction, though
recursion is required.  The greedy Kleene star regex
\code{\codeVar{A}*} behaves like \code{(\codeVar{A}(\codeVar{A}*))|}.
Thus it first tries to match \codeVar{A} followed by another match of
\code{\codeVar{A}*}, and only failing that tries to match the
empty string.

Kleene star interacts with disjunction in the expected way.  For
example, matching may match an entire string, as with
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext=abcab regex-match}
\begin{verbatim}
Regex=|(ab|abc)*|    Text=|abcab|    Matches=true
\end{verbatim}
%
while finding returns only an initial match, 
%
\commandlinefollow{ant -Dregex="(ab|abc)*" -Dtext=abcab regex-find}
\begin{verbatim}
Found |ab| at (0,2)    Found || at (2,2)    Found |ab| at (3,5)
Found || at (5,5)
\end{verbatim}
%
This is a result of the greediness of the Kleene-star operator
and the evaluation order of disjunctions.  If we reorder, we 
get the whole string,
%
\commandlinefollow{ant -Dregex="(abc|ab)*" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abcab| at (0,5)    Found || at (5,5)
\end{verbatim}
%
because we first match \code{abc} against the disjunct, then continue
trying to match \code{(abc|ab)*}, which matches \code{ab}.

\subsection{Kleene Plus}

The Kleene-plus operator is like the Kleene star, but requires at
least one match.  Thus \codeVar{A}\code{+} matches a string if the
string is composed of a sequence of one or more matches of
\codeVar{A}.  The Kleene-plus operator may be defined in terms
of Kleene star and concatenation, with \code{\codeVar{A}+} behaving
just like \code{\codeVar{A}\codeVar{A}*}.  

Use Kleene plus instead
of star to remove those pesky empty string matches.  For instance, 
%
\commandlinefollow{ant -Dregex="(abc|ab)+" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abcab| at (0,5)
\end{verbatim}

\subsection{Match Count Ranges}

We can specify an exact number or a range of possible number of
matches.  The regular expression \code{\codeVar{A}\{\codeVar{m}\}}
matches any string that that may be decomposed into a sequence of
\codeVar{m} strings, each of which matches \codeVar{A}.
%
\commandlinefollow{ant -Dregex="a\{3\}" -Dtext=aaa regex-match}
\begin{verbatim}
Regex=|a{3}|    Text=|aaa|    Matches=true
\end{verbatim}
%

There is similar notation for spans of counts.  The regex
\code{\codeVar{A}\{\codeVar{m},\codeVar{n}\}} matches any string that
may be decomposed into a sequence of between \codeVar{m} (inclusive)
and \codeVar{n} (inclusive) matches of \codeVar{A}.  The greediness
comes in because it prefers to match as many instances as possible.
For example,
%
\commandlinefollow{ant -Dregex="a\{2,3\}" -Dtext=aaaaa regex-find}
\begin{verbatim}
Found |aaa| at (0,3)    Found |aa| at (3,5)
\end{verbatim}
%
The first result found matches the regex \code{a} three times
rather than twice.  

There is also an open-ended variant.  The regex
\code{\codeVar{A}\{\codeVar{m},\}} matches any string that can be
decomposed into \codeVar{m} or more strings each of which matches
\codeVar{A}.

\section{Reluctant Quantifiers}

There are a range of reluctant quantifiers that parallel the more
typical greedy quantifiers.  For matching, the relunctant quantifiers
behave just like their greedy counterparts, whereas for find
operations, reluctant quantifiers try to match as little as possible.

The reluctant quantifiers are written like the greedy quantifiers
followed by a question mark.  For instance, \code{\codeVar{A}*?}  is
the reluctant version of the Kleene star regex \code{\codeVar{A}*},
\code{\codeVar{A}\{m,n\}?} is the reluctant variant of the range egex
\code{\codeVar{A}\{m,n\}}, and \code{\codeVar{A}??} is the reluctant
variant of the optionality regex \code{\codeVar{A}?}.

Reluctant quantifiers may be understood by reversing all the disjuncts
in the definitions of the greedy quantifier equivalents.  For
instance, we can think of \code{\codeVar{A}??} as
\code{\codeVar{(|\codeVar{A})}} and \code{\codeVar{A}*?} as
\code{(|\codeVar{A}\codeVar{A}*?)}. 

Here we repeat some key examples of the previous section using reluctant
quantifiers.
%
\commandlinefollow{ant -Dregex=a?? -Dtext=aa regex-find}
\begin{verbatim}
Found || at (0,0)    Found || at (1,1)    Found || at (2,2)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="(abc|ab)+?" -Dtext=abcab regex-find}
\begin{verbatim}
Found |abc| at (0,3)    Found |ab| at (3,5)
\end{verbatim}
%
\commandlinefollow{ant -Dregex="a\{2,3\}?" -Dtext=aaaaa regex-find}
\begin{verbatim}
Found |aa| at (0,2)    Found |aa| at (2,4)
\end{verbatim}
%


\section{Possessive Quantifiers}

The third class of quantified expression is the possessive quantifier.
Possessive quantifiers will not match a fewer number of instances of
their pattern if they can match more.  Procedurally, they commit to
a match once they've made it and do not allow backtracking.

The syntax for a possessive quantifier follows the quantifier symbol
with a plus sign (\code{+}); for instance, \code{?+} is possessive
optionality and \code{*+} is greedy Kleene star.

Consider the difference between a greedy Kleene star
%
\commandlinefollow{ant "-Dregex=[0-9]*1" -Dtext=1231 regex-match}
\begin{verbatim}
Regex=|[0-9]*1|    Text=|1231|    Matches=true
\end{verbatim}
%
which matches, and a possessive Kleene star,
%
\commandlinefollow{ant "-Dregex=[0-9]*+1" -Dtext=1231 regex-match}
\begin{verbatim}
Regex=|[0-9]*+1|    Text=|1231|    Matches=false
\end{verbatim}
%
which does not match.  Even though \code{[0-9]*} indicates a greedy
match, it is able to back off and only match the first three
characters of the input, \code{123}.  The possessive quantifier, once
it has matched \code{1231}, does not let it go, and the overall match
fails.

\section{Non-Capturing Regexes}

Some regexes match virtual positions in an input without consuming any
text themselves.


\subsection{Begin and End of Line}


The caret (\code{\^{}}) is a regular expression that matches the end
of a line and the dollar sign (\code{\$}) a regular expression
matching the beginning of a line.  For example, 
%
\commandlinefollow{ant -Dregex="\^{}abc\$" -Dtext=abc regex-match}
\begin{verbatim}
Regex=|^abc$|    Text=|abc|    Matches=true
\end{verbatim}
%
\commandlinefollow{ant -Dregex=ab\$c -Dtext=abc regex-match}
\begin{verbatim}
Regex=|ab$c|    Text=|abc|    Matches=false
\end{verbatim}
%
The begin- and end-of-line regexes do not themselves consume any
characters.

These begin-of-line and end-of-line regexes do not match new lines
inside of strings unless the \code{MULTILINE} flag is set (see
\refsec{pattern-modes}).  By default, these regexes match new-line
sequences for any platform (Unix, Macintosh, or Windows).  If the
\code{UNIX\_LINES} flag is set, they only match Unix newlines (see
\refsec{pattern-modes}).


\subsection{Line Terminators and Unix Lines}\label{section:regex-lines}

\begin{center}
\begin{tabular}{lll}
\tblhead{Code Point(s)} & \tblhead{Description} & \tblhead{Java} 
\\ \hline
\unicode{000A} & \unicodedesc{line feed} & \code{{\bk}n}
\\
\unicode{000D} & \unicodedesc{carriage return} & \code{{\bk}r}
\\
\unicode{000D}, \unicode{000A} & \unicodedesc{carriage return},
\unicodedesc{line feed} & \code{{\bk}r{\bk}n}
\\
\unicode{0085} & \unicodedesc{next line} & \code{{\bk}u0085} 
\\
\unicode{2028} & \unicodedesc{line separator} & \code{{\bk}u2028}
\\
\unicode{2029} & \unicodedesc{paragraph separator} & \code{{\bk}u2029}
\end{tabular}
\end{center}


\section{Parentheses for Grouping}\label{section:regex-groups}

Parentheses play the usual role of grouping in regular expressions,
and may be used to disambiguate what would otherwise be misparsed.
For instance, the expression \code{(a|b)c} is very different than
\code{a|(bc)}.

Parentheses also play the role of identifying the subexpressions
they wrap.  

If \codeVar{A} is a regular expression, \code{(\codeVar{A})} is a
regular expression that matches exactly the same strings as
\codeVar{A}.  Note that parentheses come in matched pairs, and
each picks out the unique subexpression \codeVar{A} it wraps.

The pairs of parentheses in a regular expression are numbered
from left to right, beginning with 1.  For example, we've written
a very simple regex with the identifier of each parentheses group
on the next line
%
\begin{verbatim}
(a(b(cd)(e)))
1 2 3   4
\end{verbatim}
%
Group 1 is \code{a(b(cd)(e))}, group 2 is \code{b(cd)(e)},
group 3 is \code{cd}, and group 4 is \code{e}.

After a match or a find operation, the substring of the match that
matched each group is available from the matcher with a method
\code{group(int)}, where the argument indicates which group's match
is returned.  

There is an implicit pair of parentheses around the entire pattern,
with group number 0.  The method \code{group()} we used earlier to
retrieve the match of the entire string is just shorthand for
\code{group(0)}.

The total number of groups in the regex is available through
the method \code{groupCount()}.  

We provide a simple class \code{RegexGroup} to illustrate the workings
of group extraction.  The work is done in the \code{main()} method
by the code
%
\codeblock{RegexGroup.1}

The identity of the groups are useful for back references (see
\refsec{regex-back-references}) and replace operations (see
\refsec{regex-replace}).



\section{Back References}\label{section:regex-back-references}

The regex \code{\bk\codeVar{n}} is a back reference to the match of
the \codeVar{n}-th capturing group before it.  




\section{Pattern Match Flags}\label{section:pattern-modes}

There are a set of flags, all represented as static integer constants
in \code{Pattern}, which may be supplied to the pattern compiler
factory method \code{Pattern.compile(String,int)} to control the
matching behavior of the compiled pattern.  The most important of
these for our purposes are the following.
%
\begin{center}
\begin{tabular}{lp{0.65\textwidth}}
\tblhead{Constant Flag} & \tblhead{Description} 
\\ \hline { } \\[-6pt]
\code{DOTALL}
& Allows the wild card (\code{.}) expression to match any
character, including line terminators.  If this mode is not
set, the wild card does not match line terminators.
\\[4pt]
\code{MULTLINE}
& Allows the begin-of-line (\code{\^{}}) and end-of-line (\code{\$}) to
match internal line terminators.  If this is not set, they only
match before the first and after the last character.  The full Java
notion of newline is used unless the flag \code{UNIX\_LINES} is also set.
\\[4pt]
\code{UNIX\_LINES}
& Treat newlines as in Unix, with a single \unicode{000A},
\unicodedesc{line feed}, Java string escape \code{{\bk}n},
representing a new line.  This affects the behavior of wildcard
(\code{.}) and begin-of-line (\code{\^{}}) and end-of-line 
(\code{\$}) expressions. 
\\[4pt] 
\code{CASE\_INSENSITIVE} 
& Matching is insensitive to case.  Case folding is only for
the ASCII charset (\unicode{0000} to \unicode{007F}) unless
the flag \code{UNICODE\_CASE} is also set, which uses the Unicode
definitions of case folding.
\\[4pt]
\code{UNICODE\_CASE}
& If this flag and the \code{CASE\_INSENSITIVE} flag is set,
matching ignores case distinctions as defined by Unicode
case folding rules.
\\[4pt]
\code{CANON\_EQ} 
& Matches are based on canonical equivalence in Unicode 
(see \refsec{unicode-normalization-forms}).
\end{tabular}
\end{center}

The flags are defined using a bit-mask pattern whereby multiple
flags are set by taking their bitwise or value.  For instance,
the expression \code{DOTALL~|~MULTILINE} allows the wildcard
to match anything and the line-terminator expressions to match
internal newlines.  More than two flags may be set this way,
so we could further restrict to Unix newlines with
\code{DOTALL~|~MULTILINE~|~UNIX\_LINES}.

Even stronger matching than canonical equivalence with unicode case
folding can be achieved by writinger the regular expression using
compatibility normal forms and using the ICU package to perform a
compatibility decomposition on the input (see
\refsec{unicode-normalization-forms}).


\section{Pattern Construction Exceptions}

Attempting to compile a regular expression with a syntax error raises
a runtime exception, \code{PatternSyntaxException} from the
\code{java.util.regex} package.  The parser tries to provide a helpful
warning message.  For instance, here's what we see if we inadvertently
add a right parenthesis to our regex.
%
\commandlinefollow{ant -Dregex=aa) -Dtext=aaab regex-find}
\begin{verbatim}
Exception in thread "main" 
    java.util.regex.PatternSyntaxException:  
    Unmatched closing ')' near index 1
\end{verbatim}


\section{Replace Operations}



\section{Thread Safety, Serialization, and Reuse}

\subsection{Thread Safety}

Because instances of \code{Pattern} are immutable, it is safe to use
them concurrently in multiple threads.  Because instances of
\code{Matcher} contain the state of the current match, it is not
thread safe to use matchers concurrently without synchronization.

\subsection{Reusing Matchers}

Matchers may be reused.  The method \code{reset()} may be called on a
matcher to reset it to behave as if it had just been constructed with
its given pattern and character sequence.  The character sequence may
be changed.  The pattern may also be changed on the fly, without
changing the current position.  This may be useful if you alternately
match first one pattern then another.  Although matchers may be
reused, the typical usage pattern is to construct them for a text, use
them once, then discard them.


\subsection{Serialization}

Patterns are serializable.  The string representing the pattern and
the compilation flags are stored and the version read back in is an
instance of \code{Pattern} behaving just like the original.  Often
patterns do not need to be serialized because they're effectively
singletons \ie{constants}.






